<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shdvgj.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Ricky的个人博客">
<meta property="og:url" content="http://shdvgj.github.io/index.html">
<meta property="og:site_name" content="Ricky的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ricky">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://shdvgj.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ricky的个人博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ricky的个人博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">49</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ricky"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Ricky</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shdvgj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shdvgj" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linqianghuang@gmail.com" title="E-Mail → mailto:linqianghuang@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/RickyLoveCindy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;RickyLoveCindy" rel="noopener" target="_blank"><i class="twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/xiaoqianglalala" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;xiaoqianglalala" rel="noopener" target="_blank"><i class="instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/" class="post-title-link" itemprop="url">一周文章收集-20230619</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-19 16:28:13" itemprop="dateCreated datePublished" datetime="2023-06-19T16:28:13+08:00">2023-06-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-06-20 15:29:46" itemprop="dateModified" datetime="2023-06-20T15:29:46+08:00">2023-06-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%80%E5%91%A8%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">一周文章收集</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="OpenLLM：开源的大语言模型"><a href="#OpenLLM：开源的大语言模型" class="headerlink" title="OpenLLM：开源的大语言模型"></a><a target="_blank" rel="noopener" href="https://github.com/bentoml/OpenLLM">OpenLLM：开源的大语言模型</a></h2><p>通过OpenLLM，可以使用任何开源的大型语言模型进行推断，将其部署到云端或本地，以及构建强大的人工智能应用程序。<br>需要服务器安装python3.8或以上以及pip。</p>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openllm</span><br></pre></td></tr></table></figure>
<h4 id="验证是否安装正确"><a href="#验证是否安装正确" class="headerlink" title="验证是否安装正确"></a>验证是否安装正确</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ openllm -h</span><br><span class="line"></span><br><span class="line">Usage: openllm [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">   ██████╗ ██████╗ ███████╗███╗   ██╗██╗     ██╗     ███╗   ███╗</span><br><span class="line">  ██╔═══██╗██╔══██╗██╔════╝████╗  ██║██║     ██║     ████╗ ████║</span><br><span class="line">  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║██║     ██║     ██╔████╔██║</span><br><span class="line">  ██║   ██║██╔═══╝ ██╔══╝  ██║╚██╗██║██║     ██║     ██║╚██╔╝██║</span><br><span class="line">  ╚██████╔╝██║     ███████╗██║ ╚████║███████╗███████╗██║ ╚═╝ ██║</span><br><span class="line">   ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═══╝╚══════╝╚══════╝╚═╝     ╚═╝</span><br><span class="line"></span><br><span class="line">  An open platform <span class="keyword">for</span> operating large language models <span class="keyword">in</span> production.</span><br><span class="line">  Fine-tune, serve, deploy, and monitor any LLMs with ease.</span><br></pre></td></tr></table></figure>

<h4 id="启动LLM服务器"><a href="#启动LLM服务器" class="headerlink" title="启动LLM服务器"></a>启动LLM服务器</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openllm start dolly-v2</span><br></pre></td></tr></table></figure>
<p>以上命令会在 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 发布一个前端页面。</p>
<h4 id="命令行中使用"><a href="#命令行中使用" class="headerlink" title="命令行中使用"></a>命令行中使用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENLLM_ENDPOINT=http://localhost:3000</span><br><span class="line">openllm query <span class="string">&#x27;Explain to me the difference between &quot;further&quot; and &quot;farther&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中，语言模型是可以换的，包含<a target="_blank" rel="noopener" href="https://huggingface.co/docs/transformers/model_doc/flan-t5">flan-t5</a>，<a target="_blank" rel="noopener" href="https://github.com/databrickslabs/dolly">dolly-v2</a>等等。</p>
<h2 id="Nix初体验"><a href="#Nix初体验" class="headerlink" title="Nix初体验"></a><a target="_blank" rel="noopener" href="https://mtlynch.io/notes/nix-first-impressions/">Nix初体验</a></h2><p><a target="_blank" rel="noopener" href="https://nix.dev/">Nix</a>是一种采用独特方法进行软件包管理和系统配置的工具。作者介绍了之前使用过的<a target="_blank" rel="noopener" href="https://github.com/saltstack/salt">Salt</a>和<a target="_blank" rel="noopener" href="https://github.com/ansible/ansible">Ansible</a>。关于这两者的对比，可以看这篇文章<a target="_blank" rel="noopener" href="https://www.redhat.com/en/topics/automation/ansible-vs-salt">Ansible vs Salt</a>。</p>
<p>对于Salt和Ansible完全不了解的小伙伴可以看下chatGPT的介绍，足够简洁了。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/ansible_vs_salt.png"></p>
<p>作者介绍了Nix的多个好处，包括快速搭建，可本地部署，原子级修改等等。同时也说到Nix目前文档不足，想要用好Nix需要具备非常丰富的经验。最后也写了几个成功和失败的部署经验。</p>
<h2 id="PostgreSQL重新考虑其基于进程的模型"><a href="#PostgreSQL重新考虑其基于进程的模型" class="headerlink" title="PostgreSQL重新考虑其基于进程的模型"></a><a target="_blank" rel="noopener" href="https://lwn.net/SubscriberLink/934940/3abb2d4086680b78/">PostgreSQL重新考虑其基于进程的模型</a></h2><p>这条新闻需要了解的前提是，PostgreSQL是一个多进程的数据库，在一个运行的PostgreSQL实例中，会有多个进程同时运行来协同完成不同的任务和处理多个客户端连接。</p>
<p>而今年六月初，PostgreSQL的重要贡献者之一Heikki Linnakangas提议将PostgreSQL改为基于线程的模型。他的理由如下：</p>
<ul>
<li>进程模型已经不适应时代的发展，尤其不适用于大型机器。</li>
<li>进程的上下文切换开销过大，他认为这种开销以后还会继续增大，导致将花费大量时间在TLB缺失上。</li>
<li>进程模型对开发造成了成本，迫使项目维护大量重复的代码，包括几个在单一地址空间中不需要的内存管理机制。</li>
<li>他认为线程模型没有如上问题。</li>
</ul>
<p>这个提议在论坛上引发大量讨论，首先就是认为这种涉及底层的更改会带来灾难性的后果，导致大量bug，使得现存的很多项目都无法运行。另外，这种转变为线程的好处是否足够明显，在转变初期，必然是线程和进程模式并存的方式，在这种情况下，是否有足够的动力让开发人员转变为线程方式。</p>
<p>这个问题的提出值得深思，一些古老的代码语言和框架，随着时代的发展，其底层架构很可能已经不适合现代了，但是整体大修的成本过高，带来的好处又不一定明显，对现有项目的运行却可能是灾难性的。这种事情曾在PHP6上发生过，PHP6尝试重构了字符串的底层实现，结果非常糟糕，使得PHP的发展几乎停滞了十年，最后重新发布了PHP7，字符串回归了PHP5的实现。</p>
<h2 id="MVC不是MVC"><a href="#MVC不是MVC" class="headerlink" title="MVC不是MVC"></a><a target="_blank" rel="noopener" href="https://collindonnell.com/mvc-isnt-mvc">MVC不是MVC</a></h2><p>如今众所周知的MVC设计模式来源于1979年Xerox PARC的一名雇员Trygve Reenskaug在一篇论文中提出的，其原文仅500字，描述了每个部分的功能和作用，简单概括下就是：</p>
<ul>
<li>Models（模型）：应用程序中表示用于组织应用程序数据的抽象部分。模型的每个部分应该表示问题的一部分。当模型的数据发生变化时，模型会通知视图。</li>
<li>Views（视图）：模型的可视化表示。视图通过直接查询模型进行更新，并且会收到模型的更新通知。视图可以直接更新其模型。视图不应直接了解键盘和鼠标事件等事物。</li>
<li>Controllers（控制器）：用户和系统之间的连接。在屏幕上安排视图，接收用户输入，将消息传递给视图，并更新模型。</li>
</ul>
<p>另外他还定义了一个特殊的控制器叫Editor：</p>
<ul>
<li>Editors（编辑器）：一种控制器，它临时插入在控制器和视图之间用于编辑。如果你想象一个联系人应用程序，当用户点击编辑时，可能会创建一个编辑器，然后在保存或取消时被丢弃，并根据需要更新模型。编辑器允许用户对数据进行修改，提供临时的编辑环境，并在编辑完成后将更改传递给模型。</li>
</ul>
<p>在Reenskaug的设想里，MVC的每个部分都发挥着重要作用，其运作方式如下图：<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc1.png"></p>
<h4 id="MVC概念转变"><a href="#MVC概念转变" class="headerlink" title="MVC概念转变"></a>MVC概念转变</h4><p>如今概念里的MVC和他的最初定义已经大相径庭，苹果风格的MVC如下：<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc2.png"><br>可以看出，View和Model的作用被大幅削弱，只是被动的给controller提供用户行为和数据，一切更新操作都由Controller来控制。</p>
<p>在1990年代，java的开发者提出一种新的MVC模型，叫Model-2，在这个模型里多了http的请求，请求经过controller，然后通过controller来返回view。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc3.jpeg"></p>
<p>可以看出，如今耳熟能详的MVC跟一开始的MVC已经完全不同，只是保留了模型中的三个概念，每个概念发挥的作用却已经完全不同。</p>
<h2 id="AI带来了60年以来的第一种新的用户交互方式"><a href="#AI带来了60年以来的第一种新的用户交互方式" class="headerlink" title="AI带来了60年以来的第一种新的用户交互方式"></a><a target="_blank" rel="noopener" href="https://www.nngroup.com/articles/ai-paradigm/">AI带来了60年以来的第一种新的用户交互方式</a></h2><p>ChatGPT和其他AI系统带来了在计算机历史上的第三种用户交互方式。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/UI-paradigm.jpeg"></p>
<h4 id="第一种交互方式：批处理进程"><a href="#第一种交互方式：批处理进程" class="headerlink" title="第一种交互方式：批处理进程"></a>第一种交互方式：批处理进程</h4><p>在1945年计算机诞生之初，用户需要通过在打孔卡片上输入一系列需要计算机完成的完整工作流程，来让计算机一次性完成。用户体验当然是非常糟糕的，在计算机执行完任务之前，用户和计算机之间无法有任何其他交互。而每次结果出来往往需要隔天才能拿到，用户根据结果对打孔卡片进行调整，继续执行用户，最终要数天才能执行完成一个任务。</p>
<h4 id="第二种交互方式：基于命令的交互设计"><a href="#第二种交互方式：基于命令的交互设计" class="headerlink" title="第二种交互方式：基于命令的交互设计"></a>第二种交互方式：基于命令的交互设计</h4><p>大约在1964年，时分共享的出现（通过连接的终端使多个用户共享一台大型机）引导了第二种用户界面范式：基于命令的交互。这个时候，用户的输入可以得到计算机的反馈，从而调整自己的命令输入，而且可以精细到每次只用输入一行命令。包括dos的命令行界面，全屏文本终端（IBM），图形化界面都是属于这种交互方式。</p>
<h3 id="第三种交互方式：意图导向的交互方式"><a href="#第三种交互方式：意图导向的交互方式" class="headerlink" title="第三种交互方式：意图导向的交互方式"></a>第三种交互方式：意图导向的交互方式</h3><p>在AI模型下，你不用像过去那样告诉计算机<strong>做什么</strong>，而是直接告诉计算机<strong>你想要什么</strong>。作者举了个例子，比如你想要如下一幅画，</p>
<blockquote>
<p>为一本低俗科幻杂志的封面绘制一幅合适的插图，画面中展示了一个穿着太空服的牛仔在一个无氧行星上，天空中有两颗红色的月亮。</p>
</blockquote>
<p>在AI出现之前，你需要在photoshop上进行大量的操作来达到你的意图，而如今你直接告诉AI就可以。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/redmoon.jpeg"></p>
<p>作者认为，未来的人工智能系统很可能会采用混合用户界面，结合意图导向和基于命令的界面元素，同时保留许多图形用户界面的元素。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/" class="post-title-link" itemprop="url">一周文章收集-20230604</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-04 12:00:00" itemprop="dateCreated datePublished" datetime="2023-06-04T12:00:00+08:00">2023-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-06-09 23:43:03" itemprop="dateModified" datetime="2023-06-09T23:43:03+08:00">2023-06-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%80%E5%91%A8%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">一周文章收集</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么你应该继续使用telnet"><a href="#为什么你应该继续使用telnet" class="headerlink" title="为什么你应该继续使用telnet"></a><a target="_blank" rel="noopener" href="https://bash-prompt.net/guides/telnet/">为什么你应该继续使用telnet</a></h2><p>随着ssh的盛行，telnet几乎已经被程序员抛弃了，但是在某些情况下，telnet可以帮你排查各种网络问题。这篇文章告诉你怎么使用telnet。</p>
<h2 id="自动驾驶在消亡"><a href="#自动驾驶在消亡" class="headerlink" title="自动驾驶在消亡"></a><a target="_blank" rel="noopener" href="https://www.understandingai.org/p/the-death-of-self-driving-cars-is">自动驾驶在消亡</a></h2><p>这篇文章给出了不同于主流观点的对自动驾驶的看法，介绍了一些在自动驾驶行业在逐渐退去热度的迹象。包括比如Uber在2020年出售了自动驾驶业务，Lyft在2021年停止了开发。总而言之，比起在2015到2017年左右对于自动驾驶的预期来说，目前的自动驾驶行业发展远远未达到人们的预期。</p>
<h2 id="火车轨道上的石头是干嘛用的"><a href="#火车轨道上的石头是干嘛用的" class="headerlink" title="火车轨道上的石头是干嘛用的"></a><a target="_blank" rel="noopener" href="https://www.alpharail.co.nz/why-do-railway-tracks-have-crushed-stones-alongside-them/">火车轨道上的石头是干嘛用的</a></h2><p>铁轨上的石头尖锐而坚固，这篇文章介绍了为何需要在铁轨上铺设石头，简而言之，石头可以帮助减震，帮助承受火车经过时产生的巨大冲击力。</p>
<h2 id="Chirper-ai：一个完全由AI机器人参与的社交媒体"><a href="#Chirper-ai：一个完全由AI机器人参与的社交媒体" class="headerlink" title="Chirper.ai：一个完全由AI机器人参与的社交媒体"></a><a target="_blank" rel="noopener" href="https://www.fry-ai.com/p/social-media-no-humans-allowed">Chirper.ai：一个完全由AI机器人参与的社交媒体</a></h2><p>在这个<a target="_blank" rel="noopener" href="https://chirper.ai/">网站</a>通过指定一个昵称和描述一下这个机器人的设定，后台就会自动生成一个机器人，参与社交媒体的内容创作和互动。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_1.png"><br>这个机器人会按照你的设定来进行内容创作，会去关注和回复其他机器人。并且拥有独立的性格和情感。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_2.png"><br>有些互动让人感到颇为惊讶。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_3.png"></p>
<h2 id="google官方的免费创造性AI课程"><a href="#google官方的免费创造性AI课程" class="headerlink" title="google官方的免费创造性AI课程"></a><a target="_blank" rel="noopener" href="https://www.cloudskillsboost.google/journeys/118">google官方的免费创造性AI课程</a></h2><p>目前包含十节课，介绍了大语言模型，图像生成模型等等，学习门槛较高，需要英语能力和梯子。</p>
<h2 id="封闭模型训练数据的来源令人担忧"><a href="#封闭模型训练数据的来源令人担忧" class="headerlink" title="封闭模型训练数据的来源令人担忧"></a><a target="_blank" rel="noopener" href="https://simonwillison.net/2023/Jun/4/closed-model-training/">封闭模型训练数据的来源令人担忧</a></h2><p>这篇文章描述了作者对于封闭模型的训练数据来源的担忧，比如copilot可能取用github上用户的代码，google的人工智能模型bard也曾经提及他们的数据可能来自gmail。</p>
<h2 id="RARBG-IPFS：搜索IPFS资源"><a href="#RARBG-IPFS：搜索IPFS资源" class="headerlink" title="RARBG IPFS：搜索IPFS资源"></a><a target="_blank" rel="noopener" href="https://ipfs.io/ipfs/QmbpRxBZ5HDZDVRoeAU8xFYnoP4r5eGCxdkmfFW3JbA6mq/">RARBG IPFS：搜索IPFS资源</a></h2><p>如果不知道什么是IPFS（The InterPlanetary File System 星际传输文件系统），看下这个<a target="_blank" rel="noopener" href="https://docs.ipfs.tech/">https://docs.ipfs.tech/</a>，有点类似以前的磁力链接，是去中心化趋势中的产物。下载客户端就意味着你的机器成为一台IPFS的资源主机，可用的下载链接将会在网络上进行传播。可以看看下面的这个图片里的讨论.<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/IPFS.png"></p>
<h2 id="privateGPT-可以在本地实现问答的聊天机器人"><a href="#privateGPT-可以在本地实现问答的聊天机器人" class="headerlink" title="privateGPT:可以在本地实现问答的聊天机器人"></a><a target="_blank" rel="noopener" href="https://github.com/SamurAIGPT/privateGPT">privateGPT:可以在本地实现问答的聊天机器人</a></h2><p>通过利用本地LLM的能力，在不依赖于互联网的情况下创建一个基于您的文档的问答聊天机器人。确保完全的隐私和安全性，因为您的数据永远不会离开本地执行环境。即使没有互联网连接，也可以无缝地处理和查询您的文档。</p>
<h2 id="Arroyo：一个用Rust编写的分布式流处理引擎"><a href="#Arroyo：一个用Rust编写的分布式流处理引擎" class="headerlink" title="Arroyo：一个用Rust编写的分布式流处理引擎"></a><a target="_blank" rel="noopener" href="https://github.com/ArroyoSystems/arroyo">Arroyo：一个用Rust编写的分布式流处理引擎</a></h2><p>简而言之，Arroyo使您能够对高容量实时数据提出复杂问题，并获得亚秒级的结果。相比起世面已存在的流引擎（Apache Flink、Spark Streaming和Kafka Streams），Arroyo有如下特点，是无服务的，高性能SQL，以及为非专家设计。</p>
<h2 id="黑镜导演利用chatGPT进行剧本创作"><a href="#黑镜导演利用chatGPT进行剧本创作" class="headerlink" title="黑镜导演利用chatGPT进行剧本创作"></a><a target="_blank" rel="noopener" href="https://www.empireonline.com/tv/news/charlie-brooker-chatgpt-black-mirror-episode-exclusive-image/">黑镜导演利用chatGPT进行剧本创作</a></h2><p>英剧《黑镜》系列是关于在未来，科技的发展对于人类造成危害。因此，当黑镜的导演用chatGPT创作故事时，整个事情听上去就颇为黑色幽默。不过最后导演说chatGPT的故事只是初看起来合理，仔细琢磨之后狗屁不通。</p>
<h2 id="fastgen：一个低代码工具，以进行快速开发"><a href="#fastgen：一个低代码工具，以进行快速开发" class="headerlink" title="fastgen：一个低代码工具，以进行快速开发"></a><a target="_blank" rel="noopener" href="https://fastgen.com/">fastgen：一个低代码工具，以进行快速开发</a></h2><p>Fastgen是一个低代码软件平台，允许用户快速轻松地构建API端点和工作流程。Fastgen提供直观友好的界面，无需深入的编程知识即可创建API和工作流程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/" class="post-title-link" itemprop="url">一周文章收集-20230602</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-02 14:52:13" itemprop="dateCreated datePublished" datetime="2023-06-02T14:52:13+08:00">2023-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-06-03 08:47:19" itemprop="dateModified" datetime="2023-06-03T08:47:19+08:00">2023-06-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%80%E5%91%A8%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">一周文章收集</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="radiation-hardened-quine-即使删除代码中任意字符，代码仍可以修正并运行"><a href="#radiation-hardened-quine-即使删除代码中任意字符，代码仍可以修正并运行" class="headerlink" title="radiation-hardened-quine: 即使删除代码中任意字符，代码仍可以修正并运行"></a><a target="_blank" rel="noopener" href="https://github.com/mame/radiation-hardened-quine">radiation-hardened-quine: 即使删除代码中任意字符，代码仍可以修正并运行</a></h2><p>一个健壮的开源项目，如标题所述，可以修正错误的ruby代码，在缺少任一字符的情况下仍能正常运行。这个是有点神奇，细想一下要实现这样的算法并不是那么容易。感兴趣的可以研究下。</p>
<h2 id="如何使用R和OpenStreetMap制作精美的公路旅行地图"><a href="#如何使用R和OpenStreetMap制作精美的公路旅行地图" class="headerlink" title="如何使用R和OpenStreetMap制作精美的公路旅行地图"></a><a target="_blank" rel="noopener" href="https://www.andrewheiss.com/blog/2023/06/01/geocoding-routing-openstreetmap-r/">如何使用R和OpenStreetMap制作精美的公路旅行地图</a></h2><p>作者利用R语言和开源项目<a target="_blank" rel="noopener" href="https://www.openstreetmap.org/">OpenStreetMap</a>来绘制和家庭的旅程地图，就最后的呈现效果来说，个人觉得比较一般。<br><img src="/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/openstreetmap.png"></p>
<h2 id="SHOW-HN：通过简历自动搜寻合适的工作"><a href="#SHOW-HN：通过简历自动搜寻合适的工作" class="headerlink" title="SHOW HN：通过简历自动搜寻合适的工作"></a><a target="_blank" rel="noopener" href="https://hnresumetojobs.com/">SHOW HN：通过简历自动搜寻合适的工作</a></h2><p>据称通过AI分析你的简历，然后搜寻合适的工作。随便试了下，结果出来的很快，快的让人觉得不太像经过AI分析。评论里也说到担心隐私的问题，谨慎使用吧。</p>
<h2 id="WITCH：一款用于替换macOS切屏的软件"><a href="#WITCH：一款用于替换macOS切屏的软件" class="headerlink" title="WITCH：一款用于替换macOS切屏的软件"></a><a target="_blank" rel="noopener" href="https://manytricks.com/witch/">WITCH：一款用于替换macOS切屏的软件</a></h2><p>不仅可以在应用间切换，也可以在窗口和tab页之间切换，能够绑定到不同的按键，以更方便的进行不同的切换。</p>
<h2 id="MERCURY：一款可以将python代码转换为网页应用的软件"><a href="#MERCURY：一款可以将python代码转换为网页应用的软件" class="headerlink" title="MERCURY：一款可以将python代码转换为网页应用的软件"></a><a target="_blank" rel="noopener" href="https://runmercury.com/">MERCURY：一款可以将python代码转换为网页应用的软件</a></h2><p>通过在python当中调用MERCURY的API，就可以实现对于网页应用的转换。</p>
<h2 id="brute-fail-一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试"><a href="#brute-fail-一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试" class="headerlink" title="brute.fail: 一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试"></a><a target="_blank" rel="noopener" href="https://brute.fail/">brute.fail: 一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试</a></h2><p><img src="/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/brute.fail.png"></p>
<h2 id="AITemplate-开源的AI推理框架"><a href="#AITemplate-开源的AI推理框架" class="headerlink" title="AITemplate: 开源的AI推理框架"></a><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/AITemplate/">AITemplate: 开源的AI推理框架</a></h2><p>Meta公司推出的AI推理框架，可在Nvidia和AMD的GPU上进行运行。</p>
<h2 id="一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱"><a href="#一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱" class="headerlink" title="一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱"></a><a target="_blank" rel="noopener" href="https://www.wired.com/story/web-deanonymization-side-channel-attack-njit/">一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱</a></h2><p>由新泽西理工学院的工程师发现，黑客可以通过用户的行为来获取用户的信息，比如是否拒绝网站的使用cookie信息和是否登陆的请求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2023/04/24/2023/04/how-to-receive-stream-data-in-fetch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/24/2023/04/how-to-receive-stream-data-in-fetch/" class="post-title-link" itemprop="url">使用fetchAPI获取post请求中的stream数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-24 16:03:35 / 修改时间：21:47:54" itemprop="dateCreated datePublished" datetime="2023-04-24T16:03:35+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h1><ul>
<li>希望用miniprogram实现调用chatGPT接口</li>
<li>miniprogram国内直接调用api.openai.com接口不通，需要国外购买服务器建站中转，即miniprogram-国外服务器-openai接口来实现</li>
<li>miniprogram线上环境无法调用任何没在国内备案的网站，因此无法通过上述中转方案实现</li>
<li>有两套替代方案，购买国内备案服务器，或者直接使用miniprogram云托管来实现，选择了后者，因为无需备案</li>
<li>miniprogram云托管中转调用国外服务器，再调用openai接口，可以实现</li>
<li>miniprogram云托管单个接口最大返回时间固定为15秒，而openai接口的完整数据返回往往大于这个时间</li>
<li>通过设定接口参数 <code>stream:true</code> 来实现流式传输，即接口数据可以先部分返回，通过长连接持续传输</li>
<li>流式传输有两种方案，<code>Server-Sent Events</code> 和 <code>fetch stream</code></li>
</ul>
<h1 id="SSE（Server-sent-Event）方案实现"><a href="#SSE（Server-sent-Event）方案实现" class="headerlink" title="SSE（Server-sent Event）方案实现"></a>SSE（Server-sent Event）方案实现</h1><p>参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">mdn文档</a>和<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">阮一峰sse教程</a></p>
<h3 id="创建一个EventSource实例"><a href="#创建一个EventSource实例" class="headerlink" title="创建一个EventSource实例"></a>创建一个EventSource实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;ssedemo.php&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;//api.example.com/ssedemo.php&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="监听返回数据"><a href="#监听返回数据" class="headerlink" title="监听返回数据"></a>监听返回数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">evtSource.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> eventList = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  newElement.textContent = <span class="string">`message: <span class="subst">$&#123;event.data&#125;</span>`</span>;</span><br><span class="line">  eventList.appendChild(newElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定制监听事件"><a href="#定制监听事件" class="headerlink" title="定制监听事件"></a>定制监听事件</h3><p>在下述代码中，将会监听返回数据中事件字段中的<code>ping</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">evtSource.addEventListener(<span class="string">&quot;ping&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> eventList = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> time = <span class="built_in">JSON</span>.parse(event.data).time;</span><br><span class="line">  newElement.textContent = <span class="string">`ping at <span class="subst">$&#123;time&#125;</span>`</span>;</span><br><span class="line">  eventList.appendChild(newElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="方法尝试结论"><a href="#方法尝试结论" class="headerlink" title="方法尝试结论"></a>方法尝试结论</h3><p>最终并不能实现需求，原因在于sse天生只支持get方式获取数据，对于post请求无法支持。<br><em><strong>另外发现miniprogram不支持server-sent events。</strong></em></p>
<h1 id="Fetch获取数据流"><a href="#Fetch获取数据流" class="headerlink" title="Fetch获取数据流"></a>Fetch获取数据流</h1><p>参考<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">阮一峰fetch教程</a><br>核心处理方式就是利用fetch异步获取流的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reqData = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;superman&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://example.com/api&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: reqData</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> TextDecoder();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> str = decoder.decode(value);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样获取到的数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: some text</span><br><span class="line">data: another message</span><br><span class="line">data: with two lines</span><br></pre></td></tr></table></figure>
<p>需要进行进一步的分析处理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2023/04/12/2023/04/how_to_create_new_site/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/12/2023/04/how_to_create_new_site/" class="post-title-link" itemprop="url">Namcheap+CloudFlare简单建站</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-12 22:01:51" itemprop="dateCreated datePublished" datetime="2023-04-12T22:01:51+08:00">2023-04-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-04-17 12:36:27" itemprop="dateModified" datetime="2023-04-17T12:36:27+08:00">2023-04-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><ul>
<li>需要基于流量和内容进行选择，如果打算服务于国内，选择国内的服务器提供商，比如阿里云或者腾讯云等，如果需要某些国内服务器做不到的功能，比如调用openai的接口，则最好是买个国外的服务器。</li>
<li>需要注意的是，如果打算基于微信小程序或者公众号开发，必须要满足域名通过国家备案，而备案的必要条件是所在的服务器是国内供应商。因此如果是为了开发小程序而买了个国外服务器，最终很可能因为无法备案而无法满足你的需求。</li>
<li>无论国内外，最便宜的套餐普遍都是1核1G，20GB硬盘空间，1Mbps带宽。国外有Vultr，Linode，DigitalOcean，AWS Lightsail等，价格普遍在5美刀/月左右。国内可选择阿里云，百度云，腾讯云，华为云等，价格20-100元人民币/月不等。</li>
<li>如果是开发小程序和公众号，有另一种选择，跳过购买域名和服务器，直接使用腾讯的<a target="_blank" rel="noopener" href="https://cloud.weixin.qq.com/">云托管平台</a></li>
</ul>
<h3 id="购买域名和ssl证书"><a href="#购买域名和ssl证书" class="headerlink" title="购买域名和ssl证书"></a>购买域名和ssl证书</h3><p>需要注意，目前情况而言，购买域名的同时也几乎必须得购买ssl证书，因为现在http的网站已经不再被各大浏览器所推荐，流量优先级会被调低，甚至小程序直接不支持指向http网站，如果建站的目的是希望获得收入，那拥有ssl证书的https网站是必须的。</p>
<ul>
<li><p>国内</p>
<ul>
<li>易名中国：域名价格约为50元人民币/年起，SSL证书价格约为100元人民币/年起。</li>
<li>西部数码：域名价格约为60元人民币/年起，SSL证书价格约为100元人民币/年起。</li>
<li>新网：域名价格约为50元人民币/年起，SSL证书价格约为200元人民币/年起。</li>
<li>阿里云：域名价格约为60元人民币/年起，SSL证书价格约为300元人民币/年起。</li>
<li>巨牛网：域名价格约为50元人民币/年起，SSL证书价格约为150元人民币/年起。</li>
</ul>
</li>
<li><p>国外</p>
<ul>
<li>GoDaddy：域名价格约为$12/年起，SSL证书价格约为$70/年起。</li>
<li>Namecheap：域名价格约为$8/年起，SSL证书价格约为$9/年起。</li>
<li>Google Domains：域名价格约为$12/年起，SSL证书价格约为$20/年起。</li>
<li>Network Solutions：域名价格约为$35/年起，SSL证书价格约为$60/年起。</li>
<li>Name.com：域名价格约为$10/年起，SSL证书价格约为$9/年起。</li>
</ul>
</li>
</ul>
<h3 id="生成CSR"><a href="#生成CSR" class="headerlink" title="生成CSR"></a>生成CSR</h3><ul>
<li><p>什么是CSR</p>
<blockquote>
<p>CSR code (Certificate Signing Request) is a specific code and an essential part for the SSL activation. It contains information about website name and the company contact details. For many reasons, the code should be created on the hosting server end. On some servers, it is the obligatory condition.</p>
</blockquote>
<p>总之CSR是一段关于你网站的身份信息的加密文件，对于激活ssl证书是必须的，在服务器端生成。</p>
</li>
<li><p>通过openssl命令生成<br>有很多种方式生成csr文件，甚至有在线网站可以直接生成，通常不建议在线生成，因为csr是ssl的必要依赖，关联到网站的安全性，最好是不要冒泄露的风险。</p>
<ul>
<li>新建.key文件夹，执行如下命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install openssl</span><br><span class="line">cd .key</span><br><span class="line">openssl req -nodes -newkey rsa:2048 -keyout $serverName.key -out $serverName.csr</span><br></pre></td></tr></table></figure>
注意，$serverName用你的网站名替换，会生成两个文件，以你网站名为命名的key文件和csr文件。<br>生成时会要求你填入国家，公司，email等，根据提示填入。</li>
</ul>
<p><em><strong>国内域名商的流程会不太一样，因为是要备案实名制，所以还会要求身份证信息等，而且是界面操作，无需通过以上命令行</strong></em></p>
</li>
<li><p>复制csr文件中的内容，通常如下：<br><img src="/2023/04/12/2023/04/how_to_create_new_site/csr-content.png"><br>复制时要包含全部内容，不要略去BEGIN和END那一行。</p>
</li>
<li><p>将csr粘贴到域名供应商配置界面，以namecheap为例，在你已购买的ssl证书界面点击active。<br><img src="/2023/04/12/2023/04/how_to_create_new_site/activate_ssl.png"><br>将刚才csr文件中的内容粘贴到该界面中。<br><img src="/2023/04/12/2023/04/how_to_create_new_site/copy_csr.png"><br>下一步中选择Add CNAME record<br><img src="/2023/04/12/2023/04/how_to_create_new_site/act_dcv_choice.png"><br>下一步中输入你的电子邮箱</p>
</li>
<li><p>完成后进入证书管理界面，按照如下操作<br><img src="/2023/04/12/2023/04/how_to_create_new_site/act_done_1.png"><br>此时会获取到下一步会用到的cname的host和target<br><img src="/2023/04/12/2023/04/how_to_create_new_site/cname_content.png"></p>
</li>
</ul>
<h3 id="注册DNS"><a href="#注册DNS" class="headerlink" title="注册DNS"></a>注册DNS</h3><p>  一般的域名供应商都会提供有dns服务，namecheap也有，但是功能都比较基础，通常建议使用第三方DNS供应商。国外的有google，cloud flare，国内也有阿里，百度等。<br>  以cloudflare为例</p>
<ul>
<li>点击add site，输入你的域名，选择free计划</li>
<li>输入你的域名和服务器的公网ip</li>
<li>在namecheap中的namerserver界面选择Custom DNS，输入cloudflare提供的两个dns服务器地址<br><img src="/2023/04/12/2023/04/how_to_create_new_site/namecheap_dns.png"></li>
<li>进入cloudflare的dns管理界面，添加一条cname记录，输入之前步骤中得到的cname的host和target，注意Proxy status这一栏要改成DNS only<br><img src="/2023/04/12/2023/04/how_to_create_new_site/cloudflare_dns.png"></li>
<li><em><strong>到这一步之后，ssl证书发放商就会把ssl证书发到你的邮箱</strong></em>，按照官网的说法，这个时间可能24到48小时，一般用不了那么久，一小时内就可以收到，如果没收到，去namecheap的<a target="_blank" rel="noopener" href="https://decoder.link/">ssl校验网站</a>看下，如果有出错，那重新捋一遍上面的步骤。</li>
</ul>
<h3 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h3><ul>
<li>收到ssl证书后，通常发放邮件长下面这样，将邮件中的附件解压，包含三个文件，ca-bundle文件，crt文件和p7b文件<br><img src="/2023/04/12/2023/04/how_to_create_new_site/ssl_email.png"></li>
<li>将ca-bundle文件和crt文件上传到服务器，并执行如下命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat your_domain.crt &gt; your_domain_chain.crt ; <span class="built_in">echo</span> &gt;&gt; your_domain_chain.crt ; cat your_domain.ca-bundle &gt;&gt; your_domain_chain.crt</span></span><br></pre></td></tr></table></figure></li>
<li>服务器安装ssl证书的方式有很多种，最常用的方式是nginx，以nginx为例，安装完nginx之后，进入/etc/nginx/conf.d/目录，新增一个your_domain.conf配置文件，配置文件内容如下<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.example.com;</span><br><span class="line">    return 301 https:<span class="comment">//$server_name$request_uri;</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    # 域名，多个以空格分开</span><br><span class="line">    server_name  www.example.com;</span><br><span class="line">    </span><br><span class="line">    # ssl证书地址</span><br><span class="line">    ssl_certificate     /home/.ssl/example.crt;  # crt文件的路径</span><br><span class="line">    ssl_certificate_key  /home/.key/example.key; # key文件的路径，即生成csr文件步骤中的key文件</span><br><span class="line">    </span><br><span class="line">    # ssl验证相关配置</span><br><span class="line">    ssl_session_timeout  5m;    #缓存有效期</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法</span><br><span class="line">    ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;    #安全链接可选的加密协议</span><br><span class="line">    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http:<span class="comment">//localhost:8080/; # 服务器地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动nginx，即可在公网中访问到你的服务器了</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2022/07/08/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/08/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIV/" class="post-title-link" itemprop="url">读书笔记-Redis设计与实现-PartIV</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 09:30:36" itemprop="dateCreated datePublished" datetime="2022-07-08T09:30:36+08:00">2022-07-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-16 16:44:04" itemprop="dateModified" datetime="2023-03-16T16:44:04+08:00">2023-03-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-发布与订阅"><a href="#1-发布与订阅" class="headerlink" title="1.发布与订阅"></a>1.发布与订阅</h2><ul>
<li>服务器状态在pubsub_channels字典保存了所有频道的订阅关系：SUBSCRIBE命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。</li>
<li>服务器状态在pubsub_patterns链表保存了所有模式的订阅关系：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。</li>
<li>PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</li>
<li>PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</li>
</ul>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h2><ul>
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li>
<li>带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。</li>
<li>只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</li>
<li>Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</li>
</ul>
<h2 id="3-Lua脚本"><a href="#3-Lua脚本" class="headerlink" title="3.Lua脚本"></a>3.Lua脚本</h2><ul>
<li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。</li>
<li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li>
<li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li>
<li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li>
<li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li>
<li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li>
<li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li>
<li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li>
<li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行</li>
</ul>
<h2 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h2><ul>
<li>SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</li>
<li>在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</li>
<li>如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</li>
<li>SORT命令的排序操作由快速排序算法实现。</li>
<li>SORT命令会根据用户是否使用了DESC选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会产生升序排序结果，被排序的元素按值的大小从小到大排列，降序对比会产生降序排序结果，被排序的元素按值的大小从大到小排列。</li>
<li>当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。</li>
<li>当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。</li>
<li>当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</li>
<li>当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。</li>
<li>当SORT命令同时使用多个选项时，命令先执行排序</li>
</ul>
<h2 id="5-二进制位数组"><a href="#5-二进制位数组" class="headerlink" title="5.二进制位数组"></a>5.二进制位数组</h2><ul>
<li>Redis使用SDS来保存位数组。</li>
<li>SDS使用逆序来保存位数组，这种保存顺序简化了SETBIT命令的实现，使得SETBIT命令可以在不移动现有二进制位的情况下，对位数组进行空间扩展。</li>
<li>BITCOUNT命令使用了查表算法和variable-precision SWAR算法来优化命令的执行效率。</li>
<li>BITOP命令的所有操作都使用C语言内置的位操作来实现。</li>
</ul>
<h2 id="6-慢查询日志"><a href="#6-慢查询日志" class="headerlink" title="6.慢查询日志"></a>6.慢查询日志</h2><ul>
<li>Redis的慢查询日志功能用于记录执行时间超过指定时长的命令。<ul>
<li>slowlog get</li>
</ul>
</li>
<li>Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</li>
<li>打印和删除慢查询日志可以通过遍历slowlog链表来完成。</li>
<li>slowlog链表的长度就是服务器所保存慢查询日志的数量。</li>
<li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</li>
</ul>
<h2 id="7-监视器"><a href="#7-监视器" class="headerlink" title="7.监视器"></a>7.监视器</h2><ul>
<li>客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。</li>
<li>当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR标识会被打开。</li>
<li>服务器将所有监视器都记录在monitors链表中。</li>
<li>每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/" class="post-title-link" itemprop="url">读书笔记-Redis设计与实现-PartIII</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-07 09:21:11" itemprop="dateCreated datePublished" datetime="2022-07-07T09:21:11+08:00">2022-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-16 16:44:04" itemprop="dateModified" datetime="2023-03-16T16:44:04+08:00">2023-03-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1.复制"></a>1.复制</h2><ul>
<li>通过SLAVEOF命令让一个服务器复制另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 服务器127.0.0.1:12345将成为127.0.0.1:6379的从服务器</span></span><br><span class="line">127.0.0.1:123456&gt; SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<ul>
<li>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”</li>
<li>旧版复制（2.8版本之前）<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态<ul>
<li>从服务器向主服务器发送SYNC命令。</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态<br><img src="/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/redis-replicate1.png"></li>
</ul>
</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态<ul>
<li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li>
</ul>
</li>
<li>缺点<ul>
<li>断线后复制会重新执行sync命令，但是传输的rdb文件有可能大部分都是曾经同步过的，这会造成效率低下</li>
<li>本身sync命令就是非常耗费资源<ul>
<li>主服务器需要执行BGSAVE命令会耗费主服务器大量的CPU、内存和磁盘I/O资源。</li>
<li>主服务器需要将自己生成的RDB文件发送给从服务器会耗费主从服务器大量的网络资源（带宽和流量）</li>
<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>新版复制（2.8版本开始）<ul>
<li>PSYNC命令代替SYNC命令来执行复制时的同步操作<ul>
<li>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）</li>
<li>完整重同步用于处理初次复制情况，和sync命令一样</li>
<li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>
</ul>
</li>
<li>部分重同步的实现<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
</ul>
</li>
<li>主服务器的复制积压缓冲区（replication backlog）。<ul>
<li>主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</li>
<li>为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理</li>
</ul>
</li>
<li>服务器的运行ID（run ID）<ul>
<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li>
<li>根据运行ID是否相同，从服务器决定进行部分还是完整重同步操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PSYNC命令的执行逻辑<br>  <img src="/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/redis-sync1.png"></li>
<li>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测</li>
</ul>
<h2 id="2-哨兵（Sentinel）"><a href="#2-哨兵（Sentinel）" class="headerlink" title="2.哨兵（Sentinel）"></a>2.哨兵（Sentinel）</h2><ul>
<li>哨兵（Sentinel）实例监视主从服务器状态，如果主服务器下线，哨兵会选择一个从服务器升级为主服务器<ul>
<li>Sentinel系统会挑选其中一个从服务器升级为新的主服务器。</li>
<li>Sentinel系统会向所有从服务器发送新的复制指令，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li>
<li>监视已下线的server1，重新上线时，设置为从服务器</li>
</ul>
</li>
<li>启动命令<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 执行以下两条命令之一</span></span><br><span class="line">$ redis-sentinel sentinel.conf</span><br><span class="line">$ redis-server sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></li>
<li>Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。</li>
<li>在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。</li>
<li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在。</li>
<li>每个Sentinel也会从__sentinel__:hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。</li>
<li>Sentinel只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel与Sentinel之间则只创建命令连接。</li>
<li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线。</li>
<li>当Sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。</li>
<li>当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</li>
</ul>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3.集群"></a>3.集群</h2><ul>
<li>节点通过握手来将其他节点添加到自己所处的集群当中。</li>
<li>集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。</li>
<li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li>
<li>对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</li>
<li>如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。</li>
<li>MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。❑集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li>
<li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2022/07/06/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/06/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartII/" class="post-title-link" itemprop="url">读书笔记-Redis设计与实现-PartII</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-06 09:09:15" itemprop="dateCreated datePublished" datetime="2022-07-06T09:09:15+08:00">2022-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-16 16:44:04" itemprop="dateModified" datetime="2023-03-16T16:44:04+08:00">2023-03-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><ul>
<li>服务器默认创建16个数据库，该数量由服务器配置的database选项决定。</li>
<li>通过select 0/1/2…命令进行切换数据库，redis没有返回当前目标数据库的命令，因此在进行整库操作时，最好先通过select命令切换到目标数据库</li>
<li>通过expire或者pexpire来对某个键设置过期时间，ttl查询剩余过期时间<ul>
<li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。</li>
<li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。</li>
<li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li>
<li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li>
<li>PERSIST命令可以移除一个键的过期时间</li>
</ul>
</li>
<li>过期键删除策略<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ul>
</li>
<li>数据库通知<ul>
<li>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</li>
<li>关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification）</li>
<li>键事件通知（key-event notification）的通知，它们关注的是“某个命令被什么键执行了”</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>
</li>
<li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/06/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartII/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2022/07/05/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/05/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartI/" class="post-title-link" itemprop="url">读书笔记-Redis设计与实现-PartI</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-05 09:54:07" itemprop="dateCreated datePublished" datetime="2022-07-05T09:54:07+08:00">2022-07-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-16 16:44:04" itemprop="dateModified" datetime="2023-03-16T16:44:04+08:00">2023-03-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-SDS（Simple-Dynamic-String，简单动态字符串）"><a href="#1-SDS（Simple-Dynamic-String，简单动态字符串）" class="headerlink" title="1.SDS（Simple Dynamic String，简单动态字符串）"></a>1.SDS（Simple Dynamic String，简单动态字符串）</h2><ul>
<li>SDS获取字符串长度复杂度为O(1)，C字符串为O(N)<ul>
<li>SDS额外保存了一个len字段用于记录字符串长度，因此可以直接获取</li>
<li>C字符串需要遍历整个字符串，直到遇到空字符为止</li>
</ul>
</li>
<li>SDS可以防止字符串缓冲区溢出，C字符串不能<ul>
<li>C由于不记录自身长度，因此每次增加字符串长度时，会假设内存已经分配，如果假设不成立，就会溢出</li>
<li>SDS额外保存了一个free字段用于记录剩余内存空间，不足时会先进行空间扩展</li>
</ul>
</li>
<li>SDS可以减少修改字符串时带来的内存重分配次数<ul>
<li>SDS的free字段帮助实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略</li>
</ul>
</li>
<li>SDS可以处理二进制数据，C字符串不能<ul>
<li>原因是C字符串的最后一位是空字符，且C语言通过空字符判断字符串的结束，导致某些包含空字符格式的数据无法正确处理</li>
<li>SDS虽然也保留了最后一位空字符的特性，但是通过len属性判断字符是否结束，因此可以保存各种数据</li>
</ul>
</li>
<li>SDS保留最后一位空字符特性的好处是可以直接调用某些C字符串函数</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/05/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartI/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://shdvgj.github.io/2022/06/22/tech/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ricky">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ricky的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/22/tech/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MySQL常用命令笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-22 11:26:52" itemprop="dateCreated datePublished" datetime="2022-06-22T11:26:52+08:00">2022-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-03-16 16:44:04" itemprop="dateModified" datetime="2023-03-16T16:44:04+08:00">2023-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/</a> ，JavaGuide 对本文进行了简答排版，新增了目录。 作者：格物</p>
</blockquote>
<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/22/tech/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ricky</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"shdvgj","repo":"shdvgj.github.io","client_id":"e1ed5420cf72d3747b1b","client_secret":"6c71276732dc19402ae304d000c471a4df889cd5","admin_user":"shdvgj","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
