<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java新特性总结</title>
    <url>/2022/06/20/blog/Java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h2><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>让 java 也能支持简单的函数式编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Runnable 接口 **/</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Comparator 接口**/</span></span><br><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comperator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comperator);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。<strong>可以想象成是 Sql 语句</strong>。</p>
<p>它的源数据可以是 Collection、Array 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="keyword">long</span> count = stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics statistics = number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    Stream stream = strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Optional表达式"><a href="#Optional表达式" class="headerlink" title="Optional表达式"></a>Optional表达式</h3><p>主要用于解决NPE问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的方式</span></span><br><span class="line">Zoo zoo = getZoo();</span><br><span class="line"><span class="keyword">if</span>(zoo != <span class="keyword">null</span>)&#123;</span><br><span class="line">   Dog dog = zoo.getDog();</span><br><span class="line">   <span class="keyword">if</span>(dog != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> age = dog.getAge();</span><br><span class="line">      System.out.println(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Optional方式</span></span><br><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Interface新增默认方法，可以用default-或-static修饰"><a href="#Interface新增默认方法，可以用default-或-static修饰" class="headerlink" title="Interface新增默认方法，可以用default 或 static修饰"></a>Interface新增默认方法，可以用default 或 static修饰</h3><p>目的：避免接口新增方法时，所有实现的类也必须跟着修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">def</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">def2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    LocalDate date = LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    LocalTime time = LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String dateTimeStr = dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">    </span><br><span class="line">    LocalDate date = LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>);</span><br><span class="line">    LocalDate.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">    LocalDateTime.parse(<span class="string">&quot;2021-01-26 12:12:22&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    LocalTime time = LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">    LocalTime.parse(<span class="string">&quot;12:12:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><h3 id="接口私有方法"><a href="#接口私有方法" class="headerlink" title="接口私有方法"></a>接口私有方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。目前能想到的最大的作用<strong>就是可以用于验证一些代码中的小问题</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jshell &gt; System.out.print(&quot;HelloWorld&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="集合新增of-方法，用于快速创建集合对象"><a href="#集合新增of-方法，用于快速创建集合对象" class="headerlink" title="集合新增of() 方法，用于快速创建集合对象"></a>集合新增of() 方法，用于快速创建集合对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Set.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Map.of(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String由char-数组改为byte-数组存储"><a href="#String由char-数组改为byte-数组存储" class="headerlink" title="String由char[]数组改为byte[]数组存储"></a>String由char[]数组改为byte[]数组存储</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h3><p>可以看成是大于package小于jar的一种结构，用于代码之间更高效的调用。在每个模块中加入一个module-info.java文件，写入下列描述，用于声明暴露和依赖的模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> modular.demo.persistent &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.hanmc.example.modulardemo.persistent.domain;</span><br><span class="line">    <span class="keyword">exports</span> com.hanmc.example.modulardemo.persistent.dao;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//声明需要依赖的模块</span></span><br><span class="line">    <span class="keyword">requires</span> modular.demo.common;</span><br><span class="line">    <span class="keyword">requires</span> mybatis.plus;</span><br><span class="line">    <span class="keyword">requires</span> mybatis.plus.core;</span><br><span class="line">    <span class="keyword">requires</span> mybatis.plus.annotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目录结构如下：<br><img src="/2022/06/20/blog/Java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/java-new1.jpg"></p>
<h3 id="引入孵化器模块jdk-incubator"><a href="#引入孵化器模块jdk-incubator" class="headerlink" title="引入孵化器模块jdk.incubator"></a>引入孵化器模块jdk.incubator</h3><p>java9开始新特性不再是一定保留，而是会在版本中进行迭代，这些新特性就放在孵化器中，如果随着迭代得以保留就会从孵化器中移出成为正式的特性，不合适的就会直接移除。这大大增强了java新特性开发的灵活性。</p>
<h3 id="G1-成为默认垃圾回收器"><a href="#G1-成为默认垃圾回收器" class="headerlink" title="G1 成为默认垃圾回收器"></a>G1 成为默认垃圾回收器</h3><h3 id="Stream-amp-Optional-增强"><a href="#Stream-amp-Optional-增强" class="headerlink" title="Stream &amp; Optional 增强"></a>Stream &amp; Optional 增强</h3><h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><p>Java 9 增加了 java.lang.ProcessHandle 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前正在运行的 JVM 的进程</span></span><br><span class="line">ProcessHandle currentProcess = ProcessHandle.current();</span><br><span class="line"><span class="comment">// 输出进程的 id</span></span><br><span class="line">System.out.println(currentProcess.pid());</span><br><span class="line"><span class="comment">// 输出进程的信息</span></span><br><span class="line">System.out.println(currentProcess.info());</span><br></pre></td></tr></table></figure>

<h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><h3 id="局部变量类型推断-var"><a href="#局部变量类型推断-var" class="headerlink" title="局部变量类型推断(var)"></a>局部变量类型推断(var)</h3><p>var 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> codefx = <span class="keyword">new</span> URL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">var</span> p = Paths.of(<span class="string">&quot;src/test/java/Java9FeaturesTest.java&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numbers = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n : list)</span><br><span class="line">    System.out.print(n+ <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count=<span class="keyword">null</span>; <span class="comment">//❌编译不通过，不能声明为 null</span></span><br><span class="line"><span class="keyword">var</span> r = () -&gt; Math.random();<span class="comment">//❌编译不通过,不能声明为 Lambda表达式</span></span><br><span class="line"><span class="keyword">var</span> array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//❌编译不通过,不能声明数组</span></span><br></pre></td></tr></table></figure>
<h3 id="若干性能的提升"><a href="#若干性能的提升" class="headerlink" title="若干性能的提升"></a>若干性能的提升</h3><h4 id="G1-并行-Full-GC"><a href="#G1-并行-Full-GC" class="headerlink" title="G1 并行 Full GC"></a>G1 并行 Full GC</h4><p>从java9的单线程标记-清除-压缩算法转为并行算法，从而有效的减少stop-the-world的时间</p>
<h4 id="Application-Class-Data-Sharing-程序class数据文件共享"><a href="#Application-Class-Data-Sharing-程序class数据文件共享" class="headerlink" title="Application Class-Data Sharing 程序class数据文件共享"></a><a href="https://www.baeldung.com/java-10-performance-improvements">Application Class-Data Sharing 程序class数据文件共享</a></h4><p>AppCDS原本是商业特性，现在免费开源了。<br>我的理解，简单来说是将类加载器中的类生成一份共享档案文件，从而在jvm启动时直接读取内存中的对应类，可以加快jvm的启动速度。</p>
<h4 id="Experimental-Java-Based-JIT-Compiler-实验性的基于-Java-的-JIT-编译器"><a href="#Experimental-Java-Based-JIT-Compiler-实验性的基于-Java-的-JIT-编译器" class="headerlink" title="Experimental Java-Based JIT Compiler 实验性的基于 Java 的 JIT 编译器"></a><a href="https://www.baeldung.com/java-10-performance-improvements#experimental-java-based-jit-compiler">Experimental Java-Based JIT Compiler 实验性的基于 Java 的 JIT 编译器</a></h4><p>Graal 是一种java编写的动态编译器，可实现更高的性能和拓展性。同时也是java9中介绍过的Ahead-of-Time（AOT）编译器的基础。<br>加入以下参数开启Graal虚拟机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure>


<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增copyOf，拷贝一个不可变的集合</span></span><br><span class="line"><span class="meta">@Test(expected = UnsupportedOperationException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenModifyCopyOfList_thenThrowsException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; copyList = List.copyOf(someIntList);</span><br><span class="line">    copyList.add(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collectors新增toUnmodifiableList方法将集合变为不可变</span></span><br><span class="line"><span class="meta">@Test(expected = UnsupportedOperationException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenModifyToUnmodifiableList_thenThrowsException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; evenList = someIntList.stream()</span><br><span class="line">      .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">      .collect(Collectors.toUnmodifiableList());</span><br><span class="line">    evenList.add(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional增加orElseThrow-方法"><a href="#Optional增加orElseThrow-方法" class="headerlink" title="Optional增加orElseThrow() 方法"></a>Optional增加orElseThrow() 方法</h3><h3 id="容器意识"><a href="#容器意识" class="headerlink" title="容器意识"></a>容器意识</h3><p>现在jvm能够知道自己在容器中运行，增加了几种容器中的jvm参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-UseContainerSupport</span><br><span class="line">-XX:ActiveProcessorCount=count</span><br><span class="line">-XX:InitialRAMPercentage</span><br><span class="line">-XX:MaxRAMPercentage</span><br><span class="line">-XX:MinRAMPercentage</span><br></pre></td></tr></table></figure>

<h3 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h3><p>现在java的证书密钥库包含了一些根证书，可用于对若干安全协议建立可信的证书连接。此功能被oracle从商业特性改为开源特性。</p>
<h3 id="基于时间发布版本"><a href="#基于时间发布版本" class="headerlink" title="基于时间发布版本"></a>基于时间发布版本</h3><p>Java10开始，oracle开始周期性的发布新版本：<br>1.每六个月发布一个java新版本。<br>2.功能性的发布只会支持6个月。<br>3.长期支持的版本会标记为LTS。该版本会支持3年。<br>4.java版本号现在会包含一个时间标示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">openjdk version <span class="string">&quot;10&quot;</span> <span class="number">2018</span>-<span class="number">03</span>-<span class="number">20</span></span><br><span class="line">OpenJDK Runtime Environment <span class="number">18.3</span> (build <span class="number">10</span>+<span class="number">46</span>)</span><br><span class="line">OpenJDK <span class="number">64</span>-Bit Server VM <span class="number">18.3</span> (build <span class="number">10</span>+<span class="number">46</span>, mixed mode)</span><br></pre></td></tr></table></figure>

<h2 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h2><p>Java11是Java8之后第一个长期支持的版本（LTS）。同时Oracle不再提供免费的Oracle JDK版本，但是依然对免费的Open JDK提供支持。</p>
<h3 id="新的String方法"><a href="#新的String方法" class="headerlink" title="新的String方法"></a>新的String方法</h3><p>新增 isBlank, lines, strip, stripLeading, stripTrailing, and repeat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于多行文本的操作</span></span><br><span class="line">String multilineString = <span class="string">&quot;Baeldung helps \n \n developers \n explore Java.&quot;</span>;</span><br><span class="line">List&lt;String&gt; lines = multilineString.lines()</span><br><span class="line">  .filter(line -&gt; !line.isBlank())</span><br><span class="line">  .map(String::strip)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line">assertThat(lines).containsExactly(<span class="string">&quot;Baeldung helps&quot;</span>, <span class="string">&quot;developers&quot;</span>, <span class="string">&quot;explore Java.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="新的Files操作方法"><a href="#新的Files操作方法" class="headerlink" title="新的Files操作方法"></a>新的Files操作方法</h3><p>Files类新增writeString和readString静态方法，现在更容易从文件中操作String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path filePath = Files.writeString(Files.createTempFile(tempDir, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;.txt&quot;</span>), <span class="string">&quot;Sample text&quot;</span>);</span><br><span class="line">String fileContent = Files.readString(filePath);</span><br><span class="line">assertThat(fileContent).isEqualTo(<span class="string">&quot;Sample text&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="集合到数组"><a href="#集合到数组" class="headerlink" title="集合到数组"></a>集合到数组</h3><p>java.util.Collection接口新增默认方法toArray</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List sampleList = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">String[] sampleArray = sampleList.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">assertThat(sampleArray).containsExactly(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="The-Not-Predicate-Method"><a href="#The-Not-Predicate-Method" class="headerlink" title="The Not Predicate Method"></a>The Not Predicate Method</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; sampleList = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;\n \n&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">List withoutBlanks = sampleList.stream()</span><br><span class="line">  .filter(Predicate.not(String::isBlank))</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line">assertThat(withoutBlanks).containsExactly(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Lamda表达式中的本地变量语法"><a href="#Lamda表达式中的本地变量语法" class="headerlink" title="Lamda表达式中的本地变量语法"></a>Lamda表达式中的本地变量语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; sampleList = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>);</span><br><span class="line">String resultString = sampleList.stream()</span><br><span class="line">  .map((<span class="meta">@Nonnull</span> <span class="keyword">var</span> x) -&gt; x.toUpperCase())</span><br><span class="line">  .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">assertThat(resultString).isEqualTo(<span class="string">&quot;JAVA, KOTLIN&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h3><p>新的HTTP API全面提升了性能并且将HTTP的支持从HTTP/1.1提升到了HTTP/2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">  .version(HttpClient.Version.HTTP_2)</span><br><span class="line">  .connectTimeout(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">  .build();</span><br><span class="line">HttpRequest httpRequest = HttpRequest.newBuilder()</span><br><span class="line">  .GET()</span><br><span class="line">  .uri(URI.create(<span class="string">&quot;http://localhost:&quot;</span> + port))</span><br><span class="line">  .build();</span><br><span class="line">HttpResponse httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">assertThat(httpResponse.body()).isEqualTo(<span class="string">&quot;Hello from the server!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="嵌套类访问控制"><a href="#嵌套类访问控制" class="headerlink" title="嵌套类访问控制"></a><a href="https://www.baeldung.com/java-11-new-features#7-nest-based-access-control">嵌套类访问控制</a></h3><h3 id="可直接运行java文件"><a href="#可直接运行java文件" class="headerlink" title="可直接运行java文件"></a>可直接运行java文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java HelloWorld.java</span><br><span class="line">Hello Java <span class="number">11</span>!</span><br></pre></td></tr></table></figure>

<h3 id="Dynamic-Class-File-Constants"><a href="#Dynamic-Class-File-Constants" class="headerlink" title="Dynamic Class-File Constants"></a>Dynamic Class-File Constants</h3><p>个人理解是动态常量池</p>
<h3 id="新增一个消极的垃圾收集器-Epsilon"><a href="#新增一个消极的垃圾收集器-Epsilon" class="headerlink" title="新增一个消极的垃圾收集器 Epsilon"></a>新增一个消极的垃圾收集器 Epsilon</h3><p>不会去进行GC，一般不用于正式的java项目，可用于测试和生命周期极短的项目。<br>启用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</span><br></pre></td></tr></table></figure>

<h3 id="飞行记录器"><a href="#飞行记录器" class="headerlink" title="飞行记录器"></a>飞行记录器</h3><p>Java Flight Recorder (JFR) 现在在OpenJDK开源，使用如下命令运行监控</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:StartFlightRecording=duration=120s,settings=profile,filename=java-demo-app.jfr</span><br></pre></td></tr></table></figure>
<p>会生成一个JFR文件，该文件要使用JDK Mission Control (JMC)进行分析。</p>
<h2 id="Java12"><a href="#Java12" class="headerlink" title="Java12"></a>Java12</h2><h3 id="String增加两个方法indent-和-transform"><a href="#String增加两个方法indent-和-transform" class="headerlink" title="String增加两个方法indent() 和 transform()"></a>String增加两个方法indent() 和 transform()</h3><h3 id="File增加文件对比方法"><a href="#File增加文件对比方法" class="headerlink" title="File增加文件对比方法"></a>File增加文件对比方法</h3><p>可以通过mismatch(Path path, Path path2) 方法来比较两个文件的内容差异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDifferentFiles_thenShouldFindMismatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path filePath3 = Files.createTempFile(<span class="string">&quot;file3&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    Path filePath4 = Files.createTempFile(<span class="string">&quot;file4&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    Files.writeString(filePath3, <span class="string">&quot;Java 12 Article&quot;</span>);</span><br><span class="line">    Files.writeString(filePath4, <span class="string">&quot;Java 12 Tutorial&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mismatch = Files.mismatch(filePath3, filePath4);</span><br><span class="line">    assertEquals(<span class="number">8</span>, mismatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collector新增teeing方法"><a href="#Collector新增teeing方法" class="headerlink" title="Collector新增teeing方法"></a>Collector新增teeing方法</h3><p>这是一个数学方法，典型用法是第一个参数得出总数，第二个参数计算个数，第三个参数将取到前两个参数的值进行平均数计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;T, ?, R&gt; teeing(Collector&lt;? <span class="keyword">super</span> T, ?, R1&gt; downstream1,</span><br><span class="line">  Collector&lt;? <span class="keyword">super</span> T, ?, R2&gt; downstream2, BiFunction&lt;? <span class="keyword">super</span> R1, ? <span class="keyword">super</span> R2, R&gt; merger)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSetOfNumbers_thenCalculateAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mean = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">      .collect(Collectors.teeing(Collectors.summingDouble(i -&gt; i), </span><br><span class="line">        Collectors.counting(), (sum, count) -&gt; sum / count));</span><br><span class="line">    assertEquals(<span class="number">3.0</span>, mean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><p>可以将数字进行格式化，按照某种语言习惯进行转换，比如1000在英语中可以转为1k。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenNumber_thenCompactValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NumberFormat likesShort = </span><br><span class="line">      NumberFormat.getCompactNumberInstance(<span class="keyword">new</span> Locale(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>), NumberFormat.Style.SHORT);</span><br><span class="line">    likesShort.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">    assertEquals(<span class="string">&quot;2.59K&quot;</span>, likesShort.format(<span class="number">2592</span>));</span><br><span class="line"></span><br><span class="line">    NumberFormat likesLong = </span><br><span class="line">      NumberFormat.getCompactNumberInstance(<span class="keyword">new</span> Locale(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>), NumberFormat.Style.LONG);</span><br><span class="line">    likesLong.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">    assertEquals(<span class="string">&quot;2.59 thousand&quot;</span>, likesLong.format(<span class="number">2592</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="预览新特性"><a href="#预览新特性" class="headerlink" title="预览新特性"></a>预览新特性</h3><p>可以输入如下参数开启新特性的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -Xlint:preview --enable-preview -source <span class="number">12</span> src/main/java/File.java</span><br></pre></td></tr></table></figure>

<h4 id="Switch-语法增强"><a href="#Switch-语法增强" class="headerlink" title="Switch 语法增强"></a>Switch 语法增强</h4><p>以前的switch写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();</span><br><span class="line">String typeOfDay = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        typeOfDay = <span class="string">&quot;Working Day&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        typeOfDay = <span class="string">&quot;Day Off&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的switch语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可在一个case中判断多个字段，同时移除break语法，</span></span><br><span class="line">typeOfDay = <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; <span class="string">&quot;Working Day&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="string">&quot;Day Off&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可在case中运行代码</span></span><br><span class="line"><span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; System.out.println(<span class="string">&quot;Working Day&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; System.out.println(<span class="string">&quot;Day Off&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行多行代码</span></span><br><span class="line"><span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; &#123;</span><br><span class="line">    <span class="comment">// more logic</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Working Day&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="instanceof的类型匹配"><a href="#instanceof的类型匹配" class="headerlink" title="instanceof的类型匹配"></a>instanceof的类型匹配</h4><p>以前在instanceof中进行类型判断和使用需要像这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String) obj;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM的修改"><a href="#JVM的修改" class="headerlink" title="JVM的修改"></a>JVM的修改</h3><h4 id="Shenandoah-一个致力于暂停时间短的垃圾收集器"><a href="#Shenandoah-一个致力于暂停时间短的垃圾收集器" class="headerlink" title="Shenandoah 一个致力于暂停时间短的垃圾收集器"></a>Shenandoah 一个致力于暂停时间短的垃圾收集器</h4><h4 id="Microbenchmark-Suite-微基准套件"><a href="#Microbenchmark-Suite-微基准套件" class="headerlink" title="Microbenchmark Suite 微基准套件"></a>Microbenchmark Suite 微基准套件</h4><p>Java12介绍了一组针对Java源码的约100个的微基准测试套件，这些套件可以测试Jvm的性能并帮助开发者在Jvm上进行开发。</p>
<h4 id="CDS-文档变为默认功能"><a href="#CDS-文档变为默认功能" class="headerlink" title="CDS 文档变为默认功能"></a>CDS 文档变为默认功能</h4><p>CDS用于减少JVM启动时间，在Java12中成为默认开启的功能，通过如下命令进行关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xshare:off HelloWorld.java</span><br></pre></td></tr></table></figure>

<h2 id="Java13"><a href="#Java13" class="headerlink" title="Java13"></a>Java13</h2><h3 id="新特性预览，需要手动开启"><a href="#新特性预览，需要手动开启" class="headerlink" title="新特性预览，需要手动开启"></a>新特性预览，需要手动开启</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -Xlint:preview --enable-preview -source <span class="number">12</span> src/main/java/File.java</span><br></pre></td></tr></table></figure>

<h4 id="Switch表达式增强，新增yield语法用于返回值"><a href="#Switch表达式增强，新增yield语法用于返回值" class="headerlink" title="Switch表达式增强，新增yield语法用于返回值"></a>Switch表达式增强，新增yield语法用于返回值</h4><p>用法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;preview&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenSwitchingOnOperationSquareMe_thenWillReturnSquare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> me = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">var</span> operation = <span class="string">&quot;squareMe&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;doubleMe&quot;</span> -&gt; &#123;</span><br><span class="line">            yield me * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;squareMe&quot;</span> -&gt; &#123;</span><br><span class="line">            yield me * me;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> -&gt; me;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">16</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多行文本块"><a href="#多行文本块" class="headerlink" title="多行文本块"></a>多行文本块</h4><p>现在可以更方便的对String进行多行文本的赋值，比如 JSON, XML, HTML 等文本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String JSON_STRING </span><br><span class="line">  = <span class="string">&quot;&#123;\r\n&quot;</span> + <span class="string">&quot;\&quot;name\&quot; : \&quot;Baeldung\&quot;,\r\n&quot;</span> + <span class="string">&quot;\&quot;website\&quot; : \&quot;https://www.%s.com/\&quot;\r\n&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">String TEXT_BLOCK_JSON = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;</span>name<span class="string">&quot; : &quot;</span>Baeldung<span class="string">&quot;,</span></span><br><span class="line"><span class="string">    &quot;</span>website<span class="string">&quot; : &quot;</span>https:<span class="comment">//www.%s.com/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">assertThat(TEXT_BLOCK_JSON.contains(&quot;</span>Baeldung<span class="string">&quot;)).isTrue();</span></span><br><span class="line"><span class="string">assertThat(TEXT_BLOCK_JSON.indexOf(&quot;</span>www<span class="string">&quot;)).isGreaterThan(0);</span></span><br><span class="line"><span class="string">assertThat(TEXT_BLOCK_JSON.length()).isGreaterThan(0);</span></span><br></pre></td></tr></table></figure>

<h3 id="动态CDS归档"><a href="#动态CDS归档" class="headerlink" title="动态CDS归档"></a>动态CDS归档</h3><p>CDS从java10发布，到java12成为默认开启的功能。然而该功能的使用略显繁杂。开发者需要先试运行他们的程序以生成class列表，然后再将其转为归档文件。这之后，这些归档文件才能在虚拟机之间进行数据共享。<br>在Java13中，简化了归档文件的生成步骤。现在我们可以在程序创建的时候就生成共享归档文件。减少了试运行的那一步。我们需要在启动参数中加入-XX:ArchiveClassesAtExit并指定归档文件名来开启该功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -XX:ArchiveClassesAtExit=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在运行相同应用的时候直接使用共享文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -XX:SharedArchiveFile=&lt;archive filename&gt; -cp &lt;app jar&gt; AppName</span><br></pre></td></tr></table></figure>

<h3 id="ZGC释放未使用内存"><a href="#ZGC释放未使用内存" class="headerlink" title="ZGC释放未使用内存"></a>ZGC释放未使用内存</h3><p>在该版本之前，ZGC虽然可以做到STW时间始终低于10ms，但是不像其他垃圾收集器会将未使用的堆内存释放。现在Java13拥有了该功能，并且该功能是默认开启的。并且ZGC现在将最大支持内存从4TB增加到了16TB。</p>
<h3 id="Socket-API重构"><a href="#Socket-API重构" class="headerlink" title="Socket API重构"></a>Socket API重构</h3><p>Socket API发布以来，20年未曾更改，在Java13终于进行了调整。</p>
<h3 id="其他更改"><a href="#其他更改" class="headerlink" title="其他更改"></a>其他更改</h3><ul>
<li>java.nio – method FileSystems.newFileSystem(Path, Map&lt;String, ?&gt;) added</li>
<li>java.time – new official Japanese era name added</li>
<li>javax.crypto – support for MS Cryptography Next Generation (CNG)</li>
<li>javax.security – property jdk.sasl.disabledMechanisms added to disable SASL mechanisms</li>
<li>javax.xml.crypto – new String constants introduced to represent Canonical XML 1.1 URIs</li>
<li>javax.xml.parsers – new methods added to instantiate DOM and SAX factories with namespaces support</li>
<li>Unicode support upgraded to version 12.1</li>
<li>Support added for Kerberos principal name canonicalization and cross-realm referrals</li>
</ul>
<h2 id="Java14"><a href="#Java14" class="headerlink" title="Java14"></a>Java14</h2><h3 id="Switch新语法和文本块语法实装"><a href="#Switch新语法和文本块语法实装" class="headerlink" title="Switch新语法和文本块语法实装"></a>Switch新语法和文本块语法实装</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isTodayHoliday = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MONDAY&quot;</span>, <span class="string">&quot;TUESDAY&quot;</span>, <span class="string">&quot;WEDNESDAY&quot;</span>, <span class="string">&quot;THURSDAY&quot;</span>, <span class="string">&quot;FRIDAY&quot;</span> -&gt; <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SATURDAY&quot;</span>, <span class="string">&quot;SUNDAY&quot;</span> -&gt; <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;What&#x27;s a &quot;</span> + day);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String multiline = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    A quick brown fox jumps over a lazy dog; \</span></span><br><span class="line"><span class="string">    the lazy dog howls loudly.&quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Records-关键字（预览特性）"><a href="#Records-关键字（预览特性）" class="headerlink" title="Records 关键字（预览特性）"></a>Records 关键字（预览特性）</h3><p>可以通过定一个Records类，来减少类中多余的模版代码，Records相当于自动帮你生成了get，equals, hashCode, 构造方法和toString方法。可以看成简化版的lombok。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String password)</span> </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User user1 = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">&quot;UserOne&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenRecord_whenObjInitialized_thenValuesCanBeFetchedWithGetters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, user1.id());</span><br><span class="line">    assertEquals(<span class="string">&quot;UserOne&quot;</span>, user1.password());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenRecord_thenEqualsImplemented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user2 = user1;</span><br><span class="line">    assertTrue(user1, user2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenRecord_thenToStringImplemented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(user1.toString().contains(<span class="string">&quot;UserOne&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NPE-报错增强，现在会准确提示报错在哪一行以及哪一个对象为空。"><a href="#NPE-报错增强，现在会准确提示报错在哪一行以及哪一个对象为空。" class="headerlink" title="NPE 报错增强，现在会准确提示报错在哪一行以及哪一个对象为空。"></a>NPE 报错增强，现在会准确提示报错在哪一行以及哪一个对象为空。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NullPointerException: Cannot store to <span class="keyword">int</span> array because <span class="string">&quot;a&quot;</span> is <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="孵化特性，这些特性放在模块jdk-incubator-中"><a href="#孵化特性，这些特性放在模块jdk-incubator-中" class="headerlink" title="孵化特性，这些特性放在模块jdk.incubator.中"></a>孵化特性，这些特性放在模块jdk.incubator.中</h3><h4 id="访问外部内存的API"><a href="#访问外部内存的API" class="headerlink" title="访问外部内存的API"></a>访问外部内存的API</h4><p>现在允许java程序直接访问外部内存，比如计算机本地内存。</p>
<h4 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h4><p>现在可以通过jlink工具打包，生成在windows中exe文件或者macos中的dmg文件，以实现更方便的双击运行。</p>
<h3 id="ZGC现在可以在Windows和MacOS上使用-实验特性"><a href="#ZGC现在可以在Windows和MacOS上使用-实验特性" class="headerlink" title="ZGC现在可以在Windows和MacOS上使用-实验特性"></a>ZGC现在可以在Windows和MacOS上使用-实验特性</h3><h3 id="为G1-增加-NUMA-内存收集机制"><a href="#为G1-增加-NUMA-内存收集机制" class="headerlink" title="为G1 增加 NUMA 内存收集机制"></a>为G1 增加 NUMA 内存收集机制</h3><h3 id="JFR-事件流，增强了JFR的监控能力，现在可以通过消费者的方式直接获取监控结果"><a href="#JFR-事件流，增强了JFR的监控能力，现在可以通过消费者的方式直接获取监控结果" class="headerlink" title="JFR 事件流，增强了JFR的监控能力，现在可以通过消费者的方式直接获取监控结果"></a>JFR 事件流，增强了JFR的监控能力，现在可以通过消费者的方式直接获取监控结果</h3><h2 id="Java15"><a href="#Java15" class="headerlink" title="Java15"></a>Java15</h2><h3 id="records关键字实装"><a href="#records关键字实装" class="headerlink" title="records关键字实装"></a>records关键字实装</h3><h3 id="sealed，non-sealed，permits关键字"><a href="#sealed，non-sealed，permits关键字" class="headerlink" title="sealed，non-sealed，permits关键字"></a>sealed，non-sealed，permits关键字</h3><p>这些关键字提供了更精细的类之间的访问控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Employee</span>, <span class="title">Manager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上语法的效果是Person类将只能被Employee, Manager类继承。<br>注意：继承sealed类的子类必须用sealed, non-sealed, 或 final进行修饰，这样可以保证类层次有限，同时被JVM正确识别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> non-sealed <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h3><p>大部分程序员在日常开发中用不到隐藏类，JVM开发者会发现它的好处。隐藏类的目的是在程序运行时创建无法被发现的类。这种类无法被引用，被反射，同时具有较短的生命周期。</p>
<h3 id="模式匹配中的类型检查"><a href="#模式匹配中的类型检查" class="headerlink" title="模式匹配中的类型检查"></a>模式匹配中的类型检查</h3><p>该特性在java14中已经介绍过，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> Employee) &#123;</span><br><span class="line">    Employee employee = (Employee) person;</span><br><span class="line">    Date hireDate = employee.getHireDate();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在java15中该特性得到增强，在类型判断成功后，jvm会自动将该变量赋值为对应类型进行后续操作，如下person对象自动赋值到了employee对象中，可以进行后续的变量操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> Employee employee &amp;&amp; employee.getYearsOfService() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="外部内存API"><a href="#外部内存API" class="headerlink" title="外部内存API"></a>外部内存API</h3><p>JAVA14中已经介绍过访问外部内存的API，在java15中增加若干功能。</p>
<ul>
<li>A new VarHandle API, to customize memory access var handles</li>
<li>Support for parallel processing of a memory segment using the Spliterator interface</li>
<li>Enhanced support for mapped memory segments</li>
<li>Ability to manipulate and dereference addresses coming from things like native calls</li>
</ul>
<h3 id="ZGC和Shenandoah成为可进行选择配置的垃圾收集器，G1依然是默认的垃圾收集器"><a href="#ZGC和Shenandoah成为可进行选择配置的垃圾收集器，G1依然是默认的垃圾收集器" class="headerlink" title="ZGC和Shenandoah成为可进行选择配置的垃圾收集器，G1依然是默认的垃圾收集器"></a>ZGC和Shenandoah成为可进行选择配置的垃圾收集器，G1依然是默认的垃圾收集器</h3><h3 id="Java15中移除偏向锁，RMI，Solaris-SPARC"><a href="#Java15中移除偏向锁，RMI，Solaris-SPARC" class="headerlink" title="Java15中移除偏向锁，RMI，Solaris/SPARC"></a>Java15中移除偏向锁，RMI，Solaris/SPARC</h3><h2 id="Java16"><a href="#Java16" class="headerlink" title="Java16"></a>Java16</h2><h3 id="动态代理现在可以反射接口的默认方法"><a href="#动态代理现在可以反射接口的默认方法" class="headerlink" title="动态代理现在可以反射接口的默认方法"></a>动态代理现在可以反射接口的默认方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object proxy = Proxy.newProxyInstance(getSystemClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; HelloWorld.class &#125;,</span><br><span class="line">    (prox, method, args) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">            <span class="keyword">return</span> InvocationHandler.invokeDefault(prox, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">Method method = proxy.getClass().getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">assertThat(method.invoke(proxy)).isEqualTo(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="日期格式的支持"><a href="#日期格式的支持" class="headerlink" title="日期格式的支持"></a>日期格式的支持</h3><p>通过一个标识符“B”来进行日期格式的转换。更多详细用法<a href="https://www.baeldung.com/java-datetimeformatter">在此</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime date = LocalTime.parse(<span class="string">&quot;15:25:08.690791&quot;</span>);</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;h B&quot;</span>);</span><br><span class="line">assertThat(date.format(formatter)).isEqualTo(<span class="string">&quot;3 in the afternoon&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Stream-类增加toList方法"><a href="#Stream-类增加toList方法" class="headerlink" title="Stream 类增加toList方法"></a>Stream 类增加toList方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; integersAsString = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; ints = integersAsString.stream().map(Integer::parseInt).collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; intsEquivalent = integersAsString.stream().map(Integer::parseInt).toList();</span><br></pre></td></tr></table></figure>

<h3 id="Vector-API-Incubator"><a href="#Vector-API-Incubator" class="headerlink" title="Vector API Incubator"></a>Vector API Incubator</h3><h3 id="Records关键字功能增强"><a href="#Records关键字功能增强" class="headerlink" title="Records关键字功能增强"></a>Records关键字功能增强</h3><h3 id="instanceof模式匹配和Sealed关键字实装"><a href="#instanceof模式匹配和Sealed关键字实装" class="headerlink" title="instanceof模式匹配和Sealed关键字实装"></a>instanceof模式匹配和Sealed关键字实装</h3><h2 id="Java17"><a href="#Java17" class="headerlink" title="Java17"></a>Java17</h2><h3 id="浮点型计算将保证在不同的平台保持严格相同的结果"><a href="#浮点型计算将保证在不同的平台保持严格相同的结果" class="headerlink" title="浮点型计算将保证在不同的平台保持严格相同的结果"></a>浮点型计算将保证在不同的平台保持严格相同的结果</h3><h3 id="伪随机数生成器增强"><a href="#伪随机数生成器增强" class="headerlink" title="伪随机数生成器增强"></a>伪随机数生成器增强</h3><p>java17为伪随机数生成器新增了几个接口和实现。将更容易使用不同的算法并更好的支持stream为基础的编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntStream <span class="title">getPseudoInts</span><span class="params">(String algorithm, <span class="keyword">int</span> streamSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// returns an IntStream with size @streamSize of random numbers generated using the @algorithm</span></span><br><span class="line">    <span class="comment">// where the lower bound is 0 and the upper is 100 (exclusive)</span></span><br><span class="line">    <span class="keyword">return</span> RandomGeneratorFactory.of(algorithm)</span><br><span class="line">            .create()</span><br><span class="line">            .ints(streamSize, <span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Applet-API-被移除"><a href="#Applet-API-被移除" class="headerlink" title="Applet API 被移除"></a>Applet API 被移除</h3><h3 id="对JDK的内部类更严格的封装，比如sun-misc-Unsafe，将保证开发者无法访问到此类方法"><a href="#对JDK的内部类更严格的封装，比如sun-misc-Unsafe，将保证开发者无法访问到此类方法" class="headerlink" title="对JDK的内部类更严格的封装，比如sun.misc.Unsafe，将保证开发者无法访问到此类方法"></a>对JDK的内部类更严格的封装，比如sun.misc.Unsafe，将保证开发者无法访问到此类方法</h3><h3 id="switch中的模式匹配"><a href="#switch中的模式匹配" class="headerlink" title="switch中的模式匹配"></a>switch中的模式匹配</h3><p>之前已经介绍过的instanceOf中的模式匹配，该功能进一步增强了switch的语法能力，如下，obj的类型转换直接发生在case关键字中，减少了很多冗余代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> record <span class="title">Human</span> <span class="params">(String name, <span class="keyword">int</span> age, String profession)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkObject</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> Human h -&gt; <span class="string">&quot;Name: %s, age: %s and profession: %s&quot;</span>.formatted(h.name(), h.age(), h.profession());</span><br><span class="line">        <span class="keyword">case</span> Circle c -&gt; <span class="string">&quot;This is a circle&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Shape s -&gt; <span class="string">&quot;It is just a shape&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">null</span> -&gt; <span class="string">&quot;It is null&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;It is an object&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkShape</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">        <span class="keyword">case</span> Triangle t &amp;&amp; (t.getNumberOfSides() != <span class="number">3</span>) -&gt; <span class="string">&quot;This is a weird triangle&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Circle c &amp;&amp; (c.getNumberOfSides() != <span class="number">0</span>) -&gt; <span class="string">&quot;This is a weird circle&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;Just a normal shape&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RMI-功能被移除"><a href="#RMI-功能被移除" class="headerlink" title="RMI 功能被移除"></a>RMI 功能被移除</h3><h3 id="sealed关键字"><a href="#sealed关键字" class="headerlink" title="sealed关键字"></a>sealed关键字</h3><h3 id="移除Ahead-Of-Time-AOT-编译-和-Just-In-Time-JIT-编译方式"><a href="#移除Ahead-Of-Time-AOT-编译-和-Just-In-Time-JIT-编译方式" class="headerlink" title="移除Ahead-Of-Time (AOT) 编译 和 Just-In-Time (JIT) 编译方式"></a>移除Ahead-Of-Time (AOT) 编译 和 Just-In-Time (JIT) 编译方式</h3><p>在JDK9和10中被介绍的特性，在经历了多个版本迭代后，其维护成本过高，因此被移除。</p>
<h3 id="移除-Security-Manager"><a href="#移除-Security-Manager" class="headerlink" title="移除 Security Manager"></a>移除 Security Manager</h3><h3 id="外部方法和外部内存的API（孵化器特性）"><a href="#外部方法和外部内存的API（孵化器特性）" class="headerlink" title="外部方法和外部内存的API（孵化器特性）"></a>外部方法和外部内存的API（孵化器特性）</h3><p>外部方法和的API允许开发者访问JVM虚拟机之外的代码，外部内存的API可以管理堆外内存。其设计目的是为了取代JNI API，并提示其安全性和性能。<br>调用C语言库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SymbolLookup libLookup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// loads a particular C library</span></span><br><span class="line">    <span class="keyword">var</span> path = JEP412.class.getResource(<span class="string">&quot;/print_name.so&quot;</span>).getPath();</span><br><span class="line">    System.load(path);</span><br><span class="line">    libLookup = SymbolLookup.loaderLookup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vector-API（二次孵化）"><a href="#Vector-API（二次孵化）" class="headerlink" title="Vector API（二次孵化）"></a>Vector API（二次孵化）</h3><p>Vector API 处理 SIMD（单指令，多数据）类型的操作，这意味着并行执行的各种指令集。 它利用支持向量指令的专用 CPU 硬件，并允许执行流水线等指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newVectorComputation</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">float</span>[] b, <span class="keyword">float</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i += SPECIES.length()) &#123;</span><br><span class="line">        <span class="keyword">var</span> m = SPECIES.indexInRange(i, a.length);</span><br><span class="line">        <span class="keyword">var</span> va = FloatVector.fromArray(SPECIES, a, i, m);</span><br><span class="line">        <span class="keyword">var</span> vb = FloatVector.fromArray(SPECIES, b, i, m);</span><br><span class="line">        <span class="keyword">var</span> vc = va.mul(vb);</span><br><span class="line">        vc.intoArray(c, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonVectorComputation</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">float</span>[] b, <span class="keyword">float</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">        c[i] = a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化过滤器"><a href="#反序列化过滤器" class="headerlink" title="反序列化过滤器"></a>反序列化过滤器</h3><p>用于验证从不可信任来源发送来的序列化数据，这个过程发生在jvm虚拟机中，提升了安全性和健壮性。</p>
<h3 id="新增一个半年周期-特性的模块"><a href="#新增一个半年周期-特性的模块" class="headerlink" title="新增一个半年周期-特性的模块"></a>新增一个半年周期-特性的模块</h3><p>这个模块帮助开发者减轻开发一个新功能的压力，一个功能首先在该模块中进行试用，之后再发布到LTS模块中。</p>
<h3 id="新增LTS模块"><a href="#新增LTS模块" class="headerlink" title="新增LTS模块"></a>新增LTS模块</h3><blockquote>
<p>参考资料<br><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">https://javaguide.cn/java/new-features/java8-common-new-features.html</a><br><a href="https://javaguide.cn/java/new-features/java9.html">https://javaguide.cn/java/new-features/java9.html</a><br><a href="https://javaguide.cn/java/new-features/java10.html">https://javaguide.cn/java/new-features/java10.html</a><br><a href="https://javaguide.cn/java/new-features/java11.html">https://javaguide.cn/java/new-features/java11.html</a><br><a href="https://javaguide.cn/java/new-features/java12-13.html">https://javaguide.cn/java/new-features/java12-13.html</a><br><a href="https://javaguide.cn/java/new-features/java14-15.html">https://javaguide.cn/java/new-features/java14-15.html</a><br><a href="https://javaguide.cn/java/new-features/java16.html">https://javaguide.cn/java/new-features/java16.html</a><br><a href="https://www.baeldung.com/java-8-new-features">https://www.baeldung.com/java-8-new-features</a><br><a href="https://www.baeldung.com/new-java-9">https://www.baeldung.com/new-java-9</a><br><a href="https://www.baeldung.com/java-10-overview">https://www.baeldung.com/java-10-overview</a><br><a href="https://www.baeldung.com/java-11-new-features">https://www.baeldung.com/java-11-new-features</a><br><a href="https://www.baeldung.com/java-12-new-features">https://www.baeldung.com/java-12-new-features</a><br><a href="https://www.baeldung.com/java-13-new-features">https://www.baeldung.com/java-13-new-features</a><br><a href="https://www.baeldung.com/java-14-new-features">https://www.baeldung.com/java-14-new-features</a><br><a href="https://www.baeldung.com/java-15-new">https://www.baeldung.com/java-15-new</a><br><a href="https://www.baeldung.com/java-16-new-features">https://www.baeldung.com/java-16-new-features</a><br><a href="https://www.baeldung.com/java-17-new-features">https://www.baeldung.com/java-17-new-features</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>一周文章收集-20220117</title>
    <url>/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/</url>
    <content><![CDATA[<p>我发现逐篇翻译看到的技术博文并不是那么高效，还是像阮老师那样把一周看到的有价值的文章收集起来，作为一个归档会更加有用。</p>
<hr>
<h2 id="微软发布了自己的linux版本：CBL-Mariner"><a href="#微软发布了自己的linux版本：CBL-Mariner" class="headerlink" title="微软发布了自己的linux版本：CBL-Mariner"></a><a href="https://github.com/microsoft/CBL-Mariner">微软发布了自己的linux版本：CBL-Mariner</a></h2><p>根据github上的介绍，CBL-Mariner 是微软为了云架构，edge的产品和服务开发的内部linux发行版。CBL-Mariner的设计是为了云设备和服务提供持久化的平台，并使得微软可以跟上linux的更新脚本。这是微软对于linux技术投入的一部分，还包括<a href="https://azure.microsoft.com/en-us/blog/sonic-the-networking-switch-software-that-powers-the-microsoft-global-cloud/">SONiC</a>， <a href="https://docs.microsoft.com/en-us/azure-sphere/product-overview/what-is-azure-sphere">Azure Sphere OS</a> 和 <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a>。</p>
<h2 id="程序员才懂的幽默"><a href="#程序员才懂的幽默" class="headerlink" title="程序员才懂的幽默"></a><a href="https://programmerhumor.io/">程序员才懂的幽默</a></h2><p>一个摸鱼网站，着实不错，里面包含了大量得具有一定开发知识才能懂的段子，是纯英文的，摸鱼的同时也能顺便提升下英文水平（并不）。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/programmerhumor.png"></p>
<h2 id="权力的游戏和指环王等奇幻故事里的地图"><a href="#权力的游戏和指环王等奇幻故事里的地图" class="headerlink" title="权力的游戏和指环王等奇幻故事里的地图"></a><a href="https://www.smithsonianmag.com/smart-news/explore-literary-maps-of-famous-authors-180979409/"><code>权力的游戏</code>和<code>指环王</code>等奇幻故事里的地图</a></h2><p>这篇文章介绍了奇幻小说中的地图，这些地图的创作倾注了作者的心血和巧思，可以给读者带来沉浸的阅读感受。原文中有更多的地图介绍。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/map1.png" alt="`奥德赛`的扉页地图"></p>
<h2 id="13个程序员必看的博客网站"><a href="#13个程序员必看的博客网站" class="headerlink" title="13个程序员必看的博客网站"></a><a href="https://blog.bit.ai/programming-blogs-and-websites/">13个程序员必看的博客网站</a></h2><p>技术博客是程序员保持技术新鲜度非常重要的一个渠道，不仅仅是看其他的技术博客，自己维护一个博客也是很有必要。文章介绍了13个可以提升技术水平的博客网站，可以作为参考。<br>P.S.后面发现里面大部分网站的质量不高，要么得收费，要么更新频率低，要么没啥有价值的文章。。。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/blog.jpg"></p>
<h2 id="深入详解Node-js线程池"><a href="#深入详解Node-js线程池" class="headerlink" title="深入详解Node.js线程池"></a><a href="https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628">深入详解Node.js线程池</a></h2><p>这篇文章介绍了使用BigQuery这个Node插件后出现的错误，应该有点深度，以我有限的Node.js知识和英文水平，并没有怎么看懂。<br>P.S.这个网站居然是收费的，一个月一篇免费博客。。。</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>一周文章收集-20220124</title>
    <url>/2022/01/25/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20220124/</url>
    <content><![CDATA[<h2 id="为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释"><a href="#为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释" class="headerlink" title="为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释"></a><a href="https://www.smithsonianmag.com/smart-news/heres-why-the-word-game-wordle-went-viral-180979439/">为什么网络游戏<code>Wordle</code>病毒式的传播，来听听心理学家的解释</a></h2><p>近期有个网络游戏<code>Wordle</code>在推特上及其流行，这是字谜类的游戏。规则比较简单，玩家需要猜一个5个字母组成的单词。其特别之处在于拥有社交属性，即一盘游戏是需要好几个人参与的，通过不同色块提示字母和位置的正确与否，这样每个人都能看到别人猜的进度，形成一种竞争体验。<br><img src="/2022/01/25/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20220124/wordle.png"></p>
<h2 id="开源工具Arthas在线诊断java程序"><a href="#开源工具Arthas在线诊断java程序" class="headerlink" title="开源工具Arthas在线诊断java程序"></a><a href="https://arthas.aliyun.com/doc/">开源工具Arthas在线诊断java程序</a></h2><p><code>Arthas</code>是Alibaba开源的Java诊断工具，可以实现在线监控执行方法，观测返回值等，在很多特殊的场景下，比如在家里无法部署开发环境却需要检查线上程序具体问题，或者需要查问题的程序只有线上包没有源代码，可以使用Arthas进行在线诊断并处理，以后将会专门写一篇关于如何使用Arthas的文章。</p>
<h2 id="如何在Debian-11安装CSF"><a href="#如何在Debian-11安装CSF" class="headerlink" title="如何在Debian 11安装CSF"></a><a href="https://vitux.com/how-to-install-config-server-firewall-csf-on-debian/">如何在Debian 11安装CSF</a></h2><p>CSF全称是Config Server Firewall，是一套可以轻松对防火墙策略和规则进行配置的防火墙软件，适合不熟悉linux防火墙的新手使用，本文介绍了如何安装和使用CSF，以增强linux的安全性。</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode算法题总结2022.3-2022.5</title>
    <url>/2022/05/09/blog/leetcode%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%932022-3-2022-5/</url>
    <content><![CDATA[<h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>基本思路：动态规划，每个格子依次计算，计算当前格子的最小路径和，因为每次移动必定是往下或者往右，因此每个格子的路径和必定来自于上边格子或者左边格子的数字加上当前格子的数字<br>时间复杂度分析：O(m<em>n)，会遍历所有格子，因此复杂度是n</em>m</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：每次只能向下或者向右移动一步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span></span><br><span class="line"><span class="comment"> * 输出：7</span></span><br><span class="line"><span class="comment"> * 解释：因为路径 1→3→1→1→1 的总和最小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     m == grid.length</span></span><br><span class="line"><span class="comment"> *     n == grid[i].length</span></span><br><span class="line"><span class="comment"> *     1 &lt;= m, n &lt;= 200</span></span><br><span class="line"><span class="comment"> *     0 &lt;= grid[i][j] &lt;= 100</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/minimum-path-sum</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinPathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length ;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j== <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i-<span class="number">1</span>][j] &gt; grid[i][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    grid[i][j] += grid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[i][j] += grid[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(minPathSum(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="排序矩阵查找"><a href="#排序矩阵查找" class="headerlink" title="排序矩阵查找"></a>排序矩阵查找</h2><p>基本思路：从右上角开始遍历，左边是比它小的，下边是比它大的，相当于是一个二叉树遍历<br>时间复杂度分析：O(m<em>n)，会遍历所有格子，因此复杂度是n</em>m</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 现有矩阵 matrix 如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *   [1,   4,  7, 11, 15],</span></span><br><span class="line"><span class="comment"> *   [2,   5,  8, 12, 19],</span></span><br><span class="line"><span class="comment"> *   [3,   6,  9, 16, 22],</span></span><br><span class="line"><span class="comment"> *   [10, 13, 14, 17, 24],</span></span><br><span class="line"><span class="comment"> *   [18, 21, 23, 26, 30]</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定 target = 5，返回 true。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定 target = 20，返回 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/sorted-matrix-search-lcci</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchMatrix</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本思路，从右上角开始遍历，左边是比它小的，下边是比它大的，相当于是一个二叉树遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[n][m] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[n][m] &gt; target) m--;</span><br><span class="line">            <span class="keyword">else</span> n++;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">0</span> || n &gt;= matrix.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(searchMatrix(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;&#125;&#125;, <span class="number">18</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并若干三元组以形成目标三元组"><a href="#合并若干三元组以形成目标三元组" class="headerlink" title="合并若干三元组以形成目标三元组"></a>合并若干三元组以形成目标三元组</h2><p>基本思路：根据题设可知，每次合并都会取各个位置更大的那个数，因此如果一个数组中的任一位置存在比目标数更大的数，则这个数组一定不能进行合并；反之，如果一个数组的任一位置存在目标数，且其他各位置的数都比目标数小，则一定能进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三元组 是一个由三个整数组成的数组。给你一个二维整数数组 triplets ，其中 triplets[i] = [ai, bi, ci] 表示第 i 个 三元组 。同时，给你一个整数数组 target = [x, y, z] ，表示你想要得到的 三元组 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了得到 target ，你需要对 triplets 执行下面的操作 任意次（可能 零 次）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     选出两个下标（下标 从 0 开始 计数）i 和 j（i != j），并 更新 triplets[j] 为 [max(ai, aj), max(bi, bj), max(ci, cj)] 。</span></span><br><span class="line"><span class="comment"> *         例如，triplets[i] = [2, 5, 3] 且 triplets[j] = [1, 7, 5]，triplets[j] 将会更新为 [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过以上操作我们可以使得目标 三元组 target 成为 triplets 的一个 元素 ，则返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：执行下述操作：</span></span><br><span class="line"><span class="comment"> * - 选择第一个和最后一个三元组 [[2,5,3],[1,8,4],[1,7,5]] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],[2,7,5]]</span></span><br><span class="line"><span class="comment"> * 目标三元组 [2,7,5] 现在是 triplets 的一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：triplets = [[1,3,4],[2,5,8]], target = [2,5,8]</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：目标三元组 [2,5,8] 已经是 triplets 的一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：执行下述操作：</span></span><br><span class="line"><span class="comment"> * - 选择第一个和第三个三元组 [[2,5,3],[2,3,4],[1,2,5],[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。</span></span><br><span class="line"><span class="comment"> * - 选择第三个和第四个三元组 [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]] 。</span></span><br><span class="line"><span class="comment"> * 目标三元组 [5,5,5] 现在是 triplets 的一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 4：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：triplets = [[3,4,5],[4,5,6]], target = [3,2,5]</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 解释：无法得到 [3,2,5] ，因为 triplets 不含 2 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTriplets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">mergeTriplets</span><span class="params">(<span class="keyword">int</span>[][] triplets, <span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (triplets == <span class="keyword">null</span> || target == <span class="keyword">null</span> || triplets.length == <span class="number">0</span> || triplets[<span class="number">0</span>].length == <span class="number">0</span> || target.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> one = target[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> two = target[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> three = target[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">boolean</span> oneJudge = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> twoJudge = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> threeJudge = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triplets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!oneJudge &amp;&amp; triplets[i][<span class="number">0</span>] == one &amp;&amp; triplets[i][<span class="number">1</span>] &lt;= two &amp;&amp; triplets[i][<span class="number">2</span>] &lt;= three) oneJudge = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!twoJudge &amp;&amp; triplets[i][<span class="number">1</span>] == two &amp;&amp; triplets[i][<span class="number">0</span>] &lt;= one &amp;&amp; triplets[i][<span class="number">2</span>] &lt;= three) twoJudge = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!threeJudge &amp;&amp; triplets[i][<span class="number">2</span>] == three &amp;&amp; triplets[i][<span class="number">0</span>] &lt;= one &amp;&amp; triplets[i][<span class="number">1</span>] &lt;= two) threeJudge = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (oneJudge &amp;&amp; twoJudge &amp;&amp; threeJudge) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(mergeTriplets(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>&#125;&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>基本思路：本质上是一个将二叉树按大小输出的问题，使用中序遍历可以实现。同时需要将头尾连接，因此存储头部结点，直到中序遍历结束，将最后的结点指向头部结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,Node _left,Node _right)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeToDoublyList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Node head, pre;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中序遍历，按大小输出结点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(node.left);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) head = node;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">            node.left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        dfs(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个相同字符之间的最长子字符串"><a href="#两个相同字符之间的最长子字符串" class="headerlink" title="两个相同字符之间的最长子字符串"></a>两个相同字符之间的最长子字符串</h2><p>基本思路：<br>        1.题设只有小写字母，因此可以用一个容量26的数组来进行存储。<br>        2.按顺序遍历数组，将每个字母出现的位置索引存储在数组中，当找到重复的字母时，将其位置和数组中的索引进行相减，得到的结果和已存储的最大值比较，如果当前结果更大，将最大值替换<br>        3.返回最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子字符串 是字符串中的一个连续字符序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;aa&quot;</span></span><br><span class="line"><span class="comment"> * 输出：0</span></span><br><span class="line"><span class="comment"> * 解释：最优的子字符串是两个 &#x27;a&#x27; 之间的空子字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;abca&quot;</span></span><br><span class="line"><span class="comment"> * 输出：2</span></span><br><span class="line"><span class="comment"> * 解释：最优的子字符串是 &quot;bc&quot; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;cbzxy&quot;</span></span><br><span class="line"><span class="comment"> * 输出：-1</span></span><br><span class="line"><span class="comment"> * 解释：s 中不存在出现出现两次的字符，所以返回 -1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 4：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;cabbac&quot;</span></span><br><span class="line"><span class="comment"> * 输出：4</span></span><br><span class="line"><span class="comment"> * 解释：最优的子字符串是 &quot;abba&quot; ，其他的非最优解包括 &quot;bb&quot; 和 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     1 &lt;= s.length &lt;= 300</span></span><br><span class="line"><span class="comment"> *     s 只含小写英文字母</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/largest-substring-between-two-equal-characters</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxLengthBetweenEqualCharacters</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本思路：遍历一遍，时间复杂度O(N)，通过map存储已经存在的字符，在遍历时再次发现该字符的话就把两个位置的值相减并和已存储的最大值进行比较</span></span><br><span class="line">    <span class="comment">/*static int maxLengthBetweenEqualCharacters(String s) &#123;</span></span><br><span class="line"><span class="comment">        if (s == null || s.length() == 0) return -1;</span></span><br><span class="line"><span class="comment">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        char[] characters = s.toCharArray();</span></span><br><span class="line"><span class="comment">        int result = 0;</span></span><br><span class="line"><span class="comment">        int temp;</span></span><br><span class="line"><span class="comment">        char ch;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; characters.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            ch = characters[i];</span></span><br><span class="line"><span class="comment">            if (map.containsKey(ch)) &#123;</span></span><br><span class="line"><span class="comment">                temp = i - map.get(ch);</span></span><br><span class="line"><span class="comment">                if (temp &gt; result) result = temp;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                map.put(ch, i);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return result - 1;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLengthBetweenEqualCharacters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不使用map的方案</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//ASCII字符长度</span></span><br><span class="line">        <span class="keyword">char</span>[] characters = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; characters.length; i++) &#123;</span><br><span class="line">            ch = characters[i] - <span class="number">97</span>; <span class="comment">// a的ascII位置是97</span></span><br><span class="line">            <span class="keyword">if</span> (alpha[ch] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = i - alpha[ch];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; result) result = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alpha[ch] = i + <span class="number">1</span>; <span class="comment">// int数组默认初始化为0，所以需要通过+1和初始0值进行区分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="替换隐藏数字得到的最晚时间"><a href="#替换隐藏数字得到的最晚时间" class="headerlink" title="替换隐藏数字得到的最晚时间"></a>替换隐藏数字得到的最晚时间</h2><p>基本思路：由于固定是XX:XX的格式字符串，因此需要处理的无非是四个位置的字符。后两位的字符如果出现’?’，那一定是可以替换为5和9。前两位出现’?’，需要考虑：<br>        1.第一位是’?’，需要看第二位的值，如果大于3，那第一位只能是1，因为不存在24-29点这样的值；如果第二位是1，2，3，那第一位可以是2<br>        2.第二位是’?’，需要看第一位的值，如果是2，那第二位最大是3；如果是第一位是1，那第二位最大可以是9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：time = &quot;2?:?0&quot;</span></span><br><span class="line"><span class="comment"> * 输出：&quot;23:50&quot;</span></span><br><span class="line"><span class="comment"> * 解释：以数字 &#x27;2&#x27; 开头的最晚一小时是 23 ，以 &#x27;0&#x27; 结尾的最晚一分钟是 50 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：time = &quot;0?:3?&quot;</span></span><br><span class="line"><span class="comment"> * 输出：&quot;09:39&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：time = &quot;1?:22&quot;</span></span><br><span class="line"><span class="comment"> * 输出：&quot;19:22&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     time 的格式为 hh:mm</span></span><br><span class="line"><span class="comment"> *     题目数据保证你可以由输入的字符串生成有效的时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">maximumTime</span><span class="params">(String time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = time.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接比较字符大小时就是比较在ASCII码的大小</span></span><br><span class="line">            <span class="keyword">if</span> (chars[<span class="number">1</span>] &gt; <span class="string">&#x27;3&#x27;</span> &amp;&amp; chars[<span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) chars[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> chars[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> || chars[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) chars[<span class="number">1</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> chars[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">3</span>] == <span class="string">&#x27;?&#x27;</span>) chars[<span class="number">3</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (chars[<span class="number">4</span>] == <span class="string">&#x27;?&#x27;</span>) chars[<span class="number">4</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maximumTime(<span class="string">&quot;?4:03&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拆分字符串使唯一子字符串的数目最大"><a href="#拆分字符串使唯一子字符串的数目最大" class="headerlink" title="拆分字符串使唯一子字符串的数目最大"></a>拆分字符串使唯一子字符串的数目最大</h2><p>基本思路：需要遍历所有的子字符串可能，用到递归+回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：子字符串 是字符串中的一个连续字符序列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;ababccc&quot;</span></span><br><span class="line"><span class="comment"> * 输出：5</span></span><br><span class="line"><span class="comment"> * 解释：一种最大拆分方法为 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;ab&#x27;, &#x27;c&#x27;, &#x27;cc&#x27;] 。像 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;cc&#x27;] 这样拆分不满足题目要求，因为其中的 &#x27;a&#x27; 和 &#x27;b&#x27; 都出现了不止一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;aba&quot;</span></span><br><span class="line"><span class="comment"> * 输出：2</span></span><br><span class="line"><span class="comment"> * 解释：一种最大拆分方法为 [&#x27;a&#x27;, &#x27;ba&#x27;] 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;aa&quot;</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> * 解释：无法进一步拆分字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     1 &lt;= s.length &lt;= 16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     s 仅包含小写英文字母</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxUniqueSplit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aac a</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUniqueSplit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        length = s.length();</span><br><span class="line">        maxUniqueSplit(<span class="number">0</span>, <span class="number">0</span>, s, set);</span><br><span class="line">        <span class="keyword">return</span> ct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxUniqueSplit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> split, String s, Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ct &lt; split) ct = split;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (length - i + split &lt; ct) <span class="keyword">break</span>;<span class="comment">// 关键步骤，判断当前切分数加上剩余数组长度是否大于最大切分数，如果不大于，则没有必要进一步切分</span></span><br><span class="line">            String substring = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (set.add(substring)) &#123;</span><br><span class="line">                maxUniqueSplit(i + <span class="number">1</span>, split + <span class="number">1</span>, s, set);</span><br><span class="line">                set.remove(substring);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] arr;</span><br><span class="line">    Set&lt;String&gt; lookUp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUniqueSplit_2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        arr=s.toCharArray();</span><br><span class="line">        lookUp=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,arr,s.length());</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> cur_depth,<span class="keyword">char</span>[] arr,<span class="keyword">int</span> remain_length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain_length==<span class="number">0</span>)&#123;</span><br><span class="line">            count=Math.max(cur_depth,count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=begin,end=begin;end&lt;arr.length;end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left_length=arr.length-end-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_depth+<span class="number">1</span>+left_length&lt;=count)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            String temp=<span class="keyword">new</span> String(arr,start,end-start+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(lookUp.contains(temp))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            lookUp.add(temp);</span><br><span class="line">            dfs(end+<span class="number">1</span>,cur_depth+<span class="number">1</span>,arr,left_length);</span><br><span class="line">            lookUp.remove(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p>基本思路：两个链表的长度可能不一，长度分别为m和n。必然有m+n=n+m。<br>情况一：两个链表相交</p>
<p>链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m ，b+c=n。</p>
<pre><code>如果 a=b，则两个指针会同时到达两个链表的第一个公共节点，此时返回两个链表的第一个公共节点；

如果 a≠b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表的第一个公共节点，该节点也是两个指针第一次同时指向的节点，此时返回两个链表的第一个公共节点。
</code></pre>
<p>情况二：两个链表不相交</p>
<p>链表 headA\textit{headA}headA 和 headB\textit{headB}headB 的长度分别是 mmm 和 nnn。考虑当 m=nm=nm=n 和 m≠nm \ne nm​=n 时，两个指针分别会如何移动：</p>
<pre><code>如果 m=n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 null，此时返回 null；

如果 m≠n，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 pB 移动了 n+m 次之后，两个指针会同时变成空值 null，此时返回 null。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入两个链表，找出它们的第一个公共节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如下面的两个链表：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在节点 c1 开始相交。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span></span><br><span class="line"><span class="comment"> * 输出：Reference of the node with value = 8</span></span><br><span class="line"><span class="comment"> * 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span></span><br><span class="line"><span class="comment"> * 输出：Reference of the node with value = 2</span></span><br><span class="line"><span class="comment"> * 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span></span><br><span class="line"><span class="comment"> * 输出：null</span></span><br><span class="line"><span class="comment"> * 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span></span><br><span class="line"><span class="comment"> * 解释：这两个链表不相交，因此返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     如果两个链表没有交点，返回 null.</span></span><br><span class="line"><span class="comment"> *     在返回结果后，两个链表仍须保持原有的结构。</span></span><br><span class="line"><span class="comment"> *     可假定整个链表结构中没有循环。</span></span><br><span class="line"><span class="comment"> *     程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span></span><br><span class="line"><span class="comment"> *     本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetIntersectionNode</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode head1 = headA;</span><br><span class="line">        ListNode head2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (head1 != head2) &#123;</span><br><span class="line">            head1 = head1 != <span class="keyword">null</span> ? head1.next:headB;</span><br><span class="line">            head2 = head2 != <span class="keyword">null</span> ? head2.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改后的最大二进制字符串"><a href="#修改后的最大二进制字符串" class="headerlink" title="修改后的最大二进制字符串"></a>修改后的最大二进制字符串</h2><p>基本思路：根据题设可知，最佳方案应当是将所有的0都移到一起，从而将00变成10，这样将是最大的可能，因此我们可以将第一个0右边的所有1都移到最右边，从而得到两边是1，中间是0的结构，然后再将中间的00依次转成10即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     操作 1 ：如果二进制串包含子字符串 &quot;00&quot; ，你可以用 &quot;10&quot; 将其替换。</span></span><br><span class="line"><span class="comment"> *         比方说， &quot;00010&quot; -&gt; &quot;10010&quot;</span></span><br><span class="line"><span class="comment"> *     操作 2 ：如果二进制串包含子字符串 &quot;10&quot; ，你可以用 &quot;01&quot; 将其替换。</span></span><br><span class="line"><span class="comment"> *         比方说， &quot;00010&quot; -&gt; &quot;00001&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：binary = &quot;000110&quot;</span></span><br><span class="line"><span class="comment"> * 输出：&quot;111011&quot;</span></span><br><span class="line"><span class="comment"> * 解释：一个可行的转换为：</span></span><br><span class="line"><span class="comment"> * &quot;000110&quot; -&gt; &quot;000101&quot;</span></span><br><span class="line"><span class="comment"> * &quot;000101&quot; -&gt; &quot;100101&quot;</span></span><br><span class="line"><span class="comment"> * &quot;100101&quot; -&gt; &quot;110101&quot;</span></span><br><span class="line"><span class="comment"> * &quot;110101&quot; -&gt; &quot;110011&quot;</span></span><br><span class="line"><span class="comment"> * &quot;110011&quot; -&gt; &quot;111011&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：binary = &quot;01&quot;</span></span><br><span class="line"><span class="comment"> * 输出：&quot;01&quot;</span></span><br><span class="line"><span class="comment"> * 解释：&quot;01&quot; 没办法进行任何转换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     1 &lt;= binary.length &lt;= 105</span></span><br><span class="line"><span class="comment"> *     binary 仅包含 &#x27;0&#x27; 和 &#x27;1&#x27; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/maximum-binary-string-after-change</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumBinaryString</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一步 从左往右，找到第一个0的位置，记录为zeroIndex</span></span><br><span class="line"><span class="comment">     * 第二步 从zeroIndex往右，找到1之后记录为oneIndex</span></span><br><span class="line"><span class="comment">     * 第三步 oneIndx&gt;0的情况下，指针从右往左找0，找到之后记录为reverseZeroIndex</span></span><br><span class="line"><span class="comment">     * 第四步 将oneIndex和reverseZeroIndex所在的字符互换</span></span><br><span class="line"><span class="comment">     * 第五步 将oneIndex和reverseZeroIndex重置为-1</span></span><br><span class="line"><span class="comment">     * 第六步 指针重新从原来oneIndex的位置向右移动，重复二到五步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binary</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">maximumBinaryString</span><span class="params">(String binary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (binary == <span class="keyword">null</span> || binary.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> binary;</span><br><span class="line">        <span class="keyword">char</span>[] chars = binary.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">            <span class="comment">// 找到第一个0的位置</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i++] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将第一个0下标+1的位置记录下来</span></span><br><span class="line">                index = i;</span><br><span class="line">                <span class="comment">// i从第一个0的右边开始从左到右遍历，j从右到左遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt;= i;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将第一个0右边的1全部移到最右侧</span></span><br><span class="line">                        <span class="keyword">if</span> (chars[j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                            chars[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            chars[j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> i++;</span><br><span class="line">                    <span class="comment">// 将左边的00变成10</span></span><br><span class="line">                    <span class="keyword">if</span> (chars[index] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        chars[index - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaximumBinaryString maximumBinaryString = <span class="keyword">new</span> MaximumBinaryString();</span><br><span class="line">        System.out.println(maximumBinaryString.maximumBinaryString(<span class="string">&quot;00010&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查两个字符串是否几乎相等"><a href="#检查两个字符串是否几乎相等" class="headerlink" title="检查两个字符串是否几乎相等"></a>检查两个字符串是否几乎相等</h2><p>基本思路：维护一个数组arr，随后对word1和word2两个字符串进行遍历，word1中出现的字符在arr中存储ascii值加1，word2种出现的字符在arr中存储ascii值减1，最后遍历arr，出现绝对值大于3的说明不符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果两个字符串 word1 和 word2 中从 &#x27;a&#x27; 到 &#x27;z&#x27; 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 word1 和 word2 几乎相等 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你两个长度都为 n 的字符串 word1 和 word2 ，如果 word1 和 word2 几乎相等 ，请你返回 true ，否则返回 false 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个字母 x 的出现 频率 指的是它在字符串中出现的次数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：word1 = &quot;aaaa&quot;, word2 = &quot;bccb&quot;</span></span><br><span class="line"><span class="comment"> * 输出：false</span></span><br><span class="line"><span class="comment"> * 解释：字符串 &quot;aaaa&quot; 中有 4 个 &#x27;a&#x27; ，但是 &quot;bccb&quot; 中有 0 个 &#x27;a&#x27; 。</span></span><br><span class="line"><span class="comment"> * 两者之差为 4 ，大于上限 3 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：word1 = &quot;abcdeef&quot;, word2 = &quot;abaaacc&quot;</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span></span><br><span class="line"><span class="comment"> * - &#x27;a&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。</span></span><br><span class="line"><span class="comment"> * - &#x27;b&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。</span></span><br><span class="line"><span class="comment"> * - &#x27;c&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。</span></span><br><span class="line"><span class="comment"> * - &#x27;d&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span></span><br><span class="line"><span class="comment"> * - &#x27;e&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span></span><br><span class="line"><span class="comment"> * - &#x27;f&#x27; 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：word1 = &quot;cccddabba&quot;, word2 = &quot;babababab&quot;</span></span><br><span class="line"><span class="comment"> * 输出：true</span></span><br><span class="line"><span class="comment"> * 解释：word1 和 word2 中每个字母出现频率之差至多为 3 ：</span></span><br><span class="line"><span class="comment"> * - &#x27;a&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。</span></span><br><span class="line"><span class="comment"> * - &#x27;b&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。</span></span><br><span class="line"><span class="comment"> * - &#x27;c&#x27; 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。</span></span><br><span class="line"><span class="comment"> * - &#x27;d&#x27; 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     n == word1.length == word2.length</span></span><br><span class="line"><span class="comment"> *     1 &lt;= n &lt;= 100</span></span><br><span class="line"><span class="comment"> *     word1 和 word2 都只包含小写英文字母。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckAlmostEquivalent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkAlmostEquivalent</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = word1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] chArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> len = chars1.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            chArr1[chars1[i]-<span class="number">97</span>]++;</span><br><span class="line">            chArr1[chars2[i]-<span class="number">97</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(chArr1[i]) &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckAlmostEquivalent checkAlmostEquivalent = <span class="keyword">new</span> CheckAlmostEquivalent();</span><br><span class="line">        System.out.println(checkAlmostEquivalent.checkAlmostEquivalent(<span class="string">&quot;dfgcbehcifihghedhffbggdcebbbghigfhddhiigcgfeiih&quot;</span>,</span><br><span class="line">                <span class="string">&quot;cdcgbeeceifbgchhfiffhifghiebfchbcbfhggchfbbhddb&quot;</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换字符串的最少操作次数"><a href="#转换字符串的最少操作次数" class="headerlink" title="转换字符串的最少操作次数"></a>转换字符串的最少操作次数</h2><p>基本思路：贪心算法，每次遇到x时，选中包含X以及之后的三个字符，进行转换；换句话说，相当于每次碰到X，将计数器+1，同时遍历数组的索引+3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个字符串 s ，由 n 个字符组成，每个字符不是 &#x27;X&#x27; 就是 &#x27;O&#x27; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 &#x27;O&#x27; 。注意，如果字符已经是 &#x27;O&#x27; ，只需要保持 不变 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回将 s 中所有字符均转换为 &#x27;O&#x27; 需要执行的 最少 操作次数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;XXX&quot;</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> * 解释：XXX -&gt; OOO</span></span><br><span class="line"><span class="comment"> * 一次操作，选中全部 3 个字符，并将它们转换为 &#x27;O&#x27; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;XXOX&quot;</span></span><br><span class="line"><span class="comment"> * 输出：2</span></span><br><span class="line"><span class="comment"> * 解释：XXOX -&gt; OOOX -&gt; OOOO</span></span><br><span class="line"><span class="comment"> * 第一次操作，选择前 3 个字符，并将这些字符转换为 &#x27;O&#x27; 。</span></span><br><span class="line"><span class="comment"> * 然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 &#x27;O&#x27; 组成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 3：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：s = &quot;OOOO&quot;</span></span><br><span class="line"><span class="comment"> * 输出：0</span></span><br><span class="line"><span class="comment"> * 解释：s 中不存在需要转换的 &#x27;X&#x27; 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     3 &lt;= s.length &lt;= 1000</span></span><br><span class="line"><span class="comment"> *     s[i] 为 &#x27;X&#x27; 或 &#x27;O&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/minimum-moves-to-convert-string</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumMoves</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                i = i + <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumMoves minimumMoves = <span class="keyword">new</span> MinimumMoves();</span><br><span class="line">        System.out.println(minimumMoves.minimumMoves(<span class="string">&quot;XXXX&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序矩阵中第-K-小的元素"><a href="#有序矩阵中第-K-小的元素" class="headerlink" title="有序矩阵中第 K 小的元素"></a>有序矩阵中第 K 小的元素</h2><p>基本思路：由于是有序矩阵，可以利用该特性进行二分查找，具体做法是，每次找到中间的位置时，比这个位置小的数字只可能是左上的方向，往左上方向查找比当前位置小的数字的个数，如果个数比k小，则需要往右下方向二分，如果个数比k大，则需要往左上二分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</span></span><br><span class="line"><span class="comment"> * 请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须找到一个内存复杂度优于 O(n2) 的解决方案。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span></span><br><span class="line"><span class="comment"> * 输出：13</span></span><br><span class="line"><span class="comment"> * 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：matrix = [[-5]], k = 1</span></span><br><span class="line"><span class="comment"> * 输出：-5</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     n == matrix.length</span></span><br><span class="line"><span class="comment"> *     n == matrix[i].length</span></span><br><span class="line"><span class="comment"> *     1 &lt;= n &lt;= 300</span></span><br><span class="line"><span class="comment"> *     -10^9 &lt;= matrix[i][j] &lt;= 10^9</span></span><br><span class="line"><span class="comment"> *     题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列</span></span><br><span class="line"><span class="comment"> *     1 &lt;= k &lt;= n^2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进阶：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题?</span></span><br><span class="line"><span class="comment"> *     你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"> * 链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix</span></span><br><span class="line"><span class="comment"> * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthSmallest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[] numArr = <span class="keyword">new</span> <span class="keyword">int</span>[len*len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                numArr[i*len + j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(numArr);</span><br><span class="line">        <span class="keyword">return</span> numArr[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest_v2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (check(matrix, mid, k, n)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KthSmallest kthSmallest = <span class="keyword">new</span> KthSmallest();</span><br><span class="line">        System.out.println(kthSmallest.kthSmallest_v2(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>&#125;&#125;,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>一周技术博客收集-20220606</title>
    <url>/2022/06/06/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20220606/</url>
    <content><![CDATA[<h2 id="Java-HashMap的死循环"><a href="#Java-HashMap的死循环" class="headerlink" title="Java HashMap的死循环"></a><a href="https://coolshell.cn/articles/9606.html">Java HashMap的死循环</a></h2><p>[1.7版本的java，1.8已解决这个问题，但是hashmap在多线程下依然可能出现别的问题]介绍了hashmap在多线程下可能出现的问题，可以深入了解为什么hashmap是线程不安全的。</p>
<h2 id="New-language-features-since-Java-8-to-18"><a href="#New-language-features-since-Java-8-to-18" class="headerlink" title="New language features since Java 8 to 18"></a><a href="https://advancedweb.hu/new-language-features-since-java-8-to-18/">New language features since Java 8 to 18</a></h2><p>介绍了java8-18的新特性。</p>
<h2 id="Java锁与线程的那些事"><a href="#Java锁与线程的那些事" class="headerlink" title="Java锁与线程的那些事"></a><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></h2><p>一篇很详尽的介绍java锁的文章</p>
<h2 id="MySQL之Binlog"><a href="#MySQL之Binlog" class="headerlink" title="MySQL之Binlog"></a><a href="https://zhuanlan.zhihu.com/p/33504555">MySQL之Binlog</a></h2><p>简单了解下Binlog</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>记一次ELK+FileBeats搭建</title>
    <url>/2019/10/07/tech/ELK_FileBeats/</url>
    <content><![CDATA[<h2 id="获取ElasticSearch-LogStash-Kibana-FileBeats"><a href="#获取ElasticSearch-LogStash-Kibana-FileBeats" class="headerlink" title="获取ElasticSearch+LogStash+Kibana+FileBeats"></a>获取ElasticSearch+LogStash+Kibana+FileBeats</h2><p>关于elk搭建的全部产品都可以从elastic的官方网站获取最新版本<br><a href="https://www.elastic.co/cn/products/">elastic官网</a></p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/1.png"><br>如图所示<br>当前elastic官方已经不再推荐单纯使用elk(ElasticSearch+LogStash+Kibana)三个产品搭建日志平台, 而是在此基础上加上了轻量级的日志收集插件FileBeats.  </p>
<h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><p>我们首先获取安装包<br>进入<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a>  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/2.png"><br>在Downloads里点击linux就可以下载到用于linux安装的tar包<br>如果是直接在linux安装,使用wget命令即可<br>如 : wget <a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-linux-x86_64.tar.gz</a><br>如果需要更旧的历史版本, 点击下面的past release即可</p>
<span id="more"></span>
<p><img src="/2019/10/07/tech/ELK_FileBeats/3.png">  </p>
<p>在获取到安装包之后, windows环境需要将tar包传送到linux , 使用scp(windows需要预装git)命令即可<br>如: scp C:/Users/Administrator/Downloads/elasticsearch-7.3.1-linux-x86_64.tar.gz <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x30;&#48;&#x2e;&#x31;&#x30;&#48;&#46;&#x31;&#x30;&#48;&#46;&#49;&#x30;&#x30;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x30;&#48;&#x2e;&#x31;&#x30;&#48;&#46;&#x31;&#x30;&#48;&#46;&#49;&#x30;&#x30;</a>:/home/elk/<br>在linux, 进入到安装包的目录, 使用tar -zxvf命令进行解压<br>如: tar -zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz<br>解压完成后, elasticsearch其实就已经完成了安装  </p>
<h3 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h3><p>在启动elasticserach之前需要注意:elasticsearch不可以用root用户启动, 因此, 需要事先在linux建立一个非root用户<br><a href="https://www.cnblogs.com/sunyllove/p/9772053.html">linux如何创建一个管理员用户</a><br>创建完linux用户后, 切换到该用户, 进入到elasticsearch目录, 执行bin/elasticserach即可<br>默认elasticsearch的端口是9200, 打开浏览器, 输入<a href="http://elasticsearch地址:9200/">http://elasticsearch地址:9200/</a>  , 出现如下画面, 说明elasticsearch启动成功</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/4.png"></p>
<h2 id="安装LogStash"><a href="#安装LogStash" class="headerlink" title="安装LogStash"></a>安装LogStash</h2><p>windows环境下载和上传到linux的方法不再赘述, 参照前文<br>linux环境, 参照如下命令即可:<br>1.执行wget <a href="https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.tar.gz">https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.tar.gz</a><br>2.进入logstash安装包目录, 执行tar -zxvf logstash-7.4.0.tar.gz  </p>
<h3 id="配置和启动LogStash"><a href="#配置和启动LogStash" class="headerlink" title="配置和启动LogStash"></a>配置和启动LogStash</h3><p>1.在启动logstash之前, 需要先新建一个logstash的配置文件<br>参照logstash目录下的config/logstash-sample.config文件(如图), 新建一个logstash-elk.config文件  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/5.png"><br>input, 即输入数据的监听端口, 这个一般不需要改.<br>output, 用于将接收到的数据发送到elasitcsearch. 将hosts改成elasticsearch部署的地址, 如果elasticsearch和logstash是同一台机器, 则不需要更改.<br>注意: 如果多个实例中的FileBeats发送过来的数据希望进入同一个elasticsearch实例, 并根据不同的ip地址划分为不同的索引, 按照如下方式配置  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    if &quot;100.100.100.101&quot; in [host][ip] &#123;</span><br><span class="line">        elasticsearch&#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">          index =&gt; &quot;sample1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if &quot;100.100.100.102&quot; in [host][ip] &#123;</span><br><span class="line">        elasticsearch&#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">          index =&gt; &quot;sample2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      elasticsearch&#123;</span><br><span class="line">        hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">        index =&gt; &quot;other&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后, 启动logstash, 执行bin/logstash -f config/logstash-elk.conf </p>
<h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>linux参照如下命令<br>1.wget <a href="https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-linux-x86_64.tar.gz</a><br>2.进入kibana安装包目录, 执行tar -zxvf kibana-7.4.0-linux-x86_64.tar.gz  </p>
<h3 id="配置和启动kibana"><a href="#配置和启动kibana" class="headerlink" title="配置和启动kibana"></a>配置和启动kibana</h3><p>进入config/kibana.yml<br>1.修改server.host为linux机器的实际地址<br>2.修改i18n.locale: “zh-CN” 这样kibana界面会显示为中文<br>3.返回kibana主目录, 执行bin/kibana  (注意:kibana也不能用root用户启动)<br>4.打开浏览器, 输入<a href="http://kibana地址:5601/">http://kibana地址:5601</a>, 出现如下画面  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/6.png"></p>
<h2 id="安装FileBeats"><a href="#安装FileBeats" class="headerlink" title="安装FileBeats"></a>安装FileBeats</h2><p>注意: <strong>FileBeats需要安装在所有需要发送日志的服务器上</strong><br>linux参照如下命令<br>1.wget <a href="https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.0-linux-x86_64.tar.gz</a><br>2.tar -zxvf filebeat-7.4.0-linux-x86_64.tar.gz</p>
<h3 id="配置和启动FileBeats"><a href="#配置和启动FileBeats" class="headerlink" title="配置和启动FileBeats"></a>配置和启动FileBeats</h3><p>进入filebeats安装目录, vi filebeat.yml<br>1.修改paths下的目录, 输入filebeats所在服务器需要收集的日志地址, 如:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paths:</span><br><span class="line">    - /home/sample1/logs/log.*</span><br><span class="line">    - /home/sample2/logs/log.*</span><br></pre></td></tr></table></figure>

<p>2.修改output.logstash下的内容, 将logstash部署的地址输入, 参照如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;100.100.100.101:5044&quot;]</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>
<p>3.进入filebeats主目录, 执行 ./filebeat -e -c filebeat.yml, 启动成功  </p>
<h2 id="kibana查看日志内容"><a href="#kibana查看日志内容" class="headerlink" title="kibana查看日志内容"></a>kibana查看日志内容</h2><p>将上述Elk+FileBeats都安装搭建完成后, 浏览器进入到kibana的界面.<br>1.打开管理-索引模式-创建索引模式, 进入如下界面:  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/7.png"><br>2.可以看到有三个索引可以匹配, 在索引模式的输入框内输入自己想要创建的索引, 如other, 然后点击下一步</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/8.png"><br>3.选择timestamp, 点击创建索引模式</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/9.png"><br>4.创建成功, 点击discover</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/10.png"><br>5.可以看到有一个新的索引other可以选择</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/11.png"></p>
<p>6.到此, elk+filebeats的基本搭建工作就已经完成了</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>12例bash脚本最佳实践</title>
    <url>/2022/01/18/blog/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BF%BB%E8%AF%91-12%E4%BE%8Bbash%E8%84%9A%E6%9C%AC%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://www.faqforge.com/linux/12-best-practices-for-writing-bash-scripts/">12 Best Practices for Writing Bash Scripts</a><br>翻译完发现这篇文章技术价值相当低。。。</p>
<hr>
<p>Bash shell全称Bourne Again Shell，现在作为大部分的linux发行版本的默认shell。一个Bash脚本是一个包含多行shell命令的文件，用于执行特别的命令。如果你熟知bash脚本，那这篇文章就很适合你，在这篇文章中我写了12种bash脚本的最佳实践，可以增加bash脚本的效率并使其更易读。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解是一段清晰代码最基础的部分，用于定义或解释复杂代码的不同部分。写脚本的时候，你可以毫不费力的看懂很早之前你写过的代码。同样也能帮助你在一个大的项目组提高工作效率，帮助你理解一个函数或方法的真实用途。</p>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>一个函数是一堆命令联合之后实现一个特定的任务，可以帮助工作流模块化并使得脚本可复用，消除重复的代码。这可以让你维护的代码更加清晰和可读。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_root</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;function has been called&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对引用变量使用双引号"><a href="#对引用变量使用双引号" class="headerlink" title="对引用变量使用双引号"></a>对引用变量使用双引号</h2><p>使用双引号可以消除不必要的通配符，同时当引用变量包含分割字符和空格时可以将包含空格的单词进行分割。如下例子中，我们可以看出变量用不用双引号的区别。（译者：没有例子，作者估计漏了）</p>
<h2 id="出现错误时终止脚本"><a href="#出现错误时终止脚本" class="headerlink" title="出现错误时终止脚本"></a>出现错误时终止脚本</h2><p>有时候执行脚本的时候可能会出现一些错误。然而即使一个命令失败了，剩余的脚本也有可能继续运行，从而影响脚本中的其他命令。所以为了避免任何进一步的逻辑错误，我们需要加入<code>set -o errexit</code>或<code>set -e</code>终止错误的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="使用未声明变量时终止脚本"><a href="#使用未声明变量时终止脚本" class="headerlink" title="使用未声明变量时终止脚本"></a>使用未声明变量时终止脚本</h2><p>脚本执行时，如果存在未声明的变量，可能导致bash使用变量时出现逻辑错误。当bash中存在一个未声明变量时，我们可以用如下命令中止脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br></pre></td></tr></table></figure>

<h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>我们必须对一个变量的数据类型和用法进行声明。当变量未声明，bash可能会因此执行失败。变量可以被声明为全局或在脚本内的本地变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable declaration</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -r -i x=30</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_variable</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> -r name = <span class="variable">$&#123;HOME&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用花括号"><a href="#使用花括号" class="headerlink" title="使用花括号"></a>使用花括号</h2><p>当使用变量关联字符串时，可以使用花括号将变量圈起来，以避免不必要的变量使用。同样也可用于对字符串的简单定义。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom variable</span></span><br><span class="line"></span><br><span class="line">data= <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>_data is being used&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>当分配命令的输出到变量时，bash使用命令替换的特性。我们需要使用推荐的$()而不是反引号去分配输出到变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="comment">#Displaying Date</span></span><br><span class="line"></span><br><span class="line">date_now = <span class="variable">$&#123;date&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>在我们的系统中，所有的环境变量都用大写字母。所以当我们声明一个本地变量时，需要使用小写字母以避免环境变量和本地变量名之间的冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line">user_var = <span class="string">&quot;<span class="variable">$HOME</span> is your system&#x27;s current login user.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="声明静态变量"><a href="#声明静态变量" class="headerlink" title="声明静态变量"></a>声明静态变量</h2><p>如果你拥有一个在整个脚本中都不变的静态数据，你可以将值分配到一个不能被修改的静态变量上。你可以使用<code>readonly</code>命令来分配静态变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is nginx test host config</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> test_conf_path = <span class="string">&quot;/etc/nginx/conf.d/test.conf&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>在多数场景下字符串用<code>==</code>进行比较，但是在bash脚本中，字符串用<code>=</code>就可以完成比较。在如下例子中，我用<code>=</code>比较两个字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># comparing two strings</span></span><br><span class="line"></span><br><span class="line">If [ <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span> = <span class="string">&quot;User1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;This is test purpose&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>调试是鉴定问题最重要的部分。我们需要在运行脚本的时候加上<code>-n</code>命令来检查脚本语法错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -n script_name</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以使用如下命令打开脚本的debug模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -x script_name</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样，就是12个可以提升你脚本能力的bash脚本实践。当使用命令去完成特殊任务时，bash脚本将是更出色的那个。</p>
<hr>
<p>refers to 指的是；全称<br>demonstration （强烈表达）集会示威;游行示威;示范;示范表演;演示;证明;证实;论证;说明;表达<br>effortless 不费力的<br>modularizing 模块化<br>globbing 通配符<br>splitting 分割<br>curly braces 大括号;花括号;大括弧;花括號<br>concatenation 串联<br>substitution 置换;取代;代换;代入<br>assigning 分配<br>syntax 语法</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日常维护相关</title>
    <url>/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="配置启动ELK-FileBeats后台运行-不随着窗口关闭而关闭"><a href="#配置启动ELK-FileBeats后台运行-不随着窗口关闭而关闭" class="headerlink" title="配置启动ELK+FileBeats后台运行, 不随着窗口关闭而关闭"></a>配置启动ELK+FileBeats后台运行, 不随着窗口关闭而关闭</h2><p>只要在后面加上&amp;即可, 如  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/logstash -f config/log4j-es.conf &amp;</span><br></pre></td></tr></table></figure>
<p>注意: 退出时使用Ctrl+D命令, 直接关闭窗口依然有可能使得进程关闭  </p>
<h2 id="LogStash自动重新加载配置"><a href="#LogStash自动重新加载配置" class="headerlink" title="LogStash自动重新加载配置"></a>LogStash自动重新加载配置</h2><p>启动logstash时在后面加上命令–config.reload.automatic  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/logstash -f config/log4j-es.conf --config.reload.automatic &amp;</span><br></pre></td></tr></table></figure>

<h2 id="重新发送filebeat抓取的内容"><a href="#重新发送filebeat抓取的内容" class="headerlink" title="重新发送filebeat抓取的内容"></a>重新发送filebeat抓取的内容</h2><p>1.删除registry下的data.json<br>如:  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /home/elk/filebeats/filebeat-7.3.1-linux-x86_64/data/registry/filebeat</span><br></pre></td></tr></table></figure>
<p>2.重启filebeat<br>如果存在正在运行的filebeat, 先kill掉  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep filebeat  </span><br><span class="line">kill -s 9 pid</span><br></pre></td></tr></table></figure>
<p>然后执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="设置索引内容30天过期删除"><a href="#设置索引内容30天过期删除" class="headerlink" title="设置索引内容30天过期删除"></a>设置索引内容30天过期删除</h2><p>本来我理解的理论上应该可以用索引的生命周期来实现, 但是半天没整明白, 所以现在<br>是简单粗暴的使用linux的cron任务来实现, 更具体的cron配置详见<a href="https://blog.csdn.net/mengzuchao/article/details/81172305">cron详解</a><br>1.编辑shell脚本, 文件名为removeDataByTime.sh, 内容如下  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">limit_date=30</span><br><span class="line">for var in `curl &#x27;localhost:9200/_cat/indices&#x27; | awk &#x27;!/kibana*/ &#123;print $3&#125;&#x27;`</span><br><span class="line">do</span><br><span class="line">  curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;query&quot;: &#123;&quot;range&quot;: &#123;&quot;@timestamp&quot;: &#123;&quot;lt&quot;: &quot;now-&#x27;$&#123;limit_date&#125;&#x27;d/d&quot;&#125;&#125;&#125;&#125;&#x27; &quot;http://localhost:9200/$&#123;var&#125;/_delete_by_query&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>2.编辑cron文件, 执行crantab -e, 打开crontab配置文件<br>加上刚才的shell脚本, 设置每天0点15分执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">15 00 * * * /home/elk/removeDataByTime.sh</span><br></pre></td></tr></table></figure>
<p>设置cron重新启动, 执行/sbin/service crond restart  </p>
<p>3.查看cron执行情况<br>查看cron任务列表 : crontab -l<br>查看cron执行日志 : grep ‘removeDataByTime’ /var/log/cron  </p>
<h2 id="设置LogStash不写入指定的内容"><a href="#设置LogStash不写入指定的内容" class="headerlink" title="设置LogStash不写入指定的内容"></a>设置LogStash不写入指定的内容</h2><p>在logstash中写入如下内容即可 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 过滤message中的内容 , 注意drop后面有一个空格</span></span><br><span class="line">    if &quot;somethingA&quot; in [message] &#123;</span><br><span class="line">      drop &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 过滤tags中的内容</span><br><span class="line">    if &quot;somethingB&quot; in [tags] &#123;</span><br><span class="line">      drop &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="设置索引别名来实现中文索引搜索"><a href="#设置索引别名来实现中文索引搜索" class="headerlink" title="设置索引别名来实现中文索引搜索"></a>设置索引别名来实现中文索引搜索</h2><p>有时候需要在搜索页面使用中文的索引名，但是在ES中不支持直接用中文名来命名索引，原因我认为应该是跟索引的Btree算法有关。</p>
<p>但是我们可以给索引设置别名来在搜索页面使用中文的索引来搜索。</p>
<p>可以按照如下方式来设置</p>
<ul>
<li>在postman发送如下请求（前提：在ElasticSearch中已经存在datadocking和activity-provider两个索引）：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST: <span class="number">192.168</span><span class="number">.15</span><span class="number">.161</span>:<span class="number">9200</span>/_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;外部对接&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;datadocking&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;微商城活动&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;activity-provider&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进入项目的索引模式</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/1.png"></p>
<p>输入刚刚设置的中文名，就可以直接对应到英文的索引名，然后按照步骤创建索引模式</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/2.png"></p>
<p>在搜索界面就可以使用中文的索引名来搜索</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/3.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架中使用get和post</title>
    <url>/2021/11/26/tech/Express%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8get%E5%92%8Cpost/</url>
    <content><![CDATA[<p>之所以有这个文章，是因为遇到在nodejs中使用express框架直接接受post请求时，无法获取到body中的内容，于是google了一篇英文文章解决了这个问题。<br>翻译自<a href="https://codeforgeek.com/handle-get-post-request-express-4/">codeforgeek</a></p>
<hr>
<p>GET和POST是两种用于构建REST接口的普通HTTP请求。两者的命名包含着不同的使用目的。<br>根据定义，GET请求从指定的地址抓取数据，POST请求则是发送数据到指定的地址。</p>
<p>Express框架提供了router()方法用于构建HTTP终端。下面让我们看下怎么使用Express来实现GET和POST请求。</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>在Express中使用GET请求非常直接。你首先必须创建一个express和router的实例。下面是实现的一小段代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">router.get(‘/handle’,<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//code to perform particular action.</span></span><br><span class="line"><span class="comment">//To access GET variable use req.query() and req.params() methods.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router in the Express app.</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, router);</span><br></pre></td></tr></table></figure>
<p>GET请求会缓存在浏览器历史中。这就是为什么不推荐使用GET请求发送敏感数据（密码，ATM取款码，等等）。你应该只使用GET请求从服务器获取数据。</p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>Express需要一个额外的中间件模块提取POST请求中的数据。这个中间件叫做”body-parser”。我们需要在Express的实例中安装和配置它。<br>你可以使用如下命令安装body-parser。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install --save body-parser</span><br></pre></td></tr></table></figure>
<p>你需要在你的项目中导入这个包并告知Express去使用这个中间件。参考如下代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here we are configuring express to use body-parser as middle-ware.</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line">router.post(‘/handle’,<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//code to perform particular action.</span></span><br><span class="line"><span class="comment">//To access POST variable use req.body()methods.</span></span><br><span class="line"><span class="built_in">console</span>.log(request.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router in the Express app.</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, router);</span><br></pre></td></tr></table></figure>
<p>通过这种方式，你可以在Express框架中使用GET和POST请求。（译者注：注意先后顺序，body-parser的注入一定要在router的注入之前，否则也会不起作用）</p>
<hr>
<p>后面的内容是博主写的demo，感觉也没必要发上来，就略过了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试八股文知识点随笔</title>
    <url>/2022/06/02/tech/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h2 id="复习关键字"><a href="#复习关键字" class="headerlink" title="复习关键字"></a>复习关键字</h2><ul>
<li><input disabled="" type="checkbox"> new对象的过程</li>
<li><input disabled="" type="checkbox"> 类加载过程<ul>
<li><input disabled="" type="checkbox"> 双亲委派机制</li>
<li><input disabled="" type="checkbox"> 类加载器</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Synchronized，Reentrantlock和AQS</li>
<li><input disabled="" type="checkbox"> Java新版本特性</li>
<li><input disabled="" type="checkbox"> 集合源码<ul>
<li><input disabled="" type="checkbox"> 红黑树</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> 两种代理模式</li>
<li><input disabled="" type="checkbox"> IO模型，三种javaIO模型</li>
<li><input disabled="" type="checkbox"> 数据库主从分离方式<ul>
<li><input disabled="" type="checkbox"> 代理方式</li>
<li><input disabled="" type="checkbox"> 组件方式</li>
</ul>
</li>
</ul>
<h2 id="框架了解"><a href="#框架了解" class="headerlink" title="框架了解"></a>框架了解</h2><ul>
<li><input disabled="" type="checkbox"> 注册中心 <a href="https://github.com/apache/zookeeper">Zookeeper</a>, <a href="https://github.com/hashicorp/consul">Consul</a>, <a href="https://github.com/Netflix/eureka">Eureka</a>, <a href="https://github.com/alibaba/nacos">Nacos</a></li>
<li><input disabled="" type="checkbox"> 客户端/进程内负载均衡器 <a href="https://github.com/Netflix/ribbon">Ribbon</a>, <a href="https://github.com/nginx/nginx">Nginx</a></li>
<li><input disabled="" type="checkbox"> Rpc调用 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">OpenFeign</a>, <a href="https://github.com/apache/dubbo">Dubbo</a>, <a href="https://github.com/grpc/grpc">Grpc</a></li>
<li><input disabled="" type="checkbox"> 熔断降级 <a href="https://github.com/Netflix/Hystrix">Hystrix</a>, <a href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><input disabled="" type="checkbox"> 微服务网关 <a href="https://github.com/Netflix/zuul">Zuul</a>, <a href="https://github.com/spring-cloud/spring-cloud-gateway">Spring Cloud Gateway</a>, <a href="https://github.com/Kong/kong">Kong</a>, <strong><a href="https://github.com/apache/apisix">APISIX</a></strong>, <a href="https://github.com/apache/incubator-shenyu">Shenyu</a></li>
<li><input disabled="" type="checkbox"> 配置中心 <a href="https://github.com/spring-cloud/spring-cloud-config">Spring Cloud Config</a> + <a href="https://github.com/spring-cloud/spring-cloud-bus">Spring Cloud Bus</a>, <a href="https://github.com/apolloconfig/apollo">Apollo</a></li>
<li><input disabled="" type="checkbox"> 开源式分布式NoSQL数据库 <a href="https://github.com/apache/cassandra">Cassandra</a></li>
<li><input disabled="" type="checkbox"> 分布式ID <a href="https://github.com/didi/tinyid/">Tinyid</a>, Snowflake(twitter的开源库已删，有很多替代方案如美团的<a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a>，百度的UidGenerator)</li>
<li><input disabled="" type="checkbox"> 分布式Redis <a href="https://github.com/CodisLabs/codis/">Codis</a></li>
<li><input disabled="" type="checkbox"> MySQL主从分离中间件 <a href="https://github.com/mysql/mysql-router">MySQL Router</a>（官方）、<a href="https://github.com/Qihoo360/Atlas">Atlas</a>（基于 MySQL Proxy）、<a href="https://github.com/mariadb-corporation/MaxScale">Maxscale</a>、<a href="https://github.com/MyCATApache/Mycat-Server">MyCat</a></li>
<li><input disabled="" type="checkbox"> 分库分表 <a href="https://github.com/apache/shardingsphere">ShardingSphere</a></li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>KMP算法</li>
<li>variable-precision SWAR算法</li>
<li>RAFT算法</li>
</ul>
<span id="more"></span>

<h2 id="使用-try-with-resources-代替try-catch-finally"><a href="#使用-try-with-resources-代替try-catch-finally" class="headerlink" title="使用 try-with-resources 代替try-catch-finally"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally">使用 try-with-resources 代替try-catch-finally</a></h2><p>适用于java7之后的特性，针对字节流和网络连接之类的对象，不再需要每次在finally中进行close</p>
<p>try-catch-finally风格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try-with-resources风格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，在 try-with-resources 语句中可以使用 effectively-final 变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// effectively-final简单说就是被初始化后从未变更的变量，如下用final修饰符的scanner和未被final修饰的writer，都未曾改变，因此就是effectively-final变量</span></span><br><span class="line"><span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(<span class="string">&quot;testWrite.txt&quot;</span>))</span><br><span class="line"><span class="keyword">try</span> (scanner;writer) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态方法为什么不能调用非静态成员?</a></h2><p>简单来说静态方法初始化在类加载时，非静态成员初始化于new 实例对象时</p>
<h2 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></h2><p><img src="/2022/06/02/tech/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E7%AC%94/javaGuide1.png"></p>
<h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashcode-%E6%96%B9%E6%B3%95">为什么重写 equals() 时必须重写 hashCode() 方法？</a></h2><p>hashcode相等时，两对象不一定相等。但如果两对象相等，那hashcode必定相等。即hashcode是两对象相等的<strong>必要不充分</strong>条件。</p>
<h2 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a><a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java.html">为什么 Java 中只有值传递</a></h2><p>还可以参见<a href="https://www.zhihu.com/question/31203609/answer/576030121">Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎</a></p>
<h2 id="Java-序列化详解"><a href="#Java-序列化详解" class="headerlink" title="Java 序列化详解"></a><a href="https://javaguide.cn/java/basis/serialization.html">Java 序列化详解</a></h2><p>序列化一般用于数据-文件转换和网络传输<br>序列化方式<br>JDK自带 性能较差，一般不用<br>kyro  高性能<br>Protobuf  高性能，跨语言，略烦琐，google在用<br>ProtoStuff  Protobuf升级版，更简洁易用<br>hessian 较老，跨语言，dubbo在使用hessian2</p>
<h2 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a><a href="https://javaguide.cn/java/basis/bigdecimal.html">BigDecimal 详解</a></h2><p><img src="/2022/06/02/tech/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E7%AC%94/javaGuide2.png"></p>
<h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">集合总结</a></h2><p><img src="/2022/06/02/tech/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E7%AC%94/javaGuide3.png"></p>
<ul>
<li>List(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li>Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li>Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li>Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
<li><strong>虽然理论上linkedList的头尾插入和删除比ArrayList更快，但是实际一般都会在中间位置插入，这个时候差别并不大，而ArrayList的其他性能几乎都更好，因此实践中几乎不会用到LinkedList</strong></li>
<li>ArrayList 实现了 RandomAccess 接口，而 LinkedList 没有实现。RandomAccess更多是一个标示，其接口内容是空的，本质上是因为ArrayList底层实现是数组，因此支持随机访问，而不是实现了RandomAccess才支持随机访问。</li>
</ul>
<h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#hashmap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9">HashMap 的长度为什么是 2 的幂次方</a></h2><p>hash值通过对数组的长度进行取模运算得到在数组中的位置<br><strong>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）</strong></p>
<h2 id="ArrayList中ensurecapacity方法"><a href="#ArrayList中ensurecapacity方法" class="headerlink" title="ArrayList中ensurecapacity方法"></a><a href="https://javaguide.cn/java/collection/arraylist-source-code.html#_3-4-ensurecapacity%E6%96%B9%E6%B3%95">ArrayList中ensurecapacity方法</a></h2><p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</strong></p>
<h2 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态"></a><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81">说说线程的生命周期和状态</a></h2><p>线程有六种状态：NEW，RUNNABLE，BLOCKED，WAITING，TIME_WAITING，TERMINATED<br>其中RUNNABLE状态包含READY和RUNNING两种状态，由于切换时间很短，因此并未做区分<br><img src="/2022/06/02/tech/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9A%8F%E7%AC%94/javaGuide4.png"></p>
<h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法"></a><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法</a></h2><p>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>
<h2 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#aqs">AQS介绍</a></h2><p>AQS 的全称为（AbstractQueuedSynchronizer），是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 8.0参考手册中文版（一）</title>
    <url>/2019/10/17/tech/MySql-Document/</url>
    <content><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">原文文档</a>  </p>
<p><strong>声明</strong></p>
<p>该文档纯粹自己手动翻译， 也许网上有更好的版本， 但是我这个属于自己学习的版本， 为了提高英语水平和对MySQL的理解， 后续不保证会持续更新，内容如有理解错误， 还请指正。</p>
<h2 id="MySQL-8-0-参考手册"><a href="#MySQL-8-0-参考手册" class="headerlink" title="MySQL 8.0 参考手册"></a>MySQL 8.0 参考手册</h2><h3 id="包含MySQL-NDB集群8-0"><a href="#包含MySQL-NDB集群8-0" class="headerlink" title="包含MySQL NDB集群8.0"></a>包含MySQL NDB集群8.0</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>这是一份MySQL参考手册。 该文档分别记录了MySQL8.0到8.0.20，以及基于NDB8.0版本到NDB8.0.19版本的NDB集群发布版本。这份文档可能包括一些目前还没发布的MySQL版本的特性。想要了解哪些版本已经发布，请查看<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">MySQL8.0发布日志</a>。  </p>
<p><strong>MySQL8.0特性</strong>。这份手册描述的特性并没有包含在所有版本的MySQL8.0中；这些特性可能不包含在你所购买的MySQL8.0版本中。如果你有任何问题是关于你的MySQL8.0版本中所包含的特性的，请参阅你的MySQL8.0许可协议或者联系你的oracle销售代表。  </p>
<p>有关每个发布版本的变化，请查看<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">MySQL8.0发布日志</a>。  </p>
<p>有关法律信息和许可信息，请查看<a href="https://dev.mysql.com/doc/refman/8.0/en/preface.html">前言和法律声明</a>。  </p>
<p>在使用MySQL中需要帮助，请访问<a href="http://forums.mysql.com/">MySQL论坛</a>，你可以在那里向别的MySQL用户描述你的问题。  </p>
<p>文档创建于：2019-10-16  </p>
<h2 id="1-一般信息"><a href="#1-一般信息" class="headerlink" title="1.  一般信息"></a>1.  一般信息</h2><p>MySQL提供了非常快速的，多线程，多用户，和健壮的SQL数据库服务。MySQL服务用于关键服务，高负荷生产的系统以及嵌入大量部署的软件。Oracle是Oracle公司及其分支机构的注册商标。MySQL是Oracle公司及其分支机构的商标，未经Oracle正式的书面许可，客户不得使用。其他的名字可能是其各自所有者的商标。  </p>
<p>MySQL软件具有双重许可。用户可以在GNU通用公共许可 (<a href="http://www.fsf.org/licenses/">http://www.fsf.org/licenses/</a>)  条款下将MySQL软件作为开源软件产品使用，或者从Oracle购买一份标准的商业许可。访问 <a href="http://www.mysql.com/company/legal/licensing/">http://www.mysql.com/company/legal/licensing/</a>  以获取更多关于授权政策的信息。  </p>
<p>下面的列表描述了一些在本手册中需要特别关注的部分：  </p>
<ul>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/features.html">1.3.2章节，“MySql的主要特性”</a>，讨论关于MySQL数据库服务的功能。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html">1.4章节，“MySQL8.0更新了什么”</a>，获取关于MySQL新功能的概况。访问<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">发布日志</a>，获取关于每个版本的更新信息。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html">2章节，安装和升级MySQL</a>，获取安装介绍。访问<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading.html">章节2.11</a>，获取MySQL升级说明。  </p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/tutorial.html">第3章节，教程</a>，获取MySQL数据库服务的教程介绍。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-administration.html">第5章节，MySQL服务管理</a>，获取关于MySQL服务的配置和管理的信息。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/security.html">第6章节，安全</a>，获取关于MySQL的安全信息。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/replication.html">第17章节，复制</a>，获取关于设置复制服务器的信息。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-enterprise.html">第30章节，MySQL企业版</a>，获取关于MySQL企业版的信息，商用版的MySQL会发布一些进阶的功能和管理工具。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/faqs.html">附录A，MySQL8.0常见问题</a>，获取关于MySQL服务及其功能的一些常见问题的答案。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">发布日志</a>，获取关于新特性和bug修复的发布信息。</p>
<p><strong>重要</strong>  </p>
<p>如果要报告问题或者bug，请按照<a href="https://dev.mysql.com/doc/refman/8.0/en/bug-reports.html">章节17，“如何报告bug和问题”</a>的指示。如果你发现在MySQL中的一个敏感的安全性的bug，请立即发送邮件信息到&lt; <a href="mailto:secalert_us@oracle.com">secalert_us@oracle.com</a> &gt;让我们知晓。例外：支持客户应该报告所有的问题，包括安全bug，发送给Oracle支持部门。  </p>
</li>
</ul>
<h3 id="1-1-关于本手册"><a href="#1-1-关于本手册" class="headerlink" title="1.1 关于本手册"></a>1.1 关于本手册</h3><p>这份参考手册适用于MySQL数据库系统8.0版本到8.0.20版。在本文中关于和MySQL8.0镜像版本的区别参照了（8.0.x）的发行版本。查看<a href="https://dev.mysql.com/doc/refman/8.0/en/preface.html#legalnotice">法律声明</a>，获取许可的信息。</p>
<p>本手册不适用于MySQL软件的更早版本，因为在MySQL8.0和更早版本之间存在着很多功能及别的方面的不同。如果你正在使用MySQL软件的早期发布版本，请参考对应的手册。比如：<a href="https://dev.mysql.com/doc/refman/5.7/en/">MySQL5.7操作手册</a>可以覆盖MySQL软件的5.7发布版本系列。</p>
<p>由于这个手册是作为参考来使用，因此不会提供关于SQL或关联的数据库概念的一般介绍。同样也不会教你如何使用你的操作系统或命令行解释器。</p>
<p>MySQL数据库软件在经历不断的发展，其手册同样也会不断的更新。最新版本的手册可以在 <a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a> 在线搜索到。其他格式也可以在这里获取，包括HTML，PDF和EPUB版本。</p>
<p>参考手册的源文件由DocBook XML格式写成。其HTML版本和其他版本都自动生成，主要使用DocBook XSL样式表。关于DocBook的信息，详见 <a href="http://docbook.org/">http://docbook.org/</a> 。</p>
<p>MySQL的源代码包括内部文档，由Doxygen编写。已完成的Doxygen内容可以访问 <a href="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html</a> 。同样也可以按照 <a href="https://dev.mysql.com/doc/refman/8.0/en/source-installation-doxygen.html">章节2.9.10，“创建MySQL Doxygen文档内容”</a>的介绍从MySQL源分发创建本地的内容。</p>
<p>如果你有使用MySQL的的问题，加入 <a href="https://mysqlcommunity.slack.com/">MySQL开发者社区</a>，或者在我们的论坛提问；详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/forums.html">章节1.6.2，“MySQL论坛的MySQL社区支持”</a>。如果你对本手册有补充或者更正的建议，请发送到 <a href="http://www.mysql.com/company/contact/%E3%80%82">http://www.mysql.com/company/contact/。</a></p>
<p>本手册最初由 David Axmark 和 Michael “Monty” Widenius 编写。主要由MySQL文档团队编写，成员包括 Chris Cole， Paul DuBois， Margaret Fisher， Edward Gilmore， Stefan Hinz， David Moss， Philip Olson， Daniel Price， Daniel So， 以及 Jon Stephens 。</p>
<h3 id="1-2-排版和语法约定"><a href="#1-2-排版和语法约定" class="headerlink" title="1.2  排版和语法约定"></a>1.2  排版和语法约定</h3><p>本手册使用下列的排版约定：</p>
<p>// TODO</p>
<h3 id="1-3-MySQL数据库管理系统总览"><a href="#1-3-MySQL数据库管理系统总览" class="headerlink" title="1.3 MySQL数据库管理系统总览"></a>1.3 MySQL数据库管理系统总览</h3><h4 id="1-3-1-什么是MySQL？"><a href="#1-3-1-什么是MySQL？" class="headerlink" title="1.3.1 什么是MySQL？"></a>1.3.1 什么是MySQL？</h4><p>MySQL是最受欢迎的开源的SQL数据库管理系统，由Oracle公司开发，发布和支持。</p>
<p><a href="http://www.mysql.com/">MySQL官网</a>提供了MySQL软件的最新版本的信息。</p>
<ul>
<li><p>MySQL是一个数据库管理系统  </p>
<p>数据库是数据的结构化集合。它可以是任何东西，从简单的购物清单，到一个图片集，或者公司网络中的海量信息。在一个计算机数据库上添加，访问和执行数据存储，你需要一个像MySQL服务器一样的数据库管理系统。由于计算机非常善于处理大量的数据，数据库管理系统就在计算机中扮演了一个中心角色，无论是作为一个独立的程序，还是别的应用的一部分。</p>
</li>
<li><p>MySQL数据库是关系型的</p>
<p>一个关系型数据库将数据存储在不同的表中，而不是把所有的数据放在一个大的存储库中。数据库结构组织成物理文件以优化速度。具有对象（诸如数据库，表，视图，行和列）的逻辑模型提供了灵活的程序设计环境。你可以建立规则去管理不同字段之间的关系，比如一对一，一对多，唯一，必填或者选填，以及不同表之间的指向。数据库强制执行这些规则，所以一个良好设计的数据库，可以使你的程序避免看到不一致，重复，孤立，过期，或者缺失的数据。</p>
<p>MySQL中的SQL代表“结构化查询语言”。SQL是用于访问数据库的最通用的标准化语言。基于你的程序设计环境，又可以直接输入SQL（比如，用于创建报表），用另一种语言把SQL注入到代码中，或者使用隐含SQL语法的特定语言的API。</p>
<p>SQL由 ANSI/ISO 的SQL标准来定义。SQL的标准从1986年以来不断发展，存在多个不同的版本。在本手册中，“SQL-92”是指1992年发布的标准，“SQL:1999”是指在1999年发布的版本，以及“SQL:2003”，指现在的版本。我们在任何时用到“SQL标准”这个词时，都是指当前版本的SQL标准。</p>
</li>
<li><p>MySQL软件是开源的</p>
<p>开源意味着对于任何人来说都可以使用和修改该软件。任何人都可以从网络上下载MySQL软件并且免费使用。你也可以按照你的意愿去学习和更改源代码以适应你的需求。MySQL软件使用<a href="http://www.fsf.org/licenses/">GPL</a>)（通用公共许可），来定义你在不同情景下对软件能做的和不能做的事。如果你对GPL感到不适，或者想要将MySQL的代码注入到一个商用软件中，你可以从我们这里购买一份商用许可。访问<a href="http://www.mysql.com/company/legal/licensing/">MySQL许可概览</a>以获取更多信息。</p>
</li>
<li><p>MySQL数据库服务快速，可靠，可拓展且易用</p>
<p>如果你寻求的就是这个，你应该去尝试一下。MySQL服务可以在笔记本或者台式机上与其他应用，网络服务一起舒适的运行，只需要一点甚至无需额外的关注。如果你将整台机器都用于MySQL，你可以调整设置利用所有的内存，CPU功率，以及IO性能。MySQL同样可以扩大网络和机器的集群。</p>
<p>MySQL服务最初开发用来比现有方式更快的处理数据，而且成功的应用在高要求的生产环境很多年。尽管经历了不断的发展，MySQL如今提供了一组丰富而有用的功能。其可连接性，速度以及安全性使得MySQL服务高度适合在网络上访问数据库。</p>
</li>
<li><p>MySQL服务运行于客户端/服务端或者嵌入式系统</p>
<p>MySQL数据库软件是一个客户端/服务端系统，其包含了一个多线程的SQL服务器用于支持不同的后端，不同的客户端程序以及库，管理工具，以及大范围的应用程序接口。</p>
<p>我们也提供MySQL服务作为一个嵌入的多线程库，你可以将其链接到你的应用以实现一个更小，更快，易于管理的独立产品。</p>
</li>
<li><p>大量捐赠的MySQL软件已经可用</p>
<p>MySQL服务有一些使用的功能是由与我们密切合作的用户开发的。很有可能你最喜欢的应用或者语言由MySQL数据库服务支持。</p>
</li>
</ul>
<p>“MySQL”的官方读法是“ My Ess Que Ell ”（而不是 “my sequel” ），但是我们不介意你把它读作“my sequel”或者别的当地的读法。</p>
<h4 id="1-3-2-MySQL的主要功能"><a href="#1-3-2-MySQL的主要功能" class="headerlink" title="1.3.2 MySQL的主要功能"></a>1.3.2 MySQL的主要功能</h4><p>本节描述了一些MySQL数据库软件的重要特征。在大部分情况下，该路线图适用于所有版本的MySQL。想要知道在特定版本的MySQL中引入的功能，请在“In a Nutshell”章节查看对应的手册：</p>
<ul>
<li>MySQL8.0：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html">章节1.4，“MySQL8.0更新了什么”</a></li>
<li>MySQL5.7：<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html">MySQL5.7更新了什么</a></li>
<li>MySQL5.6：<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-nutshell.html">MySQL5.6更新了什么</a></li>
<li>MySQL5.5：<a href="https://dev.mysql.com/doc/refman/5.5/en/mysql-nutshell.html">MySQL5.5更新了什么</a></li>
</ul>
<p><strong>内部实现和可移植性</strong></p>
<ul>
<li>由C和C++实现</li>
<li>通过了大规模的不同编译器的测试</li>
<li>在多个不同的平台上运行。详见<a href="https://www.mysql.com/support/supportedplatforms/database.html">https://www.mysql.com/support/supportedplatforms/database.html</a></li>
<li>关于移植，MySQL5.5及以上的版本使用CMake命令。更早的版本使用GNU Automake，Autoconf和Libtool。</li>
<li>经过了Purify（一个商用的内存泄漏探测器）以及Valgrind（一个GPL工具）的测试。（<a href="http://developer.kde.org/~sewardj/%EF%BC%89">http://developer.kde.org/~sewardj/）</a></li>
<li>使用具有独立模块的多层服务的设计。</li>
<li>设计为使用核心线程的多线程方式，如果多核CPU可用，则可以很容易的被使用。</li>
<li>提供了基于事务和非事务的存储引擎。</li>
<li>使用索引压缩的非常快速的B-tree磁盘（MyISAM）</li>
<li>设计为可以相对简单的增加另一个存储引擎。如果你想为一个内部的数据库提供一个SQL接口，这会非常有用。</li>
<li>使用了非常快速的基于线程的内存分配系统。</li>
<li>使用了一种优化了的内部循环的join来非常快速的执行join。</li>
<li>实现了在内存的hash table，其作为临时表来使用。</li>
<li>使用了一种尽可能快的高度优化的类库来实现SQL功能。在所有的查询初始化后一般就不会再有内存分配。</li>
<li>为使用客户端/服务端环境提供了作为单独程序的服务，作为一个库可以嵌入到独立的应用中。这种应用可以单独使用或者在网络无法访问的环境中使用。</li>
</ul>
<p><strong>数据类型</strong></p>
<ul>
<li>很多的数据类型：带符号/无符号的整数类型，1、2、3、4以及8比特的长度， <a href="https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html"><code>FLOAT</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html"><code>DOUBLE</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>BINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>TEXT</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>BLOB</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>DATE</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/time.html"><code>TIME</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>DATETIME</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>TIMESTAMP</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/year.html"><code>YEAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/set.html"><code>SET</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/enum.html"><code>ENUM</code></a> ，以及OpenGIS的空间数据类型。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">章节11，数据类型</a>。</li>
<li>固定长度和可变长度的字符串类型。</li>
</ul>
<p><strong>语句和功能</strong></p>
<ul>
<li><p>所有的操作符和功能支持都在Select列表和Where条件语句查询中。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CONCAT(first_name, <span class="string">&#x27; &#x27;</span>, last_name)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> citizen</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> income<span class="operator">/</span>dependents <span class="operator">&gt;</span> <span class="number">10000</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>完全支持SQL中的<code>Group By</code>和<code>Order By</code>条件。提供Group的功能的支持（ <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count"><code>COUNT()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg"><code>AVG()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_std"><code>STD()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum"><code>SUM()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max"><code>MAX()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min"><code>MIN()</code></a>, 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat"><code>GROUP_CONCAT()</code></a>) ）</p>
</li>
<li><p>完全支持拥有SQL和ODBC语法的 <code>LEFT OUTER JOIN</code> 和 <code>RIGHT OUTER JOIN</code>  </p>
</li>
<li><p>支持标准SQL要求的表和列的别名。</p>
</li>
<li><p>支持<code>Delete</code>，<code>Insert</code>，<code>Replace</code>，以及在<code>update</code>时返回修改的数量，或者返回匹配的行数，而不是在连接服务器时设置一个标识。</p>
</li>
<li><p>支持MySQL特定的<code>show</code>语句，用于返回数据库，存储引擎，表，以及索引的信息。支持 <code>INFORMATION_SCHEMA</code>数据库，实现自标准SQL。</p>
</li>
<li><p> <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> 语句会展现优化器如何处理查询语句的。</p>
</li>
<li><p>函数名称独立于表明和列名。比如，<code>ABS</code>是一个合法的列明。唯一的限制是在调用函数时，在函数名和(之间不能存在空格。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">章节9.3，关键字和保留字</a>。</p>
</li>
<li><p>你可以在一个语句内指定不同数据库的表。</p>
</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>权限和密码系统非常灵活和安全，并支持基于主机的认证。</li>
<li>连接服务器时，通过对所有密码通信进行加密来实现密码安全。</li>
</ul>
<p><strong>可拓展性和限制</strong></p>
<ul>
<li>支持大型数据库。我们使用的MySQL服务拥有可以包含5000万条数据的数据库。我们也知道拥有20万张表和50亿条数据的MySQL服务器的用户。</li>
<li>支持每张表最多64个索引。每个索引可以包含1-16列或者部分列。InnoDB表的索引最大宽度为767字节或者3072字节。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html">章节15.6.1.16，“InnoDB表的限制”</a>。MyISAM表的最大索引宽度为1000字节。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html">章节16.2，“MyISAM存储引擎”</a>。可以使用Char，Varchar，Blob或者Text字段类型的前缀作为一个索引。</li>
</ul>
<p><strong>可连接性</strong></p>
<ul>
<li>客户端可以通过不同的协议连接MySQL服务：<ul>
<li>客户端可以在任何平台上使用TCP/IP端口进行连接。</li>
<li>在windows系统，如果服务端启用了 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_named_pipe"><code>named_pipe</code></a> 系统参数进行启动，那客户端就可以使用name pipe进行连接。如果服务端启用了 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_shared_memory"><code>shared_memory</code></a>  系统参数进行启动，那客户端也可以使用  <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_shared_memory"><code>shared_memory</code></a>  方式进行连接。客户端可以通过使用  <a href="https://dev.mysql.com/doc/refman/8.0/en/connection-options.html#option_general_protocol"><code>--protocol=memory</code></a> 选项来进行shared memory的连接。</li>
<li>在unix系统，客户端可以使用Unix域的套接字文件来进行连接。</li>
</ul>
</li>
<li>MySQL的客户端程序可以用不同的语言编写。一个C语言编写的客户端库可以用于C语言和C++编写的客户端，或者任何别的提供C语言绑定的语言。</li>
<li> C, C++, Eiffel, Java, Perl, PHP, Python, Ruby, 和 Tcl 的API都是可用的，使得MySQL客户端可以被多种语言编写。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/connectors-apis.html">章节28，连接器和API</a>.</li>
<li>连接器/ODBC（MyODBC）接口为那些使用ODBC（Open Datebase Connectivity）连接的客户端程序提供了MySQL支持。比如说，你可以使用MS Access去连接你的MySQL服务器。客户端可以运行在Windows或者Unix。连接器/ODBC源是可用的。和很多其他的功能一样，所有的ODBC2.5的功能都是被支持的。详见<a href="https://dev.mysql.com/doc/connector-odbc/en/">MySQL 连接器/ODBC开发者指南</a>。</li>
<li>连接器/J 接口为那些使用了JDBC连接器的java客户端程序提供了MySQL支持。客户端可以运行于Windows或者Unix。连接器/J 源是可用的。详见<a href="https://dev.mysql.com/doc/connector-j/5.1/en/">MySQL连接器/J 5.1开发者指南</a>。</li>
<li>MySQL连接器/NET 允许开发者创建一个要求安全和高性能数据连接MySQL的.NET应用程序。它实现了必须的ADO.NET的接口并融入进了ADO.NET的感知工具。开发者可以选择他们的.NET语言去构建应用。MySQL连接器/NET是一个完全托管的ADO.NET驱动，100%由纯粹的C#编写。详见<a href="https://dev.mysql.com/doc/connector-net/en/">MySQL连接器/NET开发者指南</a>。</li>
</ul>
<p><strong>本地化</strong></p>
<ul>
<li>服务器可以提供各种语言的报错信息。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/error-message-language.html">章节10.12，设置错误提示的语言</a>。</li>
<li>完全支持不同的字符集，包括 <code>latin1</code> (cp1252)，<code>german</code>，<code>big5</code>，<code>ujis</code> ，几种Unicode编码，以及别的。比如， Scandinavian 的字符 “<code>å</code>”, “<code>ä</code>” 和“<code>ö</code>” 可以用在表和列的名字中。</li>
<li>所有的数据以选定的字符集存储。</li>
<li>根据默认的字符集和校对规则进行排序和比较。当MySQL服务运行的时候也可以对该规则进行更改(详见<a href="https://dev.mysql.com/doc/refman/8.0/en/charset-server.html">章节10.3.2，“服务器字符集和校验”</a>)。一个非常高级的排序例子，可以看下捷克的排序编码。MySQL支持多种可以在编译和运行阶段指定的字符集。</li>
<li>服务器时区可以动态的改变，而且单独的客户端可以指定各自的时区。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">章节5.1.13，MySQL服务器时区支持</a>。</li>
</ul>
<p><strong>客户端和工具</strong></p>
<ul>
<li>MySQL包含多个客户端和实用程序。包括命令行程序，比如 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html"><strong>mysqldump</strong></a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqladmin.html"><strong>mysqladmin</strong></a> ，以及图形化程序 <a href="https://dev.mysql.com/doc/refman/8.0/en/workbench.html">MySQL Workbench</a> 。</li>
<li>MySQL服务器内置了对于SQL语句的检查，优化和表修复的支持。这些语句可以通过<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlcheck.html">mysqlcheck</a>客户端从命令行使用。MySQL也包含了<a href="https://dev.mysql.com/doc/refman/8.0/en/myisamchk.html">myisamchk</a>工具，一个非常快速的命令行工具，用于在MyISAM表提交这些操作。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/programs.html">章节4，MySQL程序</a>。</li>
<li>可以调用 –help 和 -?来呼叫MySQL程序用以获取在线协助。</li>
</ul>
<h4 id="1-3-3-MySQL的历史"><a href="#1-3-3-MySQL的历史" class="headerlink" title="1.3.3 MySQL的历史"></a>1.3.3 MySQL的历史</h4><p>我们一开始想要用我们自己的快速，低级的引擎来使用mSQL数据库来连接我们的表。然而，经过了一些测试后，我们认为mSQL的速度和灵活性达不到我们的要求。这导致了我们的数据库的一个新的SQL接口，但是其API接口和mSQL几乎一样。该API设计为允许那些为mSQL编写的第三方代码可以很方便的移植以用于MySQL。</p>
<p>MySQL得名于联合创建人Monty Widenius的女儿，My。</p>
<p>MySQL的海豚（我们的logo）的名字是“Sakila”，这来自于“为海豚取名”的比赛中用户建议的庞大的名字列表里选择出来的。最后获胜的名字由来自非洲Swaziland， 一个名叫Ambrose Twebaze的开源软件开发者提供。据 Ambrose所说，这个女性化的名字Sakila出自 Swaziland 的当地语Siswati。Sakila也是坦桑尼亚的 Arusha 的一个城镇的名字，邻近 Ambrose 的原籍国乌干达。</p>
<h3 id="1-4-MySQL8-0更新了什么"><a href="#1-4-MySQL8-0更新了什么" class="headerlink" title="1.4 MySQL8.0更新了什么"></a>1.4 MySQL8.0更新了什么</h3><p>这一节总结了在MySQL8.0中哪些被添加，启用，以及移除。随附的部分罗列了在MySQL8.0中已经被新增，启用，移除的选项和变量。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/added-deprecated-removed.html">章节1.5，“服务器，状态变量和选项在MySQL8.0中的添加，弃用和删除”</a>。</p>
<span id="more"></span>
<p><strong>MySQL8.0新增的特性</strong></p>
<p>以下特性被加入到MySQL8.0中：</p>
<ul>
<li><p><strong>数据字典。</strong> MySQL现在合并了一个可以存储数据库对象的事务化的数据字典。在之前的MySQL发行版中，数据字典存储在元数据文件和非事务的表。关于更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary.html">章节14，MySQL数据字典</a>。</p>
</li>
<li><p><strong>原子数据定义语句(原子DDL)。</strong> 一个原子DDL语句包含了数据字典的升级，存储引擎的操作，以及将关联DDL操作的二进制日志写入到单独的原子事务中。要获取更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html">章节13.1.1，“原子数据定义语句的支持”</a>。</p>
</li>
<li><p><strong>升级过程。</strong> 在以前，安装了一个新版本的MySQL后，MySQL服务器会在下一次启动时自动升级数据字典表，在此之后，需要DBA在mysql的schema里手动调用 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 去升级系统表，也包括在别的schema比如sys schema和user schema里面的对象。</p>
<p>对于MySQL8.0.16来说，服务器会执行先前由 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 控制的任务。在安装了新版本的MySQL之后，服务器会在下次升级时自动执行所有的升级任务，而不是依赖DBA去调用 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 。而且，服务器会更新帮助表里面的内容（这是 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 没有做的）。一个新的 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-options.html#option_mysqld_upgrade"><code>--upgrade</code></a> 服务器参数为服务器如何自动执行数据字典和服务器升级的选项提供了控制。想要了解更多，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-what-is-upgraded.html">章节2.11.3，MySQL的升级流程升级了什么</a>。</p>
</li>
<li><p><strong>安全和账户管理</strong>。增加下列增强的功能后，可以提高安全性以及增加DBA在账户管理方面的灵活性：</p>
<ul>
<li><p>在mysql系统数据库中的授权表现在属于InnoDB（事务型）表。以前它们是MyISAM（非事务型）表。授权表的存储引擎的变化是伴随账户管理语句变化的基础。以前一句命名多个用户的账户管理的语句（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-user.html"><code>CREATE USER</code></a> 或 <a href="https://dev.mysql.com/doc/refman/8.0/en/drop-user.html"><code>DROP USER</code></a>) ，在其中一些用户命名失败的情况下也可以对别的用户命名成功。现在，每一个语句都是事务的，且要么所有的命名用户都成功，要么其中任何一个失败之后语句都会回滚并不发生任何效果。语句如果成功会被写入二进制表中，但是在失败时不会写入；在这种情况下，会发生回滚且没有任何变化发生。想要了解更多，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html">13.1.1“原子数据定义语句的支持”</a>。</p>
</li>
<li><p>一个新的 <code>caching_sha2_password</code>  认证插件已经可用。类似于 <code>sha256_password</code>  插件， caching_sha2_password 实现了 SHA-256 的密码Hash，但是在连接时用缓存来解决延迟问题。它也支持更多的连接协议，而且不需要为了基于RAS密钥对的密码交换功能和OpenSSL进行连接。</p>
<p> caching_sha2_password 和 sha256_password 的认证方式相比 mysql_native_password 插件提供了更多的安全加密方式，而且 caching_sha2_password 的性能比sha256_password更好。由于这些 caching_sha2_password 卓越的安全和性能的特点，现在已经成为首选的认证插件，而且也是默认的认证插件，而不是  <code>mysql_native_password</code> 。想要了解这种默认插件的变化对于服务器操作和服务器与客户端及连接器之间的兼容性的信息，详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password"> caching_sha2_password 作为首选的认证插件</a>。</p>
</li>
<li><p>MySQL如今支持角色，即权限集合的命名。角色可以被创建和删除。角色可以被授权和撤销权限。角色可以从用户账号中授权和删除。一个账户下的活跃的适用角色可以从账户里已授权的角色中选择，也可以在账户的登陆期间进行修改。想要了解更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/roles.html">6.2.10，使用角色</a>。</p>
</li>
<li><p>MySQL现在包含了用户账号目录的概念，根据系统和普通用户区分他们是否有 <a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a> 权限。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/account-categories.html">6.2.11，账户目录</a>。</p>
</li>
<li><p>在以前，除非在某些schema里，否则不能授予一个全局的权限。现在只要设置 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_partial_revokes"><code>partial_revokes</code></a>  系统参数为 enabled 就可以做到。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/partial-revokes.html">6.2.12，使用部分撤销的权限限制</a>。</p>
</li>
<li><p>授权语句拥有一个可以指定额外的权限信息的用户条件去用于语句执行。这种语法在SQL层面可见， 尽管其主要目的是使在部分撤销所施加的授予者特权限制的所有节点之间实现统一复制， 通过使这些限制出现在二进制日志中。</p>
</li>
<li><p>MySQL现在会保留历史密码信息，限制重复使用以前的密码。DBA可以要求一些数量的密码更改或者一段时间内不可以从以前的密码中选择。可以为全局和每个账户建立密码重新使用的策略。</p>
<p>现在可以通过指定当前要被取代的密码来验证更改密码的操作。这可以让DBA去避免那些不能提供他们知道的当前密码的用户去修改密码。可以为全局或每个账户建立密码验证策略。</p>
<p>账户现在允许使用双重验证，这使得在复杂的多服务器系统上可以无缝的提交分阶段的密码修改，而不需要停机。</p>
<p>这些功能为DBA提供了对密码管理的完全掌控。关于更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/password-management.html">6.2.15，密码管理</a>。</p>
</li>
<li><p>MySQL现在支持FIPS模式，它使用OpenSSL编译，在运行时一个OpenSSL库和FIPS对象模式都是可用的。FIPS模式为密码相关操作强加了一些条件，比如对于可接受的加密方式的限制，或者对于密码长度的要求。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/fips-mode.html">6.5，FIPS支持</a>。</p>
</li>
<li><p>服务器现在可以在运行时重新配置服务器用于新连接的SSL上下文。该功能可能会很有用，比如，在一个MySQL服务器运行太久而SSL证书过期，可以避免去重启该服务器。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/using-encrypted-connections.html#using-encrypted-connections-server-side-runtime-configuration">加密连接的服务器端运行时配置</a>。</p>
</li>
<li><p>OpenSSL1.1.1支持用于加密连接的TLS1.3协议，如果服务端和客户端都用OpenSSL或更高版本来编译，那么MySQL8.0.16和更高版本下也将支持TLS1.3协议。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/encrypted-connection-protocols-ciphers.html">6.3.2，加密连接TLS协议和密码</a>。</p>
</li>
<li><p>MySQL现在授予客户端在已命名的管道上用于windows尽量少的必要连接的访问控制。新的MySQL客户端软件可以不用任何额外配置打开命名管道连接。如果更早版本的客户端软件不能马上升级，那么新的 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_named_pipe_full_access_group"><code>named_pipe_full_access_group</code></a>系统参数可以给予windows用户组必要的权限用于打开命名管道连接。完全访问权限的用户组的成员应该是暂时的且被限制的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理。</strong> MySQL现在支持资源组的创建和管理，并且允许跟服务器一起运行的线程分配给特定的组，以便线程根据组的可用的资源执行。组属性可以控制其资源，允许或者限制组内线程的资源消费。DBA可以根据不同的工作量来调整这些属性为合适的值。现在，CPU时间是可以管理的资源，其概念由”虚拟CPU”来表示，其包含了CPU内核，超线程，硬件线程等等。服务器在启动时决定有多少虚拟CPU可用，并且拥有相应权限的数据库管理员可以将这些CPU与资源组关联并分配线程给组。要了解更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html">8.12.5，资源组</a>。</p>
</li>
<li><p><strong>表加密管理。</strong> 现在可以通过定义和强制加密默认值来全局管理表加密。default_table_encryption常量为新创建的schema和一般表空间定义了一个加密默认值。当创建一个schema时，加密默认值同时也可以用DEFAULT ENCRYPTION条款来进行定义。默认情况下，创建一个表的同时<br>会继承当前的schema或一般表空间的加密方式。设置table_encryption_privilege_check常量为可用，会强制使用加密默认值。当创建和修改一个不同于默认表加密设置的schema或表空间，或创建和修改一个不同于默认schema加密设置的表时，会发生权限检查。在table_encryption_privilege_check常量<br>为可用时，TABLE_ENCRYPTION_ADMIN权限会允许覆盖默认加密设置。想要了解更多这方面信息，查看《为Schemas和一般表空间定义一个加密默认值》章节。</p>
</li>
<li><p><strong>InnoDB的优化</strong> 包含以下对于InnoDB的优化：</p>
<ul>
<li>当前最大的自增计数器发生值改变时，会写入到redo日志，并在每一次检查点保存在私有引擎的系统表里。这个改进使得自增计数器的值在系统重启时保持不变。额外的：<ul>
<li>服务器重启时不会取消表选项里<code>AUTO_INCREMENT=N</code>的效果。如果你重新设置了自增计数器的值，或者你将自增计数器的值修改为一个很大的值，新的值也会在服务器重启时保持不变。</li>
<li>服务器重启时会立刻跟随一项<a href="https://dev.mysql.com/doc/refman/8.0/en/commit.html">ROLLBACK</a>的操作，而不再重新使用事务回滚后的自增值。</li>
<li>如果你将自增列的值修改为一个比当前最大自增值更大的值（比如一个update的操作），新的值会持久化，并且随之的新增操作会在这个值基础上自增。<br>更多的信息，详见15.6.1.6章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">InnoDB中的自增操作</a>，以及<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization">InnoDB自增计数器的初始化</a>。</li>
</ul>
</li>
<li>当索引树的损坏发生时，InnoDB会往redo日志写入一个损坏标识，这会保证损坏标识安全的销毁。InnoDB也会在每个检查点往私有引擎的系统表里写入内存崩溃的标识数据。在还原时，InnoDB在表和索引被标识为崩溃对象前会从这两个地方读取崩溃标识并合并结果内容。</li>
<li>InnoDB缓存插件支持多种get操作（在一个缓存查询中获取多种key-value组合）和范围查询。详见15.20.4章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html">InnoDB缓存的多种get和范围查询支持</a></li>
<li>innodb_deadlock_detect是一个新的动态变量，可以用于对不可用的死锁的监控。在高级的金融系统中，死锁监控可以缓解大量的线程等待同一个锁的情况。同时，在死锁发生时，使用在事务回滚时的innodb_lock_wait_timeout的设置并关闭死锁监控也可能是更有效的办法。</li>
<li>新的<code>INFORMATION_SCHEMA.INNODB_CACHED_INDEXES</code>表会在InnoDB缓冲池中为每个索引记录索引页缓存的数量。</li>
<li>现在，InnoDB的临时表会在共享的临时表空间ibtmp1中创建。</li>
<li>InnoDB<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html">表空间加密功能</a>支持对于redo日志和undo日志数据的加密。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html#innodb-data-encryption-redo-log">Redo日志加密</a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html#innodb-data-encryption-undo-log">Undo日志加密</a>。</li>
<li>对于<code>SELECT ... FOR SHARE</code>和<code>SELECT ... FOR UPDATE</code>这样的加锁读取语句，InnoDB支持使用<code>NOWAIT</code>和<code>SKIP LOCKED</code>选项。语句中的<code>NOWAIT</code>选项的效果是当一列被请求的行被另一个事务锁定时立刻返回结果。<code>SKIP LOCKED</code>会在结果集中移除被锁定的行。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html#innodb-locking-reads-nowait-skip-locked">并发锁读中使用NOWAIT和SKIP LOCKED</a>。<br><code>SELECT ... FOR SHARE</code>语句取代<code>SELECT ... LOCK IN SHARE MODE</code>，但是<code>LOCK IN SHARE MODE</code>依然保持着向后的兼容性。两个语句是等效的。但是<code>FOR UPDATE</code>和<code>FOR SHARE</code>支持<code>NOWAIT&#39;，&#39;SKIP LOCKED</code>，以及<code>OF</code>之类的<code>tbl_name</code>选项。<br>详见13.2.10章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">SELECT STATEMENT</a>。<code>OF</code>这个<code>tbl_name</code>值用于锁定对命名的表的查询(TODO)。</li>
<li>ADD PARTITION, DROP PARTITION, COALESCE PARTITION, REORGANIZE PARTITION, and REBUILD PARTITION ALTER TABLE options are supported by native partitioning<br>in-place APIs and may be used with ALGORITHM={COPY|INPLACE} and LOCK clauses.DROP PARTITION with ALGORITHM=INPLACE deletes data stored in the partition and drops the partition. However,<br>DROP PARTITION with ALGORITHM=COPY or old_alter_table=ON rebuilds the partitioned table and attempts to move data from the dropped partition<br>to another partition with a compatible PARTITION … VALUES definition. Data that cannot be moved to another partition is deleted. </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用命令笔记</title>
    <url>/2022/06/22/tech/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<a href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/</a> ，JavaGuide 对本文进行了简答排版，新增了目录。 作者：格物</p>
</blockquote>
<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>
<span id="more"></span>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Windows服务 */</span></span><br><span class="line"><span class="comment">-- 启动MySQL</span></span><br><span class="line">    net <span class="keyword">start</span> mysql</span><br><span class="line"><span class="comment">-- 创建Windows服务</span></span><br><span class="line">    sc <span class="keyword">create</span> mysql binPath<span class="operator">=</span> mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line"><span class="comment">/* 连接与断开服务器 */</span></span><br><span class="line">mysql <span class="operator">-</span>u 地址 <span class="operator">-</span>P 端口 <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 密码</span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST <span class="comment">-- 显示哪些线程正在运行</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="comment">-- 显示系统变量信息</span></span><br></pre></td></tr></table></figure>


<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数据库操作 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 显示当前时间、用户名、数据库版本</span></span><br><span class="line">    <span class="keyword">SELECT</span> now(), <span class="keyword">user</span>(), version();</span><br><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line">    <span class="keyword">CREATE</span> DATABASE[ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 数据库选项</span><br><span class="line">    <span class="comment">-- 数据库选项：</span></span><br><span class="line">        <span class="type">CHARACTER</span> <span class="keyword">SET</span> charset_name</span><br><span class="line">        <span class="keyword">COLLATE</span> collation_name</span><br><span class="line"><span class="comment">-- 查看已有库</span></span><br><span class="line">    <span class="keyword">SHOW</span> DATABASES[ <span class="keyword">LIKE</span> <span class="string">&#x27;PATTERN&#x27;</span>]</span><br><span class="line"><span class="comment">-- 查看当前库信息</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"><span class="comment">-- 修改库的选项信息</span></span><br><span class="line">    <span class="keyword">ALTER</span> DATABASE 库名 选项信息</span><br><span class="line"><span class="comment">-- 删除库</span></span><br><span class="line">    <span class="keyword">DROP</span> DATABASE[ IF <span class="keyword">EXISTS</span>] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure>

<h1 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line">    <span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span>[ IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        <span class="comment">/*每个字段必须有数据类型</span></span><br><span class="line"><span class="comment">        最后一个字段后不能有逗号</span></span><br><span class="line"><span class="comment">        TEMPORARY 临时表，会话结束时表自动消失</span></span><br><span class="line"><span class="comment">        对于字段的定义：</span></span><br><span class="line"><span class="comment">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#x27;string&#x27;]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">-- 表选项</span></span><br><span class="line">    <span class="comment">-- 字符集</span></span><br><span class="line">        CHARSET <span class="operator">=</span> charset_name</span><br><span class="line">        <span class="comment">-- 如果表没有设定，则使用数据库字符集</span></span><br><span class="line">    <span class="comment">-- 存储引擎</span></span><br><span class="line">        ENGINE <span class="operator">=</span> engine_name</span><br><span class="line">        <span class="comment">/*表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span></span><br><span class="line"><span class="comment">        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive</span></span><br><span class="line"><span class="comment">        不同的引擎在保存表的结构和数据时采用不同的方式</span></span><br><span class="line"><span class="comment">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span></span><br><span class="line"><span class="comment">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span></span><br><span class="line"><span class="comment">        SHOW ENGINES -- 显示存储引擎的状态信息</span></span><br><span class="line"><span class="comment">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息*/</span></span><br><span class="line">    <span class="comment">-- 自增起始数</span></span><br><span class="line">    	AUTO_INCREMENT <span class="operator">=</span> 行数</span><br><span class="line">    <span class="comment">-- 数据文件目录</span></span><br><span class="line">        DATA DIRECTORY <span class="operator">=</span> <span class="string">&#x27;目录&#x27;</span></span><br><span class="line">    <span class="comment">-- 索引文件目录</span></span><br><span class="line">        INDEX DIRECTORY <span class="operator">=</span> <span class="string">&#x27;目录&#x27;</span></span><br><span class="line">    <span class="comment">-- 表注释</span></span><br><span class="line">        COMMENT <span class="operator">=</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    <span class="comment">-- 分区选项</span></span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... (详细见手册)</span><br><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line">    <span class="keyword">SHOW</span> TABLES[ <span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span>  库名</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="comment">--（信息更详细）</span></span><br><span class="line">    <span class="keyword">DESC</span> 表名 <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 表名 <span class="operator">/</span> EXPLAIN 表名 <span class="operator">/</span> <span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> 表名 [<span class="keyword">LIKE</span> <span class="string">&#x27;PATTERN&#x27;</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"><span class="comment">-- 修改表</span></span><br><span class="line">    <span class="comment">-- 修改表本身的选项</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 表的选项</span><br><span class="line">        eg: <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE<span class="operator">=</span>MYISAM;</span><br><span class="line">    <span class="comment">-- 对表进行重命名</span></span><br><span class="line">        RENAME <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 新表名</span><br><span class="line">        RENAME <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 库名.表名 <span class="comment">--（可将表移动到另一个数据库）</span></span><br><span class="line">        <span class="comment">-- RENAME可以交换两个表名</span></span><br><span class="line">    <span class="comment">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 操作名</span><br><span class="line">        <span class="comment">-- 操作名</span></span><br><span class="line">            <span class="keyword">ADD</span>[ <span class="keyword">COLUMN</span>] 字段定义       <span class="comment">-- 增加字段</span></span><br><span class="line">                AFTER 字段名          <span class="comment">-- 表示增加在该字段名后面</span></span><br><span class="line">                <span class="keyword">FIRST</span>               <span class="comment">-- 表示增加在第一个</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段名)   <span class="comment">-- 创建主键</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [索引名] (字段名)<span class="comment">-- 创建唯一索引</span></span><br><span class="line">            <span class="keyword">ADD</span> INDEX [索引名] (字段名) <span class="comment">-- 创建普通索引</span></span><br><span class="line">            <span class="keyword">DROP</span>[ <span class="keyword">COLUMN</span>] 字段名      <span class="comment">-- 删除字段</span></span><br><span class="line">            MODIFY[ <span class="keyword">COLUMN</span>] 字段名 字段属性     <span class="comment">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span></span><br><span class="line">            CHANGE[ <span class="keyword">COLUMN</span>] 原字段名 新字段名 字段属性      <span class="comment">-- 支持对字段名修改</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY    <span class="comment">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span></span><br><span class="line">            <span class="keyword">DROP</span> INDEX 索引名 <span class="comment">-- 删除索引</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键    <span class="comment">-- 删除外键</span></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span>[ IF <span class="keyword">EXISTS</span>] 表名 ...</span><br><span class="line"><span class="comment">-- 清空表数据</span></span><br><span class="line">    <span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] 表名</span><br><span class="line"><span class="comment">-- 复制表结构</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">LIKE</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 复制表结构和数据</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 [<span class="keyword">AS</span>] <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 检查表是否有错误</span></span><br><span class="line">    <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line"><span class="comment">-- 优化表</span></span><br><span class="line">    OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"><span class="comment">-- 修复表</span></span><br><span class="line">    REPAIR [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line"><span class="comment">-- 分析表</span></span><br><span class="line">    ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数据操作 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- 增</span></span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(字段列表)] <span class="keyword">VALUES</span> (值列表)[, (值列表), ...]</span><br><span class="line">        <span class="comment">-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span></span><br><span class="line">        <span class="comment">-- 可同时插入多条数据记录！</span></span><br><span class="line">        <span class="comment">-- REPLACE 与 INSERT 完全一样，可互换。</span></span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 <span class="keyword">SET</span> 字段名<span class="operator">=</span>值[, 字段名<span class="operator">=</span>值, ...]</span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line">    <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名[ 其他子句]</span><br><span class="line">        <span class="comment">-- 可来自多个表的多个字段</span></span><br><span class="line">        <span class="comment">-- 其他子句可以不使用</span></span><br><span class="line">        <span class="comment">-- 字段列表可以用*代替，表示所有字段</span></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名[ 删除条件子句]</span><br><span class="line">        <span class="comment">-- 没有条件子句，则会删除全部</span></span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line">    UPDATE 表名 <span class="keyword">SET</span> 字段名<span class="operator">=</span>新值[, 字段名<span class="operator">=</span>新值] [更新条件]</span><br></pre></td></tr></table></figure>

<h1 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符集编码 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- MySQL、数据库、表、字段均可设置编码</span></span><br><span class="line"><span class="comment">-- 数据编码与客户端编码不需一致</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character_set_%&#x27;</span>   <span class="comment">-- 查看所有字符集编码项</span></span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 变量值</span><br><span class="line">    <span class="keyword">SET</span> character_set_client <span class="operator">=</span> gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_results <span class="operator">=</span> gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_connection <span class="operator">=</span> gbk;</span><br><span class="line"><span class="keyword">SET</span> NAMES GBK;  <span class="comment">-- 相当于完成以上三个设置</span></span><br><span class="line"><span class="comment">-- 校对集</span></span><br><span class="line">    校对集用以排序</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]<span class="operator">/</span><span class="keyword">SHOW</span> CHARSET [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]   查看所有字符集</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    <span class="keyword">COLLATE</span> 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure>

<h1 id="数据类型-列类型"><a href="#数据类型-列类型" class="headerlink" title="数据类型(列类型)"></a>数据类型(列类型)</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数据类型（列类型） */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="number">1.</span> 数值类型</span><br><span class="line"><span class="comment">-- a. 整型 ----------</span></span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     <span class="number">1</span>字节    <span class="number">-128</span> <span class="operator">~</span> <span class="number">127</span>      无符号位：<span class="number">0</span> <span class="operator">~</span> <span class="number">255</span></span><br><span class="line">    <span class="type">smallint</span>    <span class="number">2</span>字节    <span class="number">-32768</span> <span class="operator">~</span> <span class="number">32767</span></span><br><span class="line">    mediumint   <span class="number">3</span>字节    <span class="number">-8388608</span> <span class="operator">~</span> <span class="number">8388607</span></span><br><span class="line">    <span class="type">int</span>         <span class="number">4</span>字节</span><br><span class="line">    <span class="type">bigint</span>      <span class="number">8</span>字节</span><br><span class="line">    <span class="type">int</span>(M)  M表示总位数</span><br><span class="line">    <span class="comment">-- 默认存在符号位，unsigned 属性修改</span></span><br><span class="line">    <span class="comment">-- 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span></span><br><span class="line">    <span class="comment">--    例：int(5)   插入一个数&#x27;123&#x27;，补填后为&#x27;00123&#x27;</span></span><br><span class="line">    <span class="comment">-- 在满足要求的情况下，越小越好。</span></span><br><span class="line">    <span class="comment">-- 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span></span><br><span class="line"><span class="comment">-- b. 浮点型 ----------</span></span><br><span class="line">    类型             字节     范围</span><br><span class="line">    <span class="type">float</span>(单精度)     <span class="number">4</span>字节</span><br><span class="line">    <span class="keyword">double</span>(双精度)    <span class="number">8</span>字节</span><br><span class="line">    <span class="comment">/*浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span></span><br><span class="line"><span class="comment">        不同于整型，前后均会补填0.</span></span><br><span class="line"><span class="comment">    定义浮点型时，需指定总位数和小数位数。</span></span><br><span class="line"><span class="comment">        float(M, D)     double(M, D)</span></span><br><span class="line"><span class="comment">        M表示总位数，D表示小数位数。</span></span><br><span class="line"><span class="comment">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span></span><br><span class="line"><span class="comment">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span></span><br><span class="line"><span class="comment">        支持科学计数法表示。</span></span><br><span class="line"><span class="comment">        浮点数表示近似值。*/</span></span><br><span class="line"><span class="comment">-- c. 定点数 ----------</span></span><br><span class="line">    <span class="type">decimal</span> <span class="comment">-- 可变长度</span></span><br><span class="line">    <span class="type">decimal</span>(M, D)   <span class="comment">--M也表示总位数，D表示小数位数。</span></span><br><span class="line">    <span class="comment">--保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span></span><br><span class="line">    <span class="comment">--将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span></span><br><span class="line"><span class="number">2.</span> 字符串类型</span><br><span class="line"><span class="comment">-- a. char, varchar ----------</span></span><br><span class="line">    <span class="type">char</span>    <span class="comment">--定长字符串，速度快，但浪费空间</span></span><br><span class="line">    <span class="type">varchar</span> <span class="comment">--变长字符串，速度慢，但节省空间</span></span><br><span class="line">    <span class="comment">--M表示能存储的最大长度，此长度是字符数，非字节数。</span></span><br><span class="line">    <span class="comment">--不同的编码，所占用的空间不同。</span></span><br><span class="line">    <span class="type">char</span>,<span class="comment">--最多255个字符，与编码无关。</span></span><br><span class="line">    <span class="type">varchar</span>,<span class="comment">--最多65535字符，与编码有关。</span></span><br><span class="line">    <span class="comment">--条有效记录最大不能超过65535个字节。</span></span><br><span class="line">        <span class="comment">--utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span></span><br><span class="line">    <span class="type">varchar</span> <span class="comment">--是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span></span><br><span class="line">    <span class="type">varchar</span> <span class="comment">--的最大有效长度由最大行大小和使用的字符集确定。</span></span><br><span class="line">    <span class="comment">--最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是65535-1-2=65532字节。</span></span><br><span class="line">    <span class="comment">--例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</span></span><br><span class="line"><span class="comment">-- b. blob, text ----------</span></span><br><span class="line">    <span class="type">blob</span> <span class="comment">--二进制字符串（字节字符串）</span></span><br><span class="line">        tinyblob, <span class="type">blob</span>, mediumblob, longblob</span><br><span class="line">    text <span class="comment">--非二进制字符串（字符字符串）</span></span><br><span class="line">        <span class="comment">--tinytext, text, mediumtext, longtext</span></span><br><span class="line">    text <span class="comment">--在定义时，不需要定义长度，也不会计算总长度。</span></span><br><span class="line">    text <span class="comment">--类型在定义时，不可给default值</span></span><br><span class="line"><span class="comment">-- c. binary, varbinary ----------</span></span><br><span class="line">    <span class="comment">--类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span></span><br><span class="line">    <span class="type">char</span>, <span class="type">varchar</span>, text 对应 <span class="type">binary</span>, <span class="type">varbinary</span>, blob.</span><br><span class="line"><span class="number">3.</span> 日期时间类型</span><br><span class="line">    <span class="comment">-- 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span></span><br><span class="line">    datetime    <span class="number">8</span>字节    日期及时间     <span class="number">1000</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> 到 <span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">    <span class="type">date</span>        <span class="number">3</span>字节    日期         <span class="number">1000</span><span class="number">-01</span><span class="number">-01</span> 到 <span class="number">9999</span><span class="number">-12</span><span class="number">-31</span></span><br><span class="line">    <span class="type">timestamp</span>   <span class="number">4</span>字节    时间戳        <span class="number">19700101000000</span> 到 <span class="number">2038</span><span class="number">-01</span><span class="number">-19</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07</span></span><br><span class="line">    <span class="type">time</span>        <span class="number">3</span>字节    时间         <span class="number">-838</span>:<span class="number">59</span>:<span class="number">59</span> 到 <span class="number">838</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">    <span class="keyword">year</span>        <span class="number">1</span>字节    年份         <span class="number">1901</span> <span class="operator">-</span> <span class="number">2155</span></span><br><span class="line">datetime    YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD hh:mm:ss</span><br><span class="line"><span class="type">timestamp</span>   YY<span class="operator">-</span>MM<span class="operator">-</span>DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line"><span class="type">date</span>        YYYY<span class="operator">-</span>MM<span class="operator">-</span>DD</span><br><span class="line">            YY<span class="operator">-</span>MM<span class="operator">-</span>DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line"><span class="type">time</span>        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line"><span class="keyword">year</span>        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line"><span class="number">4.</span> 枚举和集合</span><br><span class="line"><span class="comment">-- 枚举(enum) ----------</span></span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    <span class="comment">/*在已知的值中进行单选。最大数量为65535.</span></span><br><span class="line"><span class="comment">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span></span><br><span class="line"><span class="comment">    表现为字符串类型，存储却是整型。</span></span><br><span class="line"><span class="comment">    NULL值的索引是NULL。</span></span><br><span class="line"><span class="comment">    空字符串错误值的索引值是0。*/</span></span><br><span class="line"><span class="comment">-- 集合（set） ----------</span></span><br><span class="line"><span class="keyword">set</span>(val1, val2, val3...)</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> tab ( gender <span class="keyword">set</span>(<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;无&#x27;</span>) );</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="string">&#x27;男, 女&#x27;</span>);</span><br><span class="line">    <span class="comment">--最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span></span><br><span class="line">    <span class="comment">--当创建表时，SET成员值的尾部空格将自动被删除。</span></span><br></pre></td></tr></table></figure>

<h1 id="列属性-列约束"><a href="#列属性-列约束" class="headerlink" title="列属性(列约束)"></a>列属性(列约束)</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列属性（列约束） */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">PRIMARY</span> 主键</span><br><span class="line">    <span class="comment">-- 能唯一标识记录的字段，可以作为主键。</span></span><br><span class="line">    <span class="comment">-- 一个表只能有一个主键。</span></span><br><span class="line">    <span class="comment">-- 主键具有唯一性。</span></span><br><span class="line">    <span class="comment">-- 声明字段时，用 primary key 标识。</span></span><br><span class="line">        <span class="comment">--也可以在字段列表之后声明</span></span><br><span class="line">            <span class="comment">--例：create table tab ( id int, stu varchar(10), primary key (id));</span></span><br><span class="line">    <span class="comment">-- 主键字段的值不能为null。</span></span><br><span class="line">    <span class="comment">-- 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span></span><br><span class="line">        <span class="comment">-- 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">UNIQUE</span> 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">NULL</span> 约束</span><br><span class="line">    <span class="keyword">null</span>不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为<span class="keyword">null</span>，表示什么都没有。</span><br><span class="line">    <span class="keyword">null</span>, 允许为空。默认。</span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">null</span>, 不允许为空。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="keyword">null</span>, <span class="string">&#x27;val&#x27;</span>);</span><br><span class="line">        <span class="comment">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">DEFAULT</span> 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="keyword">default</span>, <span class="string">&#x27;val&#x27;</span>);    <span class="comment">-- 此时表示强制使用默认值。</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> tab ( add_time <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span> );</span><br><span class="line">        <span class="comment">-- 表示将当前时间的时间戳设为默认值。</span></span><br><span class="line">        <span class="built_in">current_date</span>, <span class="built_in">current_time</span></span><br><span class="line"><span class="number">5.</span> AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或<span class="keyword">unique</span>）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为<span class="number">1</span>开始自动增长。可以通过表属性 auto_increment <span class="operator">=</span> x进行设置，或 <span class="keyword">alter</span> <span class="keyword">table</span> tbl auto_increment <span class="operator">=</span> x;</span><br><span class="line"><span class="number">6.</span> COMMENT 注释</span><br><span class="line">    例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( id <span class="type">int</span> ) comment <span class="string">&#x27;注释内容&#x27;</span>;</span><br><span class="line"><span class="number">7.</span> <span class="keyword">FOREIGN</span> KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">constraint</span> `t1_t2_fk` <span class="keyword">foreign</span> key (t1_id) <span class="keyword">references</span> t2(id);</span><br><span class="line">        <span class="comment">-- 将表t1的t1_id外键关联到表t2的id字段。</span></span><br><span class="line">        <span class="comment">-- 每个外键都有一个名字，可以通过 constraint 指定</span></span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    <span class="keyword">foreign</span> key (外键字段） <span class="keyword">references</span> 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有<span class="keyword">not</span> <span class="keyword">null</span>。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 <span class="keyword">on</span> update 或 <span class="keyword">on</span> <span class="keyword">delete</span>：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    <span class="number">1.</span> cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">set</span> <span class="keyword">null</span>，设置为<span class="keyword">null</span>。主表数据被更新（主键值更新），从表的外键被设置为<span class="keyword">null</span>。主表记录被删除，从表相关记录外键被设置成<span class="keyword">null</span>。但注意，要求该外键列，没有<span class="keyword">not</span> <span class="keyword">null</span>属性约束。</span><br><span class="line">    <span class="number">3.</span> restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure>

<h1 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 建表规范 */</span> <span class="comment">------------------</span></span><br><span class="line">    <span class="comment">-- Normal Format, NF</span></span><br><span class="line">        <span class="operator">-</span> 每个表保存一个实体信息</span><br><span class="line">        <span class="operator">-</span> 每个具有一个ID字段作为主键</span><br><span class="line">        <span class="operator">-</span> ID主键 <span class="operator">+</span> 原子表</span><br><span class="line">    <span class="comment">-- 1NF, 第一范式</span></span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    <span class="comment">-- 2NF, 第二范式</span></span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除复合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    <span class="comment">-- 3NF, 第三范式</span></span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure>

<h1 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SELECT */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] select_expr <span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> [合计函数] <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    <span class="comment">-- 可以用 * 表示所有字段。</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span></span><br><span class="line">        <span class="keyword">select</span> stu, <span class="number">29</span><span class="operator">+</span><span class="number">25</span>, now() <span class="keyword">from</span> tb;</span><br><span class="line">    <span class="comment">-- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span></span><br><span class="line">        <span class="operator">-</span> 使用 <span class="keyword">as</span> 关键字，也可省略 as.</span><br><span class="line">        <span class="keyword">select</span> stu<span class="operator">+</span><span class="number">10</span> <span class="keyword">as</span> add10 <span class="keyword">from</span> tb;</span><br><span class="line">b. <span class="keyword">FROM</span> 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    <span class="comment">-- 可以为表起别名。使用as关键字。</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1 <span class="keyword">AS</span> tt, tb2 <span class="keyword">AS</span> bb;</span><br><span class="line">    <span class="comment">-- from子句后，可以同时出现多个表。</span></span><br><span class="line">        <span class="comment">-- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb1, tb2;</span><br><span class="line">    <span class="comment">-- 向优化符提示如何选择索引</span></span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 USE INDEX (key1,key2) <span class="keyword">WHERE</span> key1<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> key2<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> key3<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 IGNORE INDEX (key3) <span class="keyword">WHERE</span> key1<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> key2<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> key3<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">c. <span class="keyword">WHERE</span> 子句</span><br><span class="line">    <span class="comment">-- 从from获得的数据源中进行筛选。</span></span><br><span class="line">    <span class="comment">-- 整型1表示真，0表示假。</span></span><br><span class="line">    <span class="comment">-- 表达式由运算符和运算数组成。</span></span><br><span class="line">        <span class="comment">-- 运算数：变量（字段）、值、函数返回值</span></span><br><span class="line">        <span class="comment">-- 运算符：</span></span><br><span class="line">            <span class="operator">=</span>, <span class="operator">&lt;=&gt;</span>, <span class="operator">&lt;&gt;</span>, <span class="operator">!=</span>, <span class="operator">&lt;=</span>, <span class="operator">&lt;</span>, <span class="operator">&gt;=</span>, <span class="operator">&gt;</span>, <span class="operator">!</span>, <span class="operator">&amp;&amp;</span>, <span class="operator">||</span>,</span><br><span class="line">            <span class="keyword">in</span> (<span class="keyword">not</span>) <span class="keyword">null</span>, (<span class="keyword">not</span>) <span class="keyword">like</span>, (<span class="keyword">not</span>) <span class="keyword">in</span>, (<span class="keyword">not</span>) <span class="keyword">between</span> <span class="keyword">and</span>, <span class="keyword">is</span> (<span class="keyword">not</span>), <span class="keyword">and</span>, <span class="keyword">or</span>, <span class="keyword">not</span>, xor</span><br><span class="line">            <span class="keyword">is</span><span class="operator">/</span><span class="keyword">is</span> <span class="keyword">not</span> 加上ture<span class="operator">/</span><span class="literal">false</span><span class="operator">/</span><span class="literal">unknown</span>，检验某个值的真假</span><br><span class="line">            <span class="operator">&lt;=&gt;</span>与<span class="operator">&lt;&gt;</span>功能相同，<span class="operator">&lt;=&gt;</span>可用于<span class="keyword">null</span>比较</span><br><span class="line">d. <span class="keyword">GROUP</span> <span class="keyword">BY</span> 子句, 分组子句</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="operator">/</span>别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：<span class="keyword">ASC</span>，降序：<span class="keyword">DESC</span></span><br><span class="line">    以下[合计函数]需配合 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 使用：</span><br><span class="line">    count 返回不同的非<span class="keyword">NULL</span>值数目  <span class="built_in">count</span>(<span class="operator">*</span>)、<span class="built_in">count</span>(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非<span class="keyword">NULL</span>值的字符串结果。组内字符串连接。</span><br><span class="line">e. <span class="keyword">HAVING</span> 子句，条件子句</span><br><span class="line">    与 <span class="keyword">where</span> 功能、用法相同，执行时机不同。</span><br><span class="line">    <span class="keyword">where</span> 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    <span class="keyword">having</span> 对筛选出的结果再次进行过滤。</span><br><span class="line">    <span class="keyword">having</span> 字段必须是查询出来的，<span class="keyword">where</span> 字段必须是数据表存在的。</span><br><span class="line">    <span class="keyword">where</span> 不可以使用字段的别名，<span class="keyword">having</span> 可以。因为执行<span class="keyword">WHERE</span>代码时，可能尚未确定列值。</span><br><span class="line">    <span class="keyword">where</span> 不可以使用合计函数。一般需用合计函数才会用 <span class="keyword">having</span></span><br><span class="line">    <span class="keyword">SQL</span>标准要求<span class="keyword">HAVING</span>必须引用<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句中的列或用于合计函数中的列。</span><br><span class="line">f. <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句，排序子句</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> 排序字段<span class="operator">/</span>别名 排序方式 [,排序字段<span class="operator">/</span>别名 排序方式]...</span><br><span class="line">    升序：<span class="keyword">ASC</span>，降序：<span class="keyword">DESC</span></span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从<span class="number">0</span>开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引<span class="number">0</span>开始。limit 获取条数</span><br><span class="line">h. <span class="keyword">DISTINCT</span>, <span class="keyword">ALL</span> 选项</span><br><span class="line">    <span class="keyword">distinct</span> 去除重复记录</span><br><span class="line">    默认为 <span class="keyword">all</span>, 全部记录</span><br></pre></td></tr></table></figure>

<h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* UNION */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个<span class="keyword">select</span>查询的结果组合成一个结果集合。</span><br><span class="line">    <span class="keyword">SELECT</span> ... <span class="keyword">UNION</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">    默认 <span class="keyword">DISTINCT</span> 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个<span class="keyword">SELECT</span>查询加上小括号包裹。</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各<span class="keyword">select</span>查询的字段数量一样。</span><br><span class="line">    每个<span class="keyword">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class="keyword">select</span>语句为准。</span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 子查询 */</span> <span class="comment">------------------</span></span><br><span class="line">    <span class="operator">-</span> 子查询需用括号包裹。</span><br><span class="line"><span class="comment">-- from型</span></span><br><span class="line">    <span class="keyword">from</span>后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    <span class="operator">-</span> 简化每个查询内的条件。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">from</span>型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    <span class="operator">-</span> 子查询返回一个表，表型子查询。</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">0</span>) <span class="keyword">as</span> subfrom <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- where型</span></span><br><span class="line">    <span class="operator">-</span> 子查询返回一个值，标量子查询。</span><br><span class="line">    <span class="operator">-</span> 不需要给子查询取别名。</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">where</span>子查询内的表，不能直接用以更新。</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb <span class="keyword">where</span> money <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(money) <span class="keyword">from</span> tb);</span><br><span class="line">    <span class="comment">-- 列子查询</span></span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 <span class="keyword">in</span> 或 <span class="keyword">not</span> <span class="keyword">in</span> 完成查询</span><br><span class="line">        <span class="keyword">exists</span> 和 <span class="keyword">not</span> <span class="keyword">exists</span> 条件</span><br><span class="line">            如果子查询返回数据，则返回<span class="number">1</span>或<span class="number">0</span>。常用于判断条件。</span><br><span class="line">            <span class="keyword">select</span> column1 <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2);</span><br><span class="line">    <span class="comment">-- 行子查询</span></span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> (id, gender) <span class="keyword">in</span> (<span class="keyword">select</span> id, gender <span class="keyword">from</span> t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 <span class="type">ROW</span>(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    <span class="comment">-- 特殊运算符</span></span><br><span class="line">    <span class="operator">!=</span> <span class="keyword">all</span>()    相当于 <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">some</span>()    相当于 <span class="keyword">in</span>。<span class="keyword">any</span> 是 <span class="keyword">some</span> 的别名</span><br><span class="line">    <span class="operator">!=</span> <span class="keyword">some</span>()   不等同于 <span class="keyword">not</span> <span class="keyword">in</span>，不等于其中某一个。</span><br><span class="line">    <span class="keyword">all</span>, <span class="keyword">some</span> 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure>

<h1 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 连接查询(join) */</span> <span class="comment">------------------</span></span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line"><span class="comment">-- 内连接(inner join)</span></span><br><span class="line">    <span class="operator">-</span> 默认就是内连接，可省略<span class="keyword">inner</span>。</span><br><span class="line">    <span class="operator">-</span> 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    <span class="keyword">on</span> 表示连接条件。其条件表达式与<span class="keyword">where</span>类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用<span class="keyword">where</span>表示连接条件。</span><br><span class="line">    还有 <span class="keyword">using</span>, 但需字段名相同。 <span class="keyword">using</span>(字段名)</span><br><span class="line">    <span class="comment">-- 交叉连接 cross join</span></span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb1 <span class="keyword">cross</span> <span class="keyword">join</span> tb2;</span><br><span class="line"><span class="comment">-- 外连接(outer join)</span></span><br><span class="line">    <span class="operator">-</span> 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    <span class="comment">-- 左外连接 left join</span></span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为<span class="keyword">null</span>填充</span><br><span class="line">    <span class="comment">-- 右外连接 right join</span></span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为<span class="keyword">null</span>填充</span><br><span class="line"><span class="comment">-- 自然连接(natural join)</span></span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了<span class="keyword">using</span>，会自动查找相同字段名。</span><br><span class="line">    <span class="keyword">natural</span> <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class="keyword">from</span> info, extra_info <span class="keyword">where</span> info.stu_num <span class="operator">=</span> extra_info.stu_id;</span><br></pre></td></tr></table></figure>

<h1 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* TRUNCATE */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line"><span class="number">1</span>，<span class="keyword">truncate</span> 是删除表再创建，<span class="keyword">delete</span> 是逐条删除</span><br><span class="line"><span class="number">2</span>，<span class="keyword">truncate</span> 重置auto_increment的值。而<span class="keyword">delete</span>不会</span><br><span class="line"><span class="number">3</span>，<span class="keyword">truncate</span> 不知道删除了几条，而<span class="keyword">delete</span>知道。</span><br><span class="line"><span class="number">4</span>，当被用于带分区的表时，<span class="keyword">truncate</span> 会保留分区</span><br></pre></td></tr></table></figure>

<h1 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h1><p>/* 备份与还原 */ ——————<br>备份，将数据的结构与表内数据保存起来。<br>利用 mysqldump 指令完成。<br>– 导出<br>mysqldump [options] db_name [tables]<br>mysqldump [options] —database DB1 [DB2 DB3…]<br>mysqldump [options] –all–database</p>
<ol>
<li>导出一张表<br>　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</li>
<li>导出多张表<br>　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</li>
<li>导出所有表<br>　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</li>
<li>导出一个库<br>　　mysqldump -u用户名 -p密码 –lock-all-tables –database 库名 &gt; 文件名(D:/a.sql)<br>可以-w携带WHERE条件</li>
</ol>
<p>– 导入</p>
<ol>
<li>在登录mysql的情况下：<br>　　source  备份文件</li>
<li>在不登录的情况下<br>　　mysql -u用户名 -p密码 库名 &lt; 备份文件</li>
</ol>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>什么是视图：<br>    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<br>    视图具有表结构文件，但不存在数据文件。<br>    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。<br>    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;] <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line">    <span class="operator">-</span> 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    <span class="operator">-</span> 视图可以使用<span class="keyword">select</span>语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    <span class="operator">-</span> 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    <span class="operator">-</span> column_list如果存在，则数目必须等于<span class="keyword">SELECT</span>语句检索的列数</span><br><span class="line"><span class="comment">-- 查看结构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line">    <span class="operator">-</span> 删除视图后，数据依然存在。</span><br><span class="line">    <span class="operator">-</span> 可同时删除多个视图。</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name ...</span><br><span class="line"><span class="comment">-- 修改视图结构</span></span><br><span class="line">    <span class="operator">-</span> 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line"><span class="comment">-- 视图作用</span></span><br><span class="line">    <span class="number">1.</span> 简化业务逻辑</span><br><span class="line">    <span class="number">2.</span> 对客户端隐藏真实的表结构</span><br><span class="line"><span class="comment">-- 视图算法(ALGORITHM)</span></span><br><span class="line">    <span class="keyword">MERGE</span>       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure>

<h1 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h1><p>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。<br>    - 支持连续SQL的集体成功或集体撤销。<br>    - 事务是数据库在数据完整性方面的一个功能。<br>    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。<br>    - InnoDB被称为事务安全型引擎。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务开启</span></span><br><span class="line">    <span class="keyword">START</span> TRANSACTION; 或者 <span class="keyword">BEGIN</span>;</span><br><span class="line">    开启事务后，所有被执行的<span class="keyword">SQL</span>语句均被认作当前事务内的<span class="keyword">SQL</span>语句。</span><br><span class="line"><span class="comment">-- 事务提交</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line"><span class="comment">-- 事务的特性</span></span><br><span class="line">    <span class="number">1.</span> 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    <span class="number">2.</span> 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        <span class="operator">-</span> 事务开始和结束时，外部数据一致</span><br><span class="line">        <span class="operator">-</span> 在整个事务过程中，操作是连续的</span><br><span class="line">    <span class="number">3.</span> 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    <span class="number">4.</span> 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line"><span class="comment">-- 事务的实现</span></span><br><span class="line">    <span class="number">1.</span> 要求是事务支持的表类型</span><br><span class="line">    <span class="number">2.</span> 执行一组相关的操作前开启事务</span><br><span class="line">    <span class="number">3.</span> 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line"><span class="comment">-- 事务的原理</span></span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要<span class="keyword">commit</span>提交持久化数据操作。</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    <span class="number">2.</span> 事务不能被嵌套</span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line">    <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 回滚到保存点</span></span><br><span class="line">    <span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 删除保存点</span></span><br><span class="line"><span class="comment">-- InnoDB自动提交特性设置</span></span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span><span class="operator">|</span><span class="number">1</span>;   <span class="number">0</span>表示关闭自动提交，<span class="number">1</span>表示开启自动提交。</span><br><span class="line">    <span class="operator">-</span> 如果关闭了，那普通操作的结果对其他客户端也不可见，需要<span class="keyword">commit</span>提交后才能持久化数据操作。</span><br><span class="line">    <span class="operator">-</span> 也可以关闭自动提交来开启事务。但与<span class="keyword">START</span> TRANSACTION不同的是，</span><br><span class="line">        <span class="keyword">SET</span> autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而<span class="keyword">START</span> TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure>

<h1 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h1><p>/* 锁表 */<br>表锁定只用于防止其它客户端进行不正当地读取和写入<br>MyISAM 支持表锁，InnoDB 支持行锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 锁定</span></span><br><span class="line">    LOCK TABLES tbl_name [<span class="keyword">AS</span> alias]</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>/* 触发器 */ ——————<br>    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象<br>    监听：记录的增加、修改、删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event <span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        <span class="keyword">INSERT</span>：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        <span class="keyword">DELETE</span>：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name</span><br><span class="line">可以使用<span class="keyword">old</span>和<span class="keyword">new</span>代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是<span class="keyword">old</span>，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line"><span class="comment">-- 字符连接函数</span></span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line"><span class="comment">-- 分支语句</span></span><br><span class="line">if 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="comment">-- 修改最外层语句结束符</span></span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    <span class="keyword">SQL</span>语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     <span class="comment">-- 修改回原来的分号</span></span><br><span class="line"><span class="comment">-- 语句块包裹</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    语句块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 特殊的执行</span></span><br><span class="line"><span class="number">1.</span> 只要添加记录，就会触发程序。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">Insert</span> <span class="keyword">into</span> <span class="keyword">on</span> duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before <span class="keyword">insert</span>, after <span class="keyword">insert</span>;</span><br><span class="line">    如果有重复记录并更新，会触发 before <span class="keyword">insert</span>, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before <span class="keyword">insert</span>, before update</span><br><span class="line"><span class="number">3.</span> Replace 语法 如果有记录，则执行 before <span class="keyword">insert</span>, before <span class="keyword">delete</span>, after <span class="keyword">delete</span>, after <span class="keyword">insert</span></span><br></pre></td></tr></table></figure>

<h1 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SQL编程 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">--// 局部变量 ----------</span></span><br><span class="line"><span class="comment">-- 变量声明</span></span><br><span class="line">    <span class="keyword">declare</span> var_name[,...] type [<span class="keyword">default</span> <span class="keyword">value</span>]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个<span class="keyword">default</span>子句。值可以被指定为一个表达式，不需要为一个常数。如果没有<span class="keyword">default</span>子句，初始值为<span class="keyword">null</span>。</span><br><span class="line"><span class="comment">-- 赋值</span></span><br><span class="line">    使用 <span class="keyword">set</span> 和 <span class="keyword">select</span> <span class="keyword">into</span> 语句为变量赋值。</span><br><span class="line">    <span class="operator">-</span> 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line"><span class="comment">--// 全局变量 ----------</span></span><br><span class="line"><span class="comment">-- 定义、赋值</span></span><br><span class="line"><span class="keyword">set</span> 语句可以定义并为变量赋值。</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var</span> <span class="operator">=</span> <span class="keyword">value</span>;</span><br><span class="line">也可以使用<span class="keyword">select</span> <span class="keyword">into</span>语句为变量初始化并赋值。这样要求<span class="keyword">select</span>语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过<span class="keyword">select</span>执行完成。此时为了避免<span class="operator">=</span>被当作关系运算符看待，使用:<span class="operator">=</span>代替。（<span class="keyword">set</span>语句可以使用<span class="operator">=</span> 和 :<span class="operator">=</span>）。</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>:<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@v1</span>:<span class="operator">=</span>id, <span class="variable">@v2</span><span class="operator">=</span>name <span class="keyword">from</span> t1 limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbl_name <span class="keyword">where</span> <span class="variable">@var</span>:<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">into</span> 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    <span class="operator">-</span><span class="operator">|</span> <span class="keyword">select</span> <span class="built_in">max</span>(height) <span class="keyword">into</span> <span class="variable">@max</span>_height <span class="keyword">from</span> tb;</span><br><span class="line"><span class="comment">-- 自定义变量名</span></span><br><span class="line">为了避免<span class="keyword">select</span>语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line"><span class="variable">@var</span><span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    <span class="operator">-</span> 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line"><span class="comment">--// 控制结构 ----------</span></span><br><span class="line"><span class="comment">-- if语句</span></span><br><span class="line">if search_condition <span class="keyword">then</span></span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition <span class="keyword">then</span></span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">    statement_list]</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="comment">-- case语句</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">value</span> <span class="keyword">WHEN</span> [compare<span class="operator">-</span><span class="keyword">value</span>] <span class="keyword">THEN</span> <span class="keyword">result</span></span><br><span class="line">[<span class="keyword">WHEN</span> [compare<span class="operator">-</span><span class="keyword">value</span>] <span class="keyword">THEN</span> <span class="keyword">result</span> ...]</span><br><span class="line">[<span class="keyword">ELSE</span> <span class="keyword">result</span>]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- while循环</span></span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">end</span> while [end_label];</span><br><span class="line"><span class="operator">-</span> 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    <span class="comment">-- 退出循环</span></span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line"><span class="comment">--// 内置函数 ----------</span></span><br><span class="line"><span class="comment">-- 数值函数</span></span><br><span class="line"><span class="built_in">abs</span>(x)          <span class="comment">-- 绝对值 abs(-10.9) = 10</span></span><br><span class="line">format(x, d)    <span class="comment">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span></span><br><span class="line"><span class="built_in">ceil</span>(x)         <span class="comment">-- 向上取整 ceil(10.1) = 11</span></span><br><span class="line"><span class="built_in">floor</span>(x)        <span class="comment">-- 向下取整 floor (10.1) = 10</span></span><br><span class="line">round(x)        <span class="comment">-- 四舍五入去整</span></span><br><span class="line"><span class="built_in">mod</span>(m, n)       <span class="comment">-- m%n m mod n 求余 10%3=1</span></span><br><span class="line">pi()            <span class="comment">-- 获得圆周率</span></span><br><span class="line">pow(m, n)       <span class="comment">-- m^n</span></span><br><span class="line"><span class="built_in">sqrt</span>(x)         <span class="comment">-- 算术平方根</span></span><br><span class="line">rand()          <span class="comment">-- 随机数</span></span><br><span class="line"><span class="keyword">truncate</span>(x, d)  <span class="comment">-- 截取d位小数</span></span><br><span class="line"><span class="comment">-- 时间日期函数</span></span><br><span class="line">now(), <span class="built_in">current_timestamp</span>();     <span class="comment">-- 当前日期时间</span></span><br><span class="line"><span class="built_in">current_date</span>();                 <span class="comment">-- 当前日期</span></span><br><span class="line"><span class="built_in">current_time</span>();                 <span class="comment">-- 当前时间</span></span><br><span class="line"><span class="type">date</span>(<span class="string">&#x27;yyyy-mm-dd hh:ii:ss&#x27;</span>);    <span class="comment">-- 获取日期部分</span></span><br><span class="line"><span class="type">time</span>(<span class="string">&#x27;yyyy-mm-dd hh:ii:ss&#x27;</span>);    <span class="comment">-- 获取时间部分</span></span><br><span class="line">date_format(<span class="string">&#x27;yyyy-mm-dd hh:ii:ss&#x27;</span>, <span class="string">&#x27;%d %y %a %d %m %b %j&#x27;</span>); <span class="comment">-- 格式化时间</span></span><br><span class="line">unix_timestamp();               <span class="comment">-- 获得unix时间戳</span></span><br><span class="line">from_unixtime();                <span class="comment">-- 从时间戳获得时间</span></span><br><span class="line"><span class="comment">-- 字符串函数</span></span><br><span class="line">length(string)          <span class="comment">-- string长度，字节</span></span><br><span class="line"><span class="keyword">char_length</span>(string)     <span class="comment">-- string的字符个数</span></span><br><span class="line"><span class="built_in">substring</span>(str, position [,length])      <span class="comment">-- 从str的position开始,取length个字符</span></span><br><span class="line">replace(str ,search_str ,replace_str)   <span class="comment">-- 在str中用replace_str替换search_str</span></span><br><span class="line">instr(string ,substring)    <span class="comment">-- 返回substring首次在string中出现的位置</span></span><br><span class="line">concat(string [,...])   <span class="comment">-- 连接字串</span></span><br><span class="line">charset(str)            <span class="comment">-- 返回字串字符集</span></span><br><span class="line">lcase(string)           <span class="comment">-- 转换成小写</span></span><br><span class="line"><span class="keyword">left</span>(string, length)    <span class="comment">-- 从string2中的左边起取length个字符</span></span><br><span class="line">load_file(file_name)    <span class="comment">-- 从文件读取内容</span></span><br><span class="line">locate(substring, string [,start_position]) <span class="comment">-- 同instr,但可指定开始位置</span></span><br><span class="line">lpad(string, length, pad)   <span class="comment">-- 重复用pad加在string开头,直到字串长度为length</span></span><br><span class="line">ltrim(string)           <span class="comment">-- 去除前端空格</span></span><br><span class="line">repeat(string, count)   <span class="comment">-- 重复count次</span></span><br><span class="line">rpad(string, length, pad)   <span class="comment">--在str后用pad补充,直到长度为length</span></span><br><span class="line">rtrim(string)           <span class="comment">-- 去除后端空格</span></span><br><span class="line">strcmp(string1 ,string2)    <span class="comment">-- 逐字符比较两字串大小</span></span><br><span class="line"><span class="comment">-- 流程函数</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> [<span class="keyword">condition</span>] <span class="keyword">then</span> <span class="keyword">result</span> [<span class="keyword">when</span> [<span class="keyword">condition</span>] <span class="keyword">then</span> <span class="keyword">result</span> ...] [<span class="keyword">else</span> <span class="keyword">result</span>] <span class="keyword">end</span>   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="built_in">count</span>()</span><br><span class="line"><span class="built_in">sum</span>();</span><br><span class="line"><span class="built_in">max</span>();</span><br><span class="line"><span class="built_in">min</span>();</span><br><span class="line"><span class="built_in">avg</span>();</span><br><span class="line">group_concat()</span><br><span class="line"><span class="comment">-- 其他常用函数</span></span><br><span class="line">md5();</span><br><span class="line"><span class="keyword">default</span>();</span><br><span class="line"><span class="comment">--// 存储函数，自定义函数 ----------</span></span><br><span class="line"><span class="comment">-- 新建</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name (参数列表) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    <span class="operator">-</span> 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    <span class="operator">-</span> 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    <span class="operator">-</span> 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    <span class="operator">-</span> 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    <span class="operator">-</span> 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    <span class="operator">-</span> 一定要有 <span class="keyword">return</span> 返回值语句。</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [IF <span class="keyword">EXISTS</span>] function_name;</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;partten&#x27;</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name;</span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> function_name 函数选项</span><br><span class="line"><span class="comment">--// 存储过程，自定义功能 ----------</span></span><br><span class="line"><span class="comment">-- 定义</span></span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的<span class="keyword">sql</span>组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过<span class="keyword">call</span>执行。</span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line"><span class="keyword">IN</span>，表示输入型</span><br><span class="line"><span class="keyword">OUT</span>，表示输出型</span><br><span class="line"><span class="keyword">INOUT</span>，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 存储过程 */</span> <span class="comment">------------------</span></span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：<span class="keyword">CALL</span> 过程名</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line"><span class="operator">-</span> 没有返回值。</span><br><span class="line"><span class="operator">-</span> 只能单独调用，不可夹杂在其他语句中</span><br><span class="line"><span class="comment">-- 参数</span></span><br><span class="line"><span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 数据类型</span><br><span class="line"><span class="keyword">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line"><span class="keyword">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line"><span class="keyword">INOUT</span>   输入输出：既可输入，也可输出</span><br><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 过程名 (参数列表)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h1 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用户和权限管理 */</span> <span class="comment">------------------</span></span><br><span class="line"><span class="comment">-- root密码重置</span></span><br><span class="line"><span class="number">1.</span> 停止MySQL服务</span><br><span class="line"><span class="number">2.</span>  [Linux] <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>bin<span class="operator">/</span>safe_mysqld <span class="comment">--skip-grant-tables &amp;</span></span><br><span class="line">    [Windows] mysqld <span class="comment">--skip-grant-tables</span></span><br><span class="line"><span class="number">3.</span> use mysql;</span><br><span class="line"><span class="number">4.</span> UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> PASSWORD<span class="operator">=</span>PASSWORD(&quot;密码&quot;) <span class="keyword">WHERE</span> `<span class="keyword">user</span>` <span class="operator">=</span> &quot;root&quot;;</span><br><span class="line"><span class="number">5.</span> FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="comment">-- 增加用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 IDENTIFIED <span class="keyword">BY</span> [PASSWORD] 密码(字符串)</span><br><span class="line">    <span class="operator">-</span> 必须拥有mysql数据库的全局<span class="keyword">CREATE</span> <span class="keyword">USER</span>权限，或拥有<span class="keyword">INSERT</span>权限。</span><br><span class="line">    <span class="operator">-</span> 只能创建用户，不能赋予权限。</span><br><span class="line">    <span class="operator">-</span> 用户名，注意引号：如 <span class="string">&#x27;user_name&#x27;</span>@<span class="string">&#x27;192.168.1.1&#x27;</span></span><br><span class="line">    <span class="operator">-</span> 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    <span class="operator">-</span> 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line"><span class="comment">-- 重命名用户</span></span><br><span class="line">RENAME <span class="keyword">USER</span> old_user <span class="keyword">TO</span> new_user</span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;密码&#x27;</span>)  <span class="comment">-- 为当前用户设置密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> 用户名 <span class="operator">=</span> PASSWORD(<span class="string">&#x27;密码&#x27;</span>) <span class="comment">-- 为指定用户设置密码</span></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户名</span><br><span class="line"><span class="comment">-- 分配权限/添加用户</span></span><br><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户名 [IDENTIFIED <span class="keyword">BY</span> [PASSWORD] <span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">all</span> privileges 表示所有权限</span><br><span class="line">    <span class="operator">-</span> <span class="operator">*</span>.<span class="operator">*</span> 表示所有库的所有表</span><br><span class="line">    <span class="operator">-</span> 库名.表名 表示某库下面的某表</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> `pms`.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;pms&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;pms0817&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> 用户名</span><br><span class="line">    <span class="comment">-- 查看当前用户权限</span></span><br><span class="line">    <span class="keyword">SHOW</span> GRANTS; 或 <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>; 或 <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"><span class="comment">-- 撤消权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">FROM</span> 用户名</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES, <span class="keyword">GRANT</span> OPTION <span class="keyword">FROM</span> 用户名   <span class="comment">-- 撤销所有权限</span></span><br><span class="line"><span class="comment">-- 权限层级</span></span><br><span class="line"><span class="comment">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span></span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span>和 <span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span>只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.<span class="operator">*</span>和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.<span class="operator">*</span>只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用<span class="keyword">REVOKE</span>时，您必须指定与被授权列相同的列。</span><br><span class="line"><span class="comment">-- 权限列表</span></span><br><span class="line"><span class="keyword">ALL</span> [PRIVILEGES]    <span class="comment">-- 设置除GRANT OPTION之外的所有简单权限</span></span><br><span class="line"><span class="keyword">ALTER</span>   <span class="comment">-- 允许使用ALTER TABLE</span></span><br><span class="line"><span class="keyword">ALTER</span> ROUTINE   <span class="comment">-- 更改或取消已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span>  <span class="comment">-- 允许使用CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> ROUTINE  <span class="comment">-- 创建已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY TABLES     <span class="comment">-- 允许使用CREATE TEMPORARY TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>     <span class="comment">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>     <span class="comment">-- 允许使用CREATE VIEW</span></span><br><span class="line"><span class="keyword">DELETE</span>  <span class="comment">-- 允许使用DELETE</span></span><br><span class="line"><span class="keyword">DROP</span>    <span class="comment">-- 允许使用DROP TABLE</span></span><br><span class="line"><span class="keyword">EXECUTE</span>     <span class="comment">-- 允许用户运行已存储的子程序</span></span><br><span class="line">FILE    <span class="comment">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span></span><br><span class="line">INDEX   <span class="comment">-- 允许使用CREATE INDEX和DROP INDEX</span></span><br><span class="line"><span class="keyword">INSERT</span>  <span class="comment">-- 允许使用INSERT</span></span><br><span class="line">LOCK TABLES     <span class="comment">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></span><br><span class="line">PROCESS     <span class="comment">-- 允许使用SHOW FULL PROCESSLIST</span></span><br><span class="line"><span class="keyword">REFERENCES</span>  <span class="comment">-- 未被实施</span></span><br><span class="line">RELOAD  <span class="comment">-- 允许使用FLUSH</span></span><br><span class="line">REPLICATION CLIENT  <span class="comment">-- 允许用户询问从属服务器或主服务器的地址</span></span><br><span class="line">REPLICATION SLAVE   <span class="comment">-- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="comment">-- 允许使用SELECT</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES  <span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VIEW</span>   <span class="comment">-- 允许使用SHOW CREATE VIEW</span></span><br><span class="line">SHUTDOWN    <span class="comment">-- 允许使用mysqladmin shutdown</span></span><br><span class="line">SUPER   <span class="comment">-- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span></span><br><span class="line">UPDATE  <span class="comment">-- 允许使用UPDATE</span></span><br><span class="line">USAGE   <span class="comment">-- “无权限”的同义词</span></span><br><span class="line"><span class="keyword">GRANT</span> OPTION    <span class="comment">-- 允许授予权限</span></span><br></pre></td></tr></table></figure>

<h1 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 表维护 */</span></span><br><span class="line"><span class="comment">-- 分析和存储表的关键字分布</span></span><br><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> 表名 ...</span><br><span class="line"><span class="comment">-- 检查一个或多个表是否有错误</span></span><br><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span> CHANGED&#125;</span><br><span class="line"><span class="comment">-- 整理数据文件的碎片</span></span><br><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>


<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>/* 杂项 */ ——————</p>
<ol>
<li>可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</li>
<li>每个库目录存在一个保存当前数据库的选项文件db.opt。</li>
<li>注释：<br> 单行注释 # 注释内容<br> 多行注释 /* 注释内容 */<br> 单行注释 – 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</li>
<li>模式通配符：<br> _   任意单个字符<br> %   任意多个字符，甚至包括零字符<br> 单引号需要进行转义 &#39;</li>
<li>CMD命令行内的语句结束符可以为 “;”, “\G”, “\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</li>
<li>SQL对大小写不敏感</li>
<li>清除已有语句：\c</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>解决maven库中无法引入Oracle_jdbc_driver</title>
    <url>/2019/11/04/tech/OracleJDBC/</url>
    <content><![CDATA[<p>1.在maven库中直接引入oracle jdbc driver是不能下载到本地的，原因是oracle的jdbc工具包不是开放给公众下载的，需要用户是oracle的注册用户才能在oracle官网下载到。</p>
<p>2.解决方式：目前没有发现更简便的方法，只能从oracle官网上下载jdbc driver的包，然后从本地upload到本地仓库。</p>
<ul>
<li><p>进入JDBC<a href="https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html">下载网站</a>，选择自己需要的JDBC driver版本，点击进入。<br><img src="/2019/11/04/tech/OracleJDBC/1.png"></p>
</li>
<li><p>下载需要的JDBC driver的jar包</p>
</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/2.png"></p>
<ul>
<li><p>如果还没有登陆oracle账号，需要你登陆以后才能下载，没有注册过的注册一个账号，这里不再赘述。</p>
</li>
<li><p>下载完成后，进入下载完成的文件夹。在这里需要手动执行命令，在该文件夹打开git窗口，如何在windows安装git请自行百度。执行如下命令。</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn deploy:deploy-file -Dmaven.test.skip=<span class="literal">true</span> -Dfile=ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.0.0.7 -Dpackaging=jar -DrepositoryId=localmaven -Durl=http://localhost/nexus/content/repositories/releases</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<p>-Dmaven.test.skip ：是否跳过jar包检测。这种官方的包，我们不需要对其进行测试，设置为true即可。</p>
<p>-Dfile：需要上传的jar包名。建议直接在jar包所在目录执行上述命令，可以避免再输入jar包的地址。</p>
<p>-DgroupId，-DartifactId，-Dversion：jar包在本地maven库中的地址。理论上这三个值都是自己定义的，只要自己能够区分出来即可。建议地址不要和官方的maven地址完全一致，改一个版本号，或者artifactId都行，这样可以避免自动从官方maven库下载jar包，导致还是不能引入。</p>
<p>-Dpackaging：打包方式。一般选择下载的是jar包，这里也写jar就行。</p>
<p>-DrepositoryId：部署的仓库ID。这个ID配置在maven的setings.xml中，参考如下：</p>
</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/3.png"></p>
<p>  自行写入本地仓库的用户名和密码。</p>
<p>  -Durl：部署的本地仓库的地址。</p>
<ul>
<li>执行完成后，显示如下页面，就表示上传成功。</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/4.png"></p>
<ul>
<li><p>在项目的pom.xml文件下需要做如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加本地仓库地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>java.net2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入oracle包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--oracle--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据爬虫实践-爬取历年东西部周最佳对比</title>
    <url>/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>历年周最佳的数据来自于NBA数据官网，链接为 <a href="http://www.stat-nba.com/award/item18.html">http://www.stat-nba.com/award/item18.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/1.png"></p>
<p>这里可以看到每个赛季的周最佳球员。然后每个球员旁边有个数据的链接，表示的就是这名球员当周的平均数据。比如11月11日-11月17日的东部周最佳是武切维奇，其数据链接为<a href="http://www.stat-nba.com/player/3672.html">http://www.stat-nba.com/player/3672.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/2.png"></p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="爬取周最佳球员"><a href="#爬取周最佳球员" class="headerlink" title="爬取周最佳球员"></a>爬取周最佳球员</h3><p>首先看周最佳的页面，链接是<a href="http://www.stat-nba.com/award/item18.html%EF%BC%8C%E9%80%89%E4%B8%AD%E6%AD%A6%E5%88%87%E7%BB%B4%E5%A5%87%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%EF%BC%8C%E9%80%89%E6%8B%A9%E2%80%9C%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E2%80%9D%E3%80%82%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A">http://www.stat-nba.com/award/item18.html，选中武切维奇的名字，右键打开右键菜单，选择“查看页面元素”。出现如下页面：</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/3.png"></p>
<p>注意，我们需要获取到的是<strong>所有的周最佳数据</strong>，而不是某个人的，因此我们需要找到这个页面元素的父元素，因此才能找到这个父元素下面的所有子元素-即所有的周最佳数据。</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/4.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如图所示，周最佳数据的节点来自于&lt;td class=&#x27;current&#x27;&gt; -&gt; &lt;table class=&#x27;stat-box&#x27;  style=&#x27;width:170px;border:0&#x27;&gt;  -&gt; &lt;td&gt;</span><br><span class="line"></span><br><span class="line">根据网页上下文的查看，可以知道&quot;&lt;td class=&quot;current&quot;&gt;是赛季的节点，&lt;table class=&quot;stat-box&quot; style=&quot;width:170px;border:0&quot;&gt;是每个赛季下每周的节点，而&lt;td&gt;就是每周下面每个球员的节点。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>因此我们根据节点的继承关系，可以写出如下的基本的爬虫逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取周最佳页面</span></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.stat-nba.com/award/item18.html&quot;</span>).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 格式化为lxml</span></span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="comment"># 查找&lt;td class=&quot;current&quot;&gt; 获取各个赛季</span></span><br><span class="line">outResult = soup.find_all(<span class="string">&quot;td&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;current&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outResult)):</span><br><span class="line">    single = outResult[i]</span><br><span class="line">    <span class="comment"># 获取每赛季数据 </span></span><br><span class="line">    data = single.parent.find_all(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;width:170px;border:0&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        singleData = data[j]</span><br><span class="line">        <span class="comment"># 获取周</span></span><br><span class="line">        week = singleData.find(<span class="string">&quot;th&quot;</span>)</span><br><span class="line">        tdList = singleData.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tdList)):</span><br><span class="line">            singleTd = tdList[k]</span><br><span class="line">            <span class="built_in">print</span>(week.text, singleTd.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/5.png"></p>
<h3 id="爬取周最佳数据"><a href="#爬取周最佳数据" class="headerlink" title="爬取周最佳数据"></a>爬取周最佳数据</h3><p>接下来我们爬取每个球员的周最佳数据，点击球员旁边的“数据”按钮，会跳转到周数据页面。</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/6.png"></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/7.png"></p>
<p>根据看到数据页面是在球员td标签下的第二个a标签下</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/8.png"></p>
<p>根据a标签的结构使用如下代码来获取球员数据的链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tdData = singleTd.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tdData) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 爬取最佳周数据</span></span><br><span class="line">    playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>获取到链接之后，按照前文所述来爬取球员的详细数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取最佳周数据</span></span><br><span class="line">playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">playerHtml = urlopen(playerUrl).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">playerSoup = BeautifulSoup(playerHtml, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">playerTable = playerSoup.find(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">    playerStatList = playerTable.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(playerStatList)):</span><br><span class="line">            playerStat = playerStatList[m]</span><br><span class="line">            <span class="comment"># 打印数据</span></span><br><span class="line">            <span class="built_in">print</span>(playerStat.text)</span><br></pre></td></tr></table></figure>

<h3 id="输出数据到Excel"><a href="#输出数据到Excel" class="headerlink" title="输出数据到Excel"></a>输出数据到Excel</h3><p>将前文进行整合，并将数据输出到Excel，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwt <span class="keyword">as</span> xlwt</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单元格格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_style</span>(<span class="params">name=<span class="string">&#x27;Times New Roman&#x27;</span>, height=<span class="number">220</span>, bold=<span class="literal">False</span></span>):</span></span><br><span class="line">    style = xlwt.XFStyle()</span><br><span class="line">    font = xlwt.Font()</span><br><span class="line">    font.name = name</span><br><span class="line">    font.bold = bold</span><br><span class="line">    font.color_index = <span class="number">4</span></span><br><span class="line">    font.height = height</span><br><span class="line">    style.font = font</span><br><span class="line">    <span class="keyword">return</span> style</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.stat-nba.com/award/item18.html&quot;</span>).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">outResult = soup.find_all(<span class="string">&quot;td&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;current&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 创建excel</span></span><br><span class="line">f = xlwt.Workbook()</span><br><span class="line">sheet1 = f.add_sheet(<span class="string">&#x27;周最佳数据&#x27;</span>, cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">style = set_style()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outResult)):</span><br><span class="line">    single = outResult[i]</span><br><span class="line">    <span class="comment"># 2000年以前数据不再显示</span></span><br><span class="line">    <span class="keyword">if</span> single.text.startswith(<span class="string">&quot;19&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 获取每赛季数据</span></span><br><span class="line">    data = single.parent.find_all(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;width:170px;border:0&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        singleData = data[j]</span><br><span class="line">        <span class="comment"># 打印周</span></span><br><span class="line">        week = singleData.find(<span class="string">&quot;th&quot;</span>)</span><br><span class="line">        tdList = singleData.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tdList)):</span><br><span class="line">            singleTd = tdList[k]</span><br><span class="line">            <span class="comment"># 暂停随机时间，以避免被反爬虫</span></span><br><span class="line">            sleeptime = random.randint(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">            time.sleep(sleeptime / <span class="number">1000</span>)</span><br><span class="line">            tdData = singleTd.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="comment"># 获取球员名</span></span><br><span class="line">            playerName = tdData[<span class="number">0</span>].text</span><br><span class="line">            <span class="built_in">print</span>(single.text, week.text, playerName)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tdData) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 爬取最佳周数据</span></span><br><span class="line">                playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                playerHtml = urlopen(playerUrl).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                playerSoup = BeautifulSoup(playerHtml, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">                playerTable = playerSoup.find(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>&#125;)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">                    playerStatList = playerTable.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">                sheet1.write(num, <span class="number">0</span>, single.text, style)</span><br><span class="line">                sheet1.write(num, <span class="number">1</span>, week.text, style)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(playerStatList)):</span><br><span class="line">                        playerStat = playerStatList[m]</span><br><span class="line">                        <span class="comment"># 打印赛季</span></span><br><span class="line">                        sheet1.write(num, <span class="number">1</span> + m, playerStat.text, style)</span><br><span class="line">                num = num + <span class="number">1</span></span><br><span class="line">f.save(<span class="string">&#x27;nbastat-week.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>输出的结果如下：</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/9.png"></p>
<h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>分析过程我就懒得再写一遍了，之前已经将分析结果发布到虎扑，链接是<a href="https://bbs.hupu.com/30738461.html">https://bbs.hupu.com/30738461.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/10.png"></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/11.png"></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>azkaban简单搭建</title>
    <url>/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>前言：<br>azkaban的用处和好处不再赘述，这里只讲怎么将azkaban在项目中使用起来。<br>另外非常推荐直接看<a href="https://azkaban.readthedocs.io/en/latest/">官方的英文文档</a>进行学习，那将是最新最可靠的教程。</p>
<h2 id="下载和安装azkaban"><a href="#下载和安装azkaban" class="headerlink" title="下载和安装azkaban"></a>下载和安装azkaban</h2><h3 id="下载azkaban"><a href="#下载azkaban" class="headerlink" title="下载azkaban"></a>下载azkaban</h3><p>方法1：直接到azkaban的github网页下载tar.gz包。截止2020.4.29日最新版本的包地址为(<a href="https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz">https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz</a>)<br>方法2：在linux执行   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="安装azkaban"><a href="#安装azkaban" class="headerlink" title="安装azkaban"></a>安装azkaban</h3><p>将包进行解压，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf azkaban-3.81.10.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压完成后目录结构如下图  </p>
<span id="more"></span>
<p><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/1.png"><br>如果使用solo-server方式的话，不需要建表，下面的步骤也都可以不用看，直接跳转看<a href="https://azkaban.readthedocs.io/en/latest/getStarted.html#getting-started-with-the-solo-server">solo-server</a><br>但是个人理解solo-server只适用于小型简单的项目，如果考虑项目以后的扩充和发展的话，建议一开始就使用multi-executor-server方式，该方式需要建表。<br>步骤如下：</p>
<h3 id="新增azkaban相关表"><a href="#新增azkaban相关表" class="headerlink" title="新增azkaban相关表"></a>新增azkaban相关表</h3><p>复制如下文件内的sql语句，在事先建好的数据库内执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi azkaban-3.81.10/azkaban-db/build/sql/create-all-sql-0.1.0-SNAPSHOT.sql</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可能有的坑：<br>早期版本的mysql可能不支持长度过长的字段设为索引和主键，遇到这种报错时，需要将对应的字段改短再执行。过长的字段比如 execution_logs.name，sql给设置的长度是varchar(640)，在我的mysql数据库中执行会报错，我改成了varchar(200)，这个字段的含义是任务名，一般来说你正常命名的话完全用不到640个字段的长度，所以可以放心修改。  </p>
<h3 id="编译azkaban"><a href="#编译azkaban" class="headerlink" title="编译azkaban"></a>编译azkaban</h3><p>在azkaban目录下执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew build installDist</span><br></pre></td></tr></table></figure>
<p>可能有的坑:</p>
</li>
<li><p>部分依赖包可能无法下载，修改build.gradle，将repositories指向国内阿里云地址，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/repository/google&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/repository/jcenter&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &#x27;com.cinnober.gradle:semver-git:2.2.3&#x27;</span><br><span class="line">    classpath &#x27;net.ltgt.gradle:gradle-errorprone-plugin:0.0.14&#x27;</span><br><span class="line">    classpath  &#x27;com.github.jengelman.gradle.plugins:shadow:4.0.0&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果出现编译报错的情况，可以尝试将编译期间的test过程注释掉，或者进入azkaban-executor-server和azkban-web-server目录下单独编译这两个包。  </p>
</li>
</ul>
<h3 id="启动azkban-executor-server"><a href="#启动azkban-executor-server" class="headerlink" title="启动azkban-executor-server"></a>启动azkban-executor-server</h3><ul>
<li><p>修改配置文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ../azkaban-3.81.0/azkaban-exec-server/build/install/azkaban-exec-server/conf/azkaban.properties</span><br></pre></td></tr></table></figure>
<p>需要修改的内容如下  </p>
<blockquote>
<p>default.timezone.id=Asia/Shanghai # 修改为中国时区<br>azkaban.webserver.url=localhost:8199 # 指向本地的azkaban-web-server地址<br>#数据库配置，指向azkban建表的数据库，根据实际的数据库配置来<br>database.type=mysql<br>mysql.port=3306<br>mysql.host=110.110.110.110<br>mysql.database=azkaban<br>mysql.user=azkaban<br>mysql.password=azkaban  </p>
</blockquote>
</li>
<li><p>启动azkaban-executor-server  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../azkaban-3.81.0/azkaban-exec-server/build/install/azkaban-exec-server;</span><br><span class="line">bin/start-exec.sh; # 注意一定要按照这个语句执行,不要在bin目录下执行./start-exe.sh，否则某些资源文件会加载不到，导致报错</span><br></pre></td></tr></table></figure></li>
<li><p> 激活executor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指向executor地址和端口</span><br><span class="line">curl localhost:port/executor?action=activate</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动azkaban-web-server"><a href="#启动azkaban-web-server" class="headerlink" title="启动azkaban-web-server"></a>启动azkaban-web-server</h3><ul>
<li><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-exec-server/conf/azkaban.properties</span><br></pre></td></tr></table></figure>
<p>需要修改的内容如下  </p>
<blockquote>
<p>default.timezone.id=Asia/Shanghai # 修改为中国时区<br>#邮件配置<br>mail.sender=<a href="mailto:&#x38;&#x38;&#56;&#56;&#56;&#x38;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;">&#x38;&#x38;&#56;&#56;&#56;&#x38;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;</a> # 发送邮件的邮箱<br>mail.host=smtp.qq.com  # 邮件服务器<br>mail.user=<a href="mailto:&#x38;&#56;&#56;&#x38;&#56;&#x38;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x38;&#56;&#56;&#x38;&#56;&#x38;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a> # 邮件用户<br>mail.password=abc123456 #密码需要取qq邮箱中获取到的授权码<br>job.failure.email=<a href="mailto:&#56;&#56;&#56;&#x38;&#x38;&#x38;&#56;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#56;&#56;&#56;&#x38;&#x38;&#x38;&#56;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a> # 定时任务执行失败发送邮件的邮箱<br>#数据库配置，指向azkban建表的数据库，根据实际的数据库配置来<br>database.type=mysql<br>mysql.port=3306<br>mysql.host=110.110.110.110<br>mysql.database=azkaban<br>mysql.user=azkaban<br>mysql.password=azkaban</p>
</blockquote>
</li>
<li><p>启动azkaban-web-server  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-web-server;</span><br><span class="line">bin/start-web.sh;</span><br></pre></td></tr></table></figure>
<h3 id="访问azkaban"><a href="#访问azkaban" class="headerlink" title="访问azkaban"></a>访问azkaban</h3><p>浏览器输入 localhost:8199，出现如下界面<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/2.png"><br>用户名密码默认均为azkban，可以在 ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-web-server/conf/azkaban-users.xml 修改用户和密码  </p>
</li>
</ul>
<h2 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h2><p>1.打开azkaban主页面，点击create project，在弹出页面输入项目名和描述<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/3.png"><br>2.随后点击项目名进入配置页面，azkaban目前无法在页面直接配置，需要通过上传和下载配置文件来完成对定时任务的增删改，也就是用到页面上的upload和download按钮<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/4.png"><br>3.在本地新建一个test.flow文件，azkaban的基本配置文件需要用flow后缀的文件进行配置，配置的基本格式如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">config</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">failure.emails</span>: <span class="string">user@qq.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nodes</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">-</span> <span class="string">name: testA</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">command</span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">command</span>: <span class="string">echo &#x27;hello wrold&#x27;</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">name: testB</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">command</span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">command</span>: <span class="string">echo &#x27;hello wrold&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中nodes节点下的就是执行的任务，commnad写的就是该任务需要执行的指令，azkaban还支持其他job类型，具体见<a href="https://azkaban.readthedocs.io/en/latest/jobTypes.html">官方文档</a><br>我暂时只用到commond<br>4.同时新建一个flow20.project文件，里面只需要一条内容，如下<br>azkaban-flow-version: 2.0<br>5.将flow文件和flow20.project文件打包成 <strong>【项目名.zip】</strong>，然后在azkaban页面点击upload，上传该zip文件<br>6.点击项目名就可以看到刚创建的job，然后点击execute flow-schedule，就可以配置cron表达式，设置该任务的运行周期<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/5.png"><br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/6.png"><br>7.以后对于任务的新增和命令修改，都只能通过在azkaban页面点击download下载zip文件，然后修改里面的内容，再重新上传来完成</p>
<h2 id="清理历史定时任务执行日志"><a href="#清理历史定时任务执行日志" class="headerlink" title="清理历史定时任务执行日志"></a>清理历史定时任务执行日志</h2><p>简单粗暴的方法，在azkaban的数据库执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> execution_flows;</span><br><span class="line"><span class="keyword">truncate</span> execution_jobs;</span><br><span class="line"><span class="keyword">truncate</span> execution_logs;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>azkaban</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用技巧</title>
    <url>/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>1.进入<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 可以选择多种主题<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1.png"><br>点击图片进去可以看到这种主题的预览效果<br>点击文字进去将进入这个主题的github站点, 里面会详细说明该主题的安装和配置方式  </p>
<p>2.目前最流行的hexo主题应该是NexT, 我这次选的是3-hexo作为例子来讲解一下, 这个也是一个优秀的国产hexo主题<br>其最终效果如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2.png">   </p>
<p>3.关于3-hexo的安装和设置方法, 都可以直接参照<a href="https://github.com/yelog/hexo-theme-3-hexo">该主题的github主页</a><br>简单介绍一下:  </p>
<ul>
<li>获取3-hexo: git clone <a href="https://github.com/yelog/hexo-theme-3-hexo.git">https://github.com/yelog/hexo-theme-3-hexo.git</a> themes/3-hexo  </li>
<li>将3-hexo的主题文件夹复制到hexo的themes目录下  </li>
<li>修改3-hexo目录下的_config.yml文件, 修改方式在_config.yml中已经有详细的注释, 按照注释修改即可  </li>
<li>hexo主目录下打开git窗口, 依次输入如下命令<br>hexo clean (清除静态页面缓存文件, 防止出现缓存影响页面样式的情况)<br>hexo g (生成静态页面)<br>hexo s (启动本地hexo服务器, 可以打开localhost:4000查看页面效果)<br>hexo d (发布到github)  <span id="more"></span></li>
</ul>
<h2 id="设置分类和标签"><a href="#设置分类和标签" class="headerlink" title="设置分类和标签"></a>设置分类和标签</h2><p>1.每一个由hexo生成的md文件, 其内容开头都是由两个”—“组成的, hexo把这部分称为<a href="https://hexo.io/zh-cn/docs/front-matter">Front-Matter</a>, 如图:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/3.png">  </p>
<p>2.在Front-Matter的区域内可以设置关于文章的诸多信息, 包括标题, 创建时间, 标签, 目录, 是否开启评论等  </p>
<p>3.标签的参数名称为tags, 目录的参数名称为categories, 设置单个标签和目录的格式如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: hexo</span><br><span class="line">categories: hexo</span><br></pre></td></tr></table></figure>
<p>设置多个标签和多级目录的格式如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">- hexo</span><br><span class="line">- blog</span><br><span class="line">categories: </span><br><span class="line">- 学习</span><br><span class="line">- 搭建相关</span><br></pre></td></tr></table></figure>
<p><strong>注意:目录的先后顺序决定了其父子级关系, 如上面的例子中, “学习”目录是”搭建相关”目录的父目录. 在3-hexo主题中的效果如下:</strong><br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/4.png"></p>
<h3 id="以下是我的hexo更新之后需要额外操作的步骤"><a href="#以下是我的hexo更新之后需要额外操作的步骤" class="headerlink" title="以下是我的hexo更新之后需要额外操作的步骤"></a>以下是我的hexo更新之后需要额外操作的步骤</h3><p>4.使用命令创建tags和categories目录<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><br>这样会在source目录下生成tags和categories目录，并在该目录下生成index.md文件<br>5.在tags目录下index.md文件内增加一行 <strong>type: tags</strong>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2021-11-23 08:46:12</span><br><span class="line">type: tags</span><br></pre></td></tr></table></figure>
<p>在categories.md文件内增加一行 <strong>type: categories</strong>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2021-11-23 08:46:12</span><br><span class="line">type: categories</span><br></pre></td></tr></table></figure>
<p>6.重新执行hexo g即生成目录和标签</p>
<h2 id="MarkDown开发工具"><a href="#MarkDown开发工具" class="headerlink" title="MarkDown开发工具"></a>MarkDown开发工具</h2><p>我本人不太喜欢为markdown开发再安装一个软件, 所以以下都是针对程序员电脑上通常已有的软件上安装插件, 当然如果没有这些软件, 那推荐直接安装<a href="https://typora.io/">typora</a>  </p>
<p>1.Notepad++插件MarkdownViewer++<br>如果已经安装了Notepad++, 可以直接下载<a href="https://github.com/nea/MarkdownViewerPlusPlus/releases">MarkdownViewer++</a>插件<br>下载完成后, 直接将dll文件放入Notepad++主目录下的plugin文件夹下, 然后重新启动Notepad++即可, 在Notepad++的工具栏会出现一个”m”图标:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/5.png"><br>点击即可实时查看页面效果<br>优点: 插件轻量级, 1MB不到, 占用系统的内存消耗极小<br>缺点: 功能非常有限, 只能实时查看效果, 不能对markdown语法高亮  </p>
<p>2.Idea插件MarkDown Navigator<br>其实Idea自带了一个MarkDown的插件, 但是这个插件不太好用, 所以这里不再介绍了<br>打开Idea, 打开File-Settings-Plugins-Browse Repositories, 查找MarkDown Navigator, 点击Install, 重新启动Idea即可<br>效果如图:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/6.png"><br>优点: 支持MarkDown语法高亮, 支持语法快捷键, 且在Idea内开发, 对于程序员来说比较习惯<br>缺点: 毕竟需要Idea来开发, 对于仅仅只要写博客的人来说, 显得有点笨重  </p>
<p>3.MarkDown在线编辑器<br>在线编辑的好处不言自明, 不用安装任何软件和插件, 只要有浏览器就行<br>推荐<a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a> </p>
<h2 id="为博客设置密码"><a href="#为博客设置密码" class="headerlink" title="为博客设置密码"></a>为博客设置密码</h2><p>1.安装插件: 在hexo主目录下执行npm install –save hexo-blog-encrypt<br>2.在需要设置密码的博客的Front-Matter里面加一个参数<br>password:*****  </p>
<h2 id="如何上传图片"><a href="#如何上传图片" class="headerlink" title="如何上传图片"></a>如何上传图片</h2><p>1.在github存储图片并在博客内关联图片链接<br>这种方式比较推荐, 因为别的博客网站通常都会有防止外部访问的措施在, 存储<br>在github上的图片不会有外部无法访问的情况. 对于各个版本的hexo都能适用.</p>
<ul>
<li>打开hexo主目录下的_config.yml文件, 修改参数post_asset_folder为true</li>
<li>使用hexo n “博客标题” 新建博客时将会同时新建一个同名的资源文件夹, 如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/7.png">  </li>
<li>将博客内用到的图片放置到资源文件夹内, 可以按顺序号命名, 如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/8.png"></li>
<li>在博客内链接该图片, 格式为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](https://raw.githubusercontent.com/#username/#username.github.io/master/#YYYY/#MM/#DD/#title/#photoname)  </span><br><span class="line">#username : github用户名</span><br><span class="line">#YYYY/#MM/#DD : 如果没有修改_config.yml里的默认文件夹创建方式的话, 就是填入年月日即可, 如2019/10/14  </span><br><span class="line">#title : 文章标题  </span><br><span class="line">#photoname : 图片名称  </span><br></pre></td></tr></table></figure>
比如我这篇博客的图片链接地址如下图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/9.png">  </li>
<li>链接完图片后目前在博客的预览界面还无法看到图片, 需要先执行<br>hexo clean (非必要步骤, 如果博客页面格式显示不正确, 需要执行)<br>hexo g (创建博客静态网页文件)<br>hexo d (这一步用于发布博客, 也同时发布图片)<br>hexo d的命令将会把图片发布到github服务器上, 也就可以在上述格式的图片地址里看到该图片  </li>
</ul>
<p>2.直接链接本地地址, 这种方式也很方便, 网上也有挺多人使用这种方式, 主要优点<br>是不用多操作一步链接网络地址, 我贴一下该方式:</p>
<ol>
<li>打开hexo主目录下的_config.yml文件, 修改参数post_asset_folder为true</li>
<li>安装图片插件 npm install hexo-asset-image –save<br>或者安装  npm install hexo-renderer-marked -s</li>
<li>在博客内直接引用本地地址即可, 如  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](/1.png)</span><br></pre></td></tr></table></figure>
<h2 id="设置首页文章摘要"><a href="#设置首页文章摘要" class="headerlink" title="设置首页文章摘要"></a>设置首页文章摘要</h2>有三种方法，推荐使用第一种，更加灵活的根据文章进行不同长度的摘要截断，而且对于不同的插件也有最好的适应性</li>
<li>在文章中使用 <!-- more --> 手动进行截断，Hexo 提供的方式</li>
<li>在文章的 front-matter 中添加 description，并提供文章摘录 </li>
<li>自动形成摘要，在 主题配置文件 中添加<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">enable</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">length</span>: <span class="string">150</span></span><br></pre></td></tr></table></figure>
默认截取的长度为 150 字符，可以根据需要自行设定</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linux日常维护命令</title>
    <url>/2019/10/16/tech/linux%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="删除测试库创建日期在10天以前的日志"><a href="#删除测试库创建日期在10天以前的日志" class="headerlink" title="删除测试库创建日期在10天以前的日志"></a>删除测试库创建日期在10天以前的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -ctime +10 -type f -name &quot;*log.log.20*&quot; | xargs rm -rf</span><br></pre></td></tr></table></figure>

<h2 id="查看磁盘空间和大文件"><a href="#查看磁盘空间和大文件" class="headerlink" title="查看磁盘空间和大文件"></a>查看磁盘空间和大文件</h2><h3 id="查看磁盘剩余空间"><a href="#查看磁盘剩余空间" class="headerlink" title="查看磁盘剩余空间"></a>查看磁盘剩余空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h3 id="查看目录下大文件"><a href="#查看目录下大文件" class="headerlink" title="查看目录下大文件"></a>查看目录下大文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>

<h2 id="查看进程中的java程序"><a href="#查看进程中的java程序" class="headerlink" title="查看进程中的java程序"></a>查看进程中的java程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死某个进程</span></span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>

<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br></pre></td></tr></table></figure>

<h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp C:/Users/Administrator/Downloads/elasticsearch-7.3.1-linux-x86_64.tar.gz root@192.168.15.161:/home/bos-provider/bos-provider-1.0-SNAPSHOT/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="MQ查询命令"><a href="#MQ查询命令" class="headerlink" title="MQ查询命令"></a>MQ查询命令</h2><h4 id="查询某条消息的生产者和消费者，以及消息的track路径"><a href="#查询某条消息的生产者和消费者，以及消息的track路径" class="headerlink" title="查询某条消息的生产者和消费者，以及消息的track路径"></a>查询某条消息的生产者和消费者，以及消息的track路径</h4><p>1.进入/usr/java/rocketmq/bin<br>2.根据key查找</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin queryMsgBykey -n 127.0.0.1:9876 -k b6df2c64-4654-409d-b457-ec1db294a606 -t ORDER</span><br></pre></td></tr></table></figure>

<p>3.根据key可以找到ID<br>   根据ID查找消费者和生产者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin queryMsgById -n 127.0.0.1:9876 -i C0A8074100002A9F00000001A2BC9012</span><br></pre></td></tr></table></figure>

<h4 id="查看topiclist"><a href="#查看topiclist" class="headerlink" title="查看topiclist"></a>查看topiclist</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin topicList –n 127.0.0.1:9876</span><br></pre></td></tr></table></figure>

<h3 id="curl发送post请求"><a href="#curl发送post请求" class="headerlink" title="curl发送post请求"></a>curl发送post请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date=`date +%Y-%m-%d `;curl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;dateBegin&quot;:&quot;&#x27;$date&#x27; 00:00:00&quot;,&quot;dateEnd&quot;:&quot;&#x27;$date&#x27; 23:59:59&quot;&#125;&#x27; &quot;http://192.168.15.162:8082/hr/syncPunchRecordByUser&quot;</span><br></pre></td></tr></table></figure>

<p>参数 内容<br>-H 请求头<br>-d POST内容<br>-X 请求协议</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins简单搭建</title>
    <url>/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="下载和安装jenkins"><a href="#下载和安装jenkins" class="headerlink" title="下载和安装jenkins"></a>下载和安装jenkins</h2><p>相对简单的办法，依次执行以下语句(前提，需要先安装rpm) </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取jenkins的rpm安装文件</span></span><br><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.222.3-1.1.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">使用rpm安装</span></span><br><span class="line">rpm -ivh jenkins-2.222.3-1.1.noarch.rpm </span><br></pre></td></tr></table></figure>

<h2 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h2><p>jenkins启动需要先安装java，java的安装不再赘述，java安装完成后，修改jenkins配置文件，指向java的安装目录 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/jenkins</span><br></pre></td></tr></table></figure>
<p>在”candidates=”这一行加入java安装目录，如果默认配置里面已经指向了你的java安装目录，则不需要再次配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">candidates=&quot;</span><br><span class="line">/etc/alternatives/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-1.7.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.7.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-11.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-11.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">/usr/bin/java</span><br><span class="line">/usr/java/jdk1.8.0_121/jre/bin/java</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>修改jenkins端口 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> JENKINS_PORT=<span class="string">&quot;8999&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>配置完成后，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service jenkins start</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service jenkins status</span><br></pre></td></tr></table></figure>
<p>出现以下截图说明成功启动<br><img src="/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/1.png">  </p>
<h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><p>访问 <a href="http://localhost:8999/">http://localhost:8999/</a> 即可看到jenkins的启动页面，稍等一会儿，看到如下页面：<br><img src="/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/2.png"><br>接下来按照页面指引一步步安装即可。</p>
<ul>
<li>需要注意的点：插件按照推荐插件安装后，可能会有个别插件无法完成安装，这时不要选择重试，直接跳过，在Manage Jenkins - Mange Plugins - 高级，修改URL为 <a href="http://mirror.esuni.jp/jenkins/updates/update-center.json">http://mirror.esuni.jp/jenkins/updates/update-center.json</a> ，然后再更新插件即可。  </li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>linux版本过低情况下使用高版本nodejs</title>
    <url>/2021/12/17/tech/linux%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%ACnodejs/</url>
    <content><![CDATA[<p><strong>我这里针对的低版本linux指的是centos6。</strong></p>
<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>最近需要写一个页面，我前段时间一直在用nodejs开发，所以我就选择了react来写页面。在本机开发调试完成之后，部署到linux上出现问题，在运行npm install命令的时候出现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm WARN notsup Unsupported engine for react-scripts@5.0.0: wanted: &#123;&quot;node&quot;:&quot;&gt;=14.0.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: react-scripts@5.0.0</span><br><span class="line">npm WARN notsup Unsupported engine for css-loader@6.5.1: wanted: &#123;&quot;node&quot;:&quot;&gt;= 12.13.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: css-loader@6.5.1</span><br><span class="line">npm WARN notsup Unsupported engine for css-minimizer-webpack-plugin@3.3.1: wanted: &#123;&quot;node&quot;:&quot;&gt;= 12.13.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: css-minimizer-webpack-plugin@3.3.1</span><br><span class="line">npm WARN notsup Unsupported engine for eslint@8.5.0: wanted: &#123;&quot;node&quot;:&quot;^12.22.0 || ^14.17.0 || &gt;=16.0.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: eslint@8.5.0</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>显然，根据提示是因为node版本太低导致，那首先想到的必然就是升级node版本。</p>
<h2 id="尝试升级node版本失败，gcc版本过低"><a href="#尝试升级node版本失败，gcc版本过低" class="headerlink" title="尝试升级node版本失败，gcc版本过低"></a>尝试升级node版本失败，gcc版本过低</h2><p>升级node版本有几种办法：</p>
<ul>
<li>通过下载<a href="https://nodejs.org/en/download/releases/">官网</a>的二进制包，然后解压缩到目录，再通过ln指令进行node版本的关联。</li>
<li>第二种方法比较简单，安装node的一个版本管理工具，叫<a href="https://github.com/tj/n">n</a>，然后运行如下指令就可以完成安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line">n node版本号</span><br></pre></td></tr></table></figure>
<span id="more"></span>
然而在我运行了n 14 之后，却出现了报错如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.5&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#x27; not found (required by node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.5&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#x27; not found (required by /usr/local/bin/node)</span><br></pre></td></tr></table></figure>
这个报错我去网上搜了下，原因基本就是因为gcc的版本过低导致。在解决这个问题的时候，我出现了非常多的路线错误，导致这个问题本来挺容易解决的，却绕了很多的弯。</li>
</ul>
<h2 id="尝试升级gcc版本失败，yum安装源版本过低"><a href="#尝试升级gcc版本失败，yum安装源版本过低" class="headerlink" title="尝试升级gcc版本失败，yum安装源版本过低"></a>尝试升级gcc版本失败，yum安装源版本过低</h2><p>首先我直接尝试了运行yum安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>
<p>结果报错，提示404。经查发现原来centos已经停止支持centos6版本的linux了，甚至还卸磨杀驴，将之前的yum源也都关闭，不仅如此，国内的所有centos6的镜像yum源也都关闭了。最终我在阿里的镜像源里看到一句话，如果非要用centos6的yum源，访问<a href="https://vault.centos.org/">https://vault.centos.org/</a>。看来centos还是归档了一份镜像源，还算有点良心，但是这个网站也写了下面一段话。</p>
<blockquote>
<p>This is <em>NOT</em> an updated tree for installing CentOS Linux : It is a snapshot of the older trees that have been removed from the main CentOS servers as new point releases are released.<br>  This is provided for reference and to provide access to older archived versions, and we do not put security updates into the trees on this server.<br>  Please see this <a href="http://www.centos.org/download">link</a> for active versions of CentOS Linux </p>
</blockquote>
<p>总之就是告诉你这个镜像也尽量别用，只是为了老版本linux做的一个备份而已。反正centos意思也很明显了，centos6你就别用了，能升级就升级。<br>那有什么办法呢，先用这个镜像源看看吧。尝试替换yum源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 最好是先备份一份，我只是为了复盘问题处理过程，所以省略这一步</span></span></span><br><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>
<p>可以直接用如下内容替换进去：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意，这是centos6的yum源，更高版本的不要用这个源</span></span><br><span class="line"><span class="attr">[base]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Base - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/os/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line"><span class="attr">[updates]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Updates - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/updates/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line"><span class="attr">[extras]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Extras - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/extras/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line"><span class="attr">[centosplus]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Plus - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/centosplus/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#contrib - packages by Centos Users</span></span><br><span class="line"><span class="attr">[contrib]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Contrib - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/contrib/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br></pre></td></tr></table></figure>
<p>这样一通操作之后，通过yum安装gcc倒是走通了，可是。。。安装的版本还是不符合要求，这个yum源下的gcc最高版本还是太低。那咋办？我想到了两个方式，一是手动安装，二是。。。升级linux版本。</p>
<h2 id="尝试手动安装高版本gcc失败"><a href="#尝试手动安装高版本gcc失败" class="headerlink" title="尝试手动安装高版本gcc失败"></a>尝试手动安装高版本gcc失败</h2><p>过程不再赘述了，基本原因是linux内核版本太低，使得make命令执行失败。</p>
<h2 id="升级lunux版本失败"><a href="#升级lunux版本失败" class="headerlink" title="升级lunux版本失败"></a>升级lunux版本失败</h2><p>升级linux我确实也去查了下方法，升级失败的原因也挺操蛋的，就是centos全面关闭centos6的支持，甚至连centos6升级到centos7的通道都关了，导致网上查的那些方法都不能用，centos真是全面诠释了什么叫全面关闭对老系统的支持。</p>
<h2 id="回归最早的报错，解决-39-GLIBCXX-3-4-20-39-not-found的问题"><a href="#回归最早的报错，解决-39-GLIBCXX-3-4-20-39-not-found的问题" class="headerlink" title="回归最早的报错，解决&#39;GLIBCXX_3.4.20&#39; not found的问题"></a>回归最早的报错，解决<code>&#39;GLIBCXX_3.4.20&#39; not found</code>的问题</h2><p>上面解决问题的过程持续了几乎一整天，我在linux版本升级也失败之后，我突然意识到，我只是想要部署个web页面而已啊，为啥会搞的这么麻烦？于是我回归到最早的那个报错，<code>&#39;GLIBCXX_3.4.20&#39; not found</code>，在百度上连续吃瘪之后，我用了谷歌来查这个问题，没想到的是，谷歌出来的一片文章五分钟就解决另外我的问题。<br>这篇文章链接：<a href="https://www.jianshu.com/p/050b2b777b9d">version ‘GLIBCXX_3.4.20’ not found 解决方法</a>。<br>为了防止原文404，我也备份一下这个解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 查看系统版本</span><br><span class="line">strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line"></span><br><span class="line">发现少了GLIBCXX_3.4.20，解决方法是升级libstdc++.</span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line">sudo yum provides libstdc++.so.6</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">libstdc++-4.8.5-39.el7.i686 : GNU Standard C++ Library</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libstdc++.so.6</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">cd /usr/local/lib64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最新版本的libstdc.so_.6.0.26</span></span><br><span class="line">sudo wget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip</span><br><span class="line">unzip libstdc.so_.6.0.26.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下载的最新版本拷贝到 /usr/lib64</span></span><br><span class="line">cp libstdc++.so.6.0.26 /usr/lib64</span><br><span class="line">cd  /usr/lib64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 /usr/lib64下libstdc++.so.6链接的版本</span></span><br><span class="line">ls -l | grep libstdc++</span><br><span class="line">libstdc++.so.6 -&gt;libstdc++.so.6.0.19</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除/usr/lib64原来的软连接libstdc++.so.6，删除之前先备份一份</span></span><br><span class="line">sudo rm libstdc++.so.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接新的版本</span></span><br><span class="line">sudo ln -s libstdc++.so.6.0.26 libstdc++.so.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看新版本，成功</span></span><br><span class="line">strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_3.4.20</span><br><span class="line">GLIBCXX_3.4.21</span><br><span class="line">GLIBCXX_3.4.22</span><br><span class="line">GLIBCXX_3.4.23</span><br><span class="line">GLIBCXX_3.4.24</span><br><span class="line">GLIBCXX_3.4.25</span><br><span class="line">GLIBCXX_3.4.26</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其实这个方法也算是手动安装，但是问题的关键是他的方式是只升级了libstdc，而我之前纠结的一直是gcc版本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问题最后圆满解决了，这个过程中也算是学到了不少东西，所以想记录一下。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>logback日志配置模板</title>
    <url>/2019/11/05/tech/logback%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 常量定义start --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认日志输出格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;HOST_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Project_Name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DEFAULT_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ** $&#123;HOST_NAME&#125; ** [%thread] ** %level ** [%logger] ** - %file:%line ** [%method] - ** %msg%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MAX_HISTORY&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_QUEUE_SIZE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DEFAULT_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 常量定义end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 默认日志的console appender，本地使用的日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>E:/logs/$&#123;HOST_NAME&#125;/$&#123;HOST_NAME&#125;-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!local&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务器上使用的appender start --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认的file appender，按天切分日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/home/logs/$&#123;HOSTNAME&#125;/$&#123;HOSTNAME&#125;-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 错误日志，按天切分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_ERROR&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/home/logs/$&#123;HOSTNAME&#125;/$&#123;HOSTNAME&#125;_error-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_ROLLING_FILE_ERROR&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
  </entry>
  <entry>
    <title>利用hexo和github搭建个人博客</title>
    <url>/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="github建立个人网站"><a href="#github建立个人网站" class="headerlink" title="github建立个人网站"></a>github建立个人网站</h2><p>1.github的账号申请不再赘述<br>2.打开github.com, 点击new, 新建一个项目<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png"><br>3.输入项目名称, 注意项目名称的格式必须是”用户名.github.io”的格式<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png"><br>4.点击Create Repository完成项目新建<br>5.点击新建的项目, 进入settings, 往下找到GitHub Pages, 点击Choose a theme, 选择一个主题后, 点击select theme就完成了网站的发布<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png"><br>6.在浏览器输入”用户名.github.io”, 就可以看到github为你默认创建的首页  </p>
<h2 id="hexo搭建博客"><a href="#hexo搭建博客" class="headerlink" title="hexo搭建博客"></a>hexo搭建博客</h2><p>1.在使用hexo搭建博客之前, 需要完成几个基础工作<br><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">安装git</a><br><a href="https://help.github.com/cn/articles/adding-a-new-ssh-key-to-your-github-account">新增ssh key到github</a><br><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">安装node.js</a><br>2.在本地拉取github上刚刚创建的网页项目(用户名.github.io)<br>3.在项目目录下新建一个文件夹, 可以随意命名, 比如hexo<br>4.进入hexo目录, windows下右键空白处, 点击Git Bash Here<br>5.依次执行命令<br>npm install hexo-cli -g  (安装hexo)<br>hexo init  (初始化网站)<br>npm install hexo-deployer-git –save  (安装hexo发布到git的插件)<br>中间遇到需要确认的信息, 直接按回车即可<br>6.打开hexo目录下的_config.yml文件, 有几个地方可以进行修改<br>title: 你的网站名字<br>author: 网站作者<br>theme: 去<a href="https://hexo.io/themes/">hexo主题</a>可以选择, 注意要先将主题下载到hexo/themes下才可选择该主题<br>注意: <strong>必须要修改的部分是deploy, 改成如下格式</strong>  </p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>其他配置的详细说明在<a href="https://hexo.io/docs/configuration.html">hexo配置文件说明</a><br>7.接下来就可以开始写博客了<br>使用命令hexo n “博客标题”, 即完成了一个新的博客文件的创建<br>该命令会在hexo/source/_posts目录下新建一个”博客标题.md”的文件<br>该文件内容格式如下<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png"><br>正文内容使用markdown语法进行编写, 至于markdown怎么写, 可以参考<a href="http://www.markdown.cn/">markdown官方文档</a><br>8.博客写完之后, 保存文件, 然后依次执行如下命令<br>hexo g  (根据md文件创建静态网页文件, 注意每次更新博客内容都需要执行这个命令)<br>hexo s  (这一步是启动本地hexo服务器, 主要是为了本地预览博客效果, 浏览器打开localhost:4000预览效果)<br>hexo d (发布网页到github)<br>9.浏览器打开”用户名.github.io”即可看到你刚刚写的博客内容<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说, hexo+github搭建博客非常的简便, hexo内置的几种主题也都非常的简洁美观, 对于既想要有逼格的有自己的个人博客网站, 又不想太麻烦的人来说, 是个不错的选择</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>官方文档解释MySQL最左匹配(最左前缀)原则</title>
    <url>/2019/10/15/tech/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E9%87%8AMySQL%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D(%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80)%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h2><p>关于最左匹配原则的解释, 网上找了很多, 但是我感觉都不是特别准确, 于是一怒之下<br>直接找了官网的文档, 一下子就清晰了. 下面贴下官网的解释, 然后我自己翻译了一下.  </p>
<h3 id="来自官方文档的解释"><a href="#来自官方文档的解释" class="headerlink" title="来自官方文档的解释"></a>来自官方文档的解释</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html">原文链接</a>  </p>
<blockquote>
<p>MySQL can create composite indexes (that is, indexes on multiple columns).<br> An index may consist of up to 16 columns. For certain data types,<br> you can index a prefix of the column (see<br> <a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">Section 8.3.5, “Column Indexes”</a>).  </p>
</blockquote>
<p>MySQL可以创建联合索引(即, 多列的索引). 一个索引可以包含最多16列. 对于<br>某些数据类型, 你可以索引列的前缀(这里说的是对于Blob和Text类型, 索引列的前几位就可以,<br>如INDEX(blob_col(10)), 详见<a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">索引文档</a>)  </p>
<blockquote>
<p>MySQL can use multiple-column indexes for queries that test all the columns in the index,<br>or queries that test just the first column, the first two columns, the first three columns, and so on.<br>If you specify the columns in the right order in the index definition,<br>a single composite index can speed up several kinds of queries on the same table.  </p>
</blockquote>
<p>MySQL的联合索引可以用于包含索引中所有列的查询条件的语句, 或者包含索引中的第一列的查询条件的语句,<br>以及索引中前两列, 索引中的前三列, 以此类推. 如果你在索引定义中以正确的顺序指定列,<br>那么联合索引就可以加速同一张表中的多个不同类型的查询.  </p>
<blockquote>
<p>A multiple-column index can be considered a sorted array, the rows of<br>which contain values that are created by concatenating the values of the indexed columns.  </p>
</blockquote>
<p>一个联合索引可以看作是一个有序队列, 里面有值的列是根据连接索引列的值创建的.(这句可能不准确)  </p>
<blockquote>
<p>Note<br>As an alternative to a composite index, you can introduce a column that<br>is “hashed” based on information from other columns. If this column is<br>short, reasonably unique, and indexed, it might be faster than a “wide”<br>index on many columns. In MySQL, it is very easy to use this extra column:  </p>
</blockquote>
<p>提示<br>作为联合索引的一个替代项, 你可以采用一个Hash值列, 这个列的Hash值来自其他的列.<br>如果该列简短, 合理唯一, 且被索引, 那该列就可能比一个很”宽”的由多个列构成的索引<br>更快. MySQL里可以很容易的使用这种列:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> hash_col<span class="operator">=</span>MD5(CONCAT(val1,val2))</span><br><span class="line">  <span class="keyword">AND</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>Suppose that a table has the following specification:</p>
</blockquote>
<p>假设有如下表定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id         <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name  <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX name (last_name,first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The name index is an index over the last_name and first_name columns.<br>The index can be used for lookups in queries that specify values in a known<br>range for combinations of last_name and first_name values. It can also be used<br>for queries that specify just a last_name value because that column is a<br>leftmost prefix of the index (as described later in this section).<br>Therefore, the name index is used for lookups in the following queries:  </p>
</blockquote>
<p>索引name是一个包含了last_name和first_name列的索引. 该索引可以用于为last_name<br>和first_name值的组合指定一个已知范围内的查询. 同样也可以用于只指定了last_name列值的查询,<br>因为这个列是索引的一个最左前缀(就如下一节所说). 因此, 索引name可以用于下列的查询语句:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span> <span class="keyword">AND</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> (first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;Jon&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> first_name <span class="operator">&gt;=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span> first_name <span class="operator">&lt;</span> <span class="string">&#x27;N&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>However, the name index is not used for lookups in the following queries:  </p>
</blockquote>
<p>然而, 索引name不能用于下列的查询:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Suppose that you issue the following SELECT statement:  </p>
</blockquote>
<p>假设存在以下select语句:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If a multiple-column index exists on col1 and col2, the appropriate<br>rows can be fetched directly. If separate single-column indexes exist<br>on col1 and col2, the optimizer attempts to use the Index Merge optimization<br>(see Section 8.2.1.3, “Index Merge Optimization”), or attempts to find<br>the most restrictive index by deciding which index excludes more rows<br>and using that index to fetch the rows.  </p>
</blockquote>
<p>如果一个联合索引存在于col1和col2, 相应的列会被直接抓取. 如果是分为单独的索引<br>分别存在于col1和col2, 优化器会尝试利用索引联合优化(详见8.2.1.3, <a href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html">“索引联合<br>优化”</a>),<br>或者尝试去寻找包含最多列, 最大限制的索引, 并利用该索引去抓取列.  </p>
<blockquote>
<p><strong>If the table has a multiple-column index, any leftmost prefix of the<br>index can be used by the optimizer to look up rows. For example,<br>if you have a three-column index on (col1, col2, col3), you have indexed<br>search capabilities on (col1), (col1, col2), and (col1, col2, col3).</strong>  </p>
</blockquote>
<p><strong>如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如,<br>如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1),<br>(col1, col2), 以及(col1, col2, col3)</strong>  </p>
<blockquote>
<p><strong>MySQL cannot use the index to perform lookups if the columns do not<br>form a leftmost prefix of the index. Suppose that you have the SELECT<br>statements shown here:</strong>  </p>
</blockquote>
<p><strong>如果查询的列不是索引的最左前缀, 那MySQL不会将索引用于执行查询. 假设你有<br>下列查询语句:</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2 <span class="keyword">AND</span> col3<span class="operator">=</span>val3;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If an index exists on (col1, col2, col3), only the first two queries<br>use the index. The third and fourth queries do involve indexed columns,<br>but do not use an index to perform lookups because (col2) and (col2, col3)<br>are not leftmost prefixes of (col1, col2, col3).  </p>
</blockquote>
<p>如果索引存在于(col1, col2, col3), 那只有头两个查询语句用到了索引. 第三个和<br>第四个查询包含索引的列, 但是不会用索引去执行查询. 因为(col2)和(col2, col3)<br>不是(col1, col2, col3)的最左前缀  </p>
<h2 id="官方文档小结"><a href="#官方文档小结" class="headerlink" title="官方文档小结"></a>官方文档小结</h2><p>其实官方文档已经解释的非常详细了, 总结关于最左匹配的解释, 那其实只有这么<br>几句话:<br>1.按照文档, 更准确的说法应该是最左前缀原则, 即如果你创建一个联合索引, 那<br>这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀<br>就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索<br>引查询.<br>2.其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列<br>也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.<br><strong>注意, (col1, col3)会启用(col1)的索引查询</strong>  </p>
<h3 id="官方文档的其他细节"><a href="#官方文档的其他细节" class="headerlink" title="官方文档的其他细节"></a>官方文档的其他细节</h3><p>读一下官方文档, 还有很多别的发现, 跟最左前缀无关, 关于联合索引的别的细节,<br>总结如下:  </p>
<ul>
<li>联合索引最多只能包含16列  </li>
<li>blob和text也能创建索引, 但是必须指定前面多少位  </li>
<li>官方推荐了一种联合索引的替代方案: 可以额外创建一列, 其列值由联合索引包含<br>的所有列值所生成的hash值来构成(个人认为似乎破坏了第一范式的设计规则) </li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建新项目的框架</title>
    <url>/2019/10/22/tech/%E6%90%AD%E5%BB%BA%E6%96%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> 基础架构：Spring Boot / Spring Cloud</li>
<li><input checked="" disabled="" type="checkbox"> 数据库：MySQL / Oracle</li>
<li><input checked="" disabled="" type="checkbox"> 数据库层连接：Hibernate / Mybatis / JPA</li>
<li><input checked="" disabled="" type="checkbox"> 分页</li>
<li><input checked="" disabled="" type="checkbox"> 日志：Log4j / Slf4J</li>
<li><input checked="" disabled="" type="checkbox"> 数据库连接池：Druid</li>
<li><input checked="" disabled="" type="checkbox"> 消息中间件：Dubbo / Grpc</li>
<li><input disabled="" type="checkbox"> 缓存：Redis</li>
<li><input checked="" disabled="" type="checkbox"> 权限：Spring Security / Shiro</li>
<li><input checked="" disabled="" type="checkbox"> 包管理仓库：Maven / Gradle</li>
<li><input disabled="" type="checkbox"> 统一日志记录-数据库层面</li>
<li><input checked="" disabled="" type="checkbox"> JSON处理：FastJSON</li>
<li><input checked="" disabled="" type="checkbox"> 统一返回结果处理</li>
<li><input checked="" disabled="" type="checkbox"> Zookeeper</li>
<li><input disabled="" type="checkbox"> MQ组件：RabbitMQ / RocketMQ / Kafka</li>
<li><input checked="" disabled="" type="checkbox"> 统一Exception处理</li>
<li><input checked="" disabled="" type="checkbox"> 公用Util类</li>
<li><input checked="" disabled="" type="checkbox"> 测试用例：JUnit</li>
<li><input disabled="" type="checkbox"> 集群</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
  </entry>
  <entry>
    <title>用curl计算网络请求的时间</title>
    <url>/2021/11/29/tech/%E7%94%A8curl%E8%AE%A1%E6%97%B6/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://susam.in/maze/timing-with-curl.html">Timing With Curl</a></p>
<hr>
<p>当一个http请求花费了太长时间的时候，我经常用下面的命令来查找原因。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -w &quot;time_namelookup: %&#123;time_namelookup&#125;</span><br><span class="line">time_connect: %&#123;time_connect&#125;</span><br><span class="line">time_appconnect: %&#123;time_appconnect&#125;</span><br><span class="line">time_pretransfer: %&#123;time_pretransfer&#125;</span><br><span class="line">time_redirect: %&#123;time_redirect&#125;</span><br><span class="line">time_starttransfer: %&#123;time_starttransfer&#125;</span><br><span class="line">time_total: %&#123;time_total&#125;</span><br><span class="line">&quot; https://example.com/</span><br></pre></td></tr></table></figure>
<p>下面是用一条指令来实现的同样的命令，我可以在未来用到的时候，在这个页面通过三次点击快速复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -w &quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot; https://example.com/</span><br></pre></td></tr></table></figure>
<p>这个命令输入之后，一般能看到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;namelookup: %&#123;time_namelookup&#125;\nconnect: %&#123;time_connect&#125;\nappconnect: %&#123;time_appconnect&#125;\npretransfer: %&#123;time_pretransfer&#125;\nstarttransfer: %&#123;time_starttransfer&#125;\ntotal: %&#123;time_total&#125;\n&quot;</span> https://example.com/</span></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001403</span><br><span class="line">time_connect: 0.245464</span><br><span class="line">time_appconnect: 0.757656</span><br><span class="line">time_pretransfer: 0.757823</span><br><span class="line">time_redirect: 0.000000</span><br><span class="line">time_starttransfer: 0.982111</span><br><span class="line">time_total: 0.982326</span><br></pre></td></tr></table></figure>
<p>为了简洁起见，在上面的输出中，我用省略号忽略了大部分的html部分的输出。<br>下面的列表描述了输出中每一个数字的含义。这些信息直接取自curl 7.20.0版本的手册。以下是详情：</p>
<ul>
<li><em>time_namelookup</em>: 以秒为单位，表示从命令开始到域名被解析完成所需时间。</li>
<li><em>time_connect</em>: 以秒为单位，表示从命令开始到TCP请求完成连接到远程端口（或代理）所需时间。</li>
<li><em>time_appconnect</em>: 以秒为单位，表示从命令开始到SSL／SSH等请求完成到远程端口的连接／握手所需时间。（7.19.0版本后加入）</li>
<li><em>time_pretransfer</em>: 以秒为单位，表示从命令开始到文件传输开始所需时间。这包括所有的预传输命令和协议。包含所有涉及到特定协议的预传输指令和谈判（？）。</li>
<li><em>time_redirect</em>: 以秒为单位，包括所有的重定向步骤，从域名检索，连接，预传输以及在最后交换数据开始之前的传输所需时间。time_redirect展示了多个重定向请求的完整执行时间。（7.12.3版本后加入）</li>
<li><em>time_starttransfer</em>: 以秒为单位，表示从命令开始到第一个字节被传输所属时间。这包含了<em>time_pretransfer</em>，以及服务器计算结果所属的时间。</li>
<li><em>time_total</em>: 以秒为单位，表示整个操作持续到最后所需的总时间。这个时间会精确到毫秒进行展现。</li>
</ul>
<p>一个没啥用的关键细节是，<em>time_appconnect</em>和<em>time_connect</em>之间的时间差可以告诉我们SSL／TLS握手所需时间。对于一个没有SSL／TLS的干净连接，这个时间会显示为0。下面的输出证明了这件事：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot;</span> http://example.com/</span></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001507</span><br><span class="line">time_connect: 0.247032</span><br><span class="line">time_appconnect: 0.000000</span><br><span class="line">time_pretransfer: 0.247122</span><br><span class="line">time_redirect: 0.000000</span><br><span class="line">time_starttransfer: 0.512645</span><br><span class="line">time_total: 0.512853</span><br></pre></td></tr></table></figure>

<p>同样注意<em>time_redirect</em>在上面的输出中也是0。这是因为访问example.com的时候，没有重定向发生。以下是另一个例子，展示了当重定向发生时输出会是什么样子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot;</span> https://susam.in/blog</span></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001886</span><br><span class="line">time_connect: 0.152445</span><br><span class="line">time_appconnect: 0.465326</span><br><span class="line">time_pretransfer: 0.465413</span><br><span class="line">time_redirect: 0.614289</span><br><span class="line">time_starttransfer: 0.763997</span><br><span class="line">time_total: 0.765413</span><br></pre></td></tr></table></figure>

<p>当网络服务遭遇一个潜在的延迟事件时，我会在多个客户端优先使用这条命令，因为这个命令返回的结果帮助我快速找到网络延迟的原因。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Dubbo无法处理自定义异常的问题</title>
    <url>/2019/11/04/tech/%E8%A7%A3%E5%86%B3Dubbo%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Dubbo有一个比较奇怪的问题，目前不知道Apache和Alibaba公司出于什么样的考虑，貌似一直都没有一个比较合适的解决方案，问题如下：</p>
<ul>
<li><p>项目搭建中你需要自定义一个本地的Exception，命名为比如BusinessException。比较一般的书写代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> linqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 业务异常类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(Integer code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通常这个BusinessException是要能够跨模块使用的，一般放在commons或者core模块中，同时别的模块的pom.xml文件引入这些模块，使得整个项目都可以使用这个BusinessException。</p>
</li>
<li><p>问题来了，如果在A模块调用了B模块，B模块抛出了一个BusinessException，这时A模块接收到的不是BusinessException，而是一个RuntimeException，而且关于BusinessException的细节已经完全丢失，只会剩下一个类名的描述。</p>
</li>
</ul>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>关于该问题出现的原因，参考<a href="https://blog.csdn.net/qq_25673113/article/details/78574514">这篇文章</a>，归纳一下，就是在Dubbo的传输信息过程中，类ExceptionFilter.java会对Exception做一个过滤，其过滤器的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// directly throw if it&#x27;s checked exception</span></span><br><span class="line"><span class="keyword">if</span> (!(exception <span class="keyword">instanceof</span> RuntimeException) &amp;&amp; (exception <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// directly throw if the exception appears in the signature</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());</span><br><span class="line">    Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; exceptionClass : exceptionClassses) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception.getClass().equals(exceptionClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="comment">// for the exception not found in method&#x27;s signature, print ERROR message in server&#x27;s log.</span></span><br><span class="line">logger.error(<span class="string">&quot;Got unchecked and undeclared exception which called by &quot;</span> + RpcContext.getContext().getRemoteHost() + <span class="string">&quot;. service: &quot;</span> + invoker.getInterface().getName() + <span class="string">&quot;, method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, exception: &quot;</span> + exception.getClass().getName() + <span class="string">&quot;: &quot;</span> + exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line"><span class="comment">// directly throw if exception class and interface class are in the same jar file.</span></span><br><span class="line">String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());</span><br><span class="line">String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());</span><br><span class="line"><span class="keyword">if</span> (serviceFile == <span class="keyword">null</span> || exceptionFile == <span class="keyword">null</span> || serviceFile.equals(exceptionFile)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// directly throw if it&#x27;s JDK exception</span></span><br><span class="line">String className = exception.getClass().getName();</span><br><span class="line"><span class="keyword">if</span> (className.startsWith(<span class="string">&quot;java.&quot;</span>) || className.startsWith(<span class="string">&quot;javax.&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directly throw if it&#x27;s dubbo exception</span></span><br><span class="line"><span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherwise, wrap with RuntimeException and throw back to the client</span></span><br><span class="line">appResponse.setException(<span class="keyword">new</span> RuntimeException(StringUtils.toString(exception)));</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>即Dubbo在遇到异常时会这样处理：</p>
<ul>
<li>非RuntimeException不处理，直接返回</li>
<li>抛出的是方法上注明的异常，直接返回</li>
<li>如果异常类和接口类在同一jar包，直接返回</li>
<li>java或者javax目录下的异常类，直接返回</li>
<li>Dubbo自带的RpcException，直接返回</li>
<li>其他的异常，会被封装为RuntimeException返回</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>根据以上的分析，那么很显然，自定义异常是被直接封装为RuntimeException返回了，而且只带了自定义异常的类名信息，丢失了别的细节。</p>
<p>那么我们想要自定义异常进行正常返回，那只有满足这个FIlter所写的上述条件。我们可以分析一下：</p>
<ul>
<li><p>不继承RuntimeException，以检查时异常抛出。<strong>不推荐，正常的业务异常应该是运行时异常。</strong></p>
</li>
<li><p>在接口方法上要写上throws BusinessException，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">DemoUser <span class="title">getUserInfo</span><span class="params">(Long userID)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不推荐，不符合接口设计原则，且这样是把运行时异常作为检查时异常处理。</strong></p>
</li>
<li><p>把自定义异常类和接口放在同一个包目录下。<strong>不推荐，毕竟这样相当于绑定了异常类的目录，耦合性变高。</strong></p>
</li>
<li><p>改包名，以“java.”或者“javax.”来开头。<strong>不推荐，违反了类命名原则。</strong></p>
</li>
<li><p>继承Dubbo的RpcException。RpcException也是继承了RuntimeException，因此能够以RuntimeException的方式进行处理。<strong>不推荐，相当于自定义异常属于Dubbo的RpcException，这在程序设计上不合理。</strong></p>
</li>
</ul>
<p>我们发现，想要满足Dubbo的过滤器直接返回异常的条件，我们就必须做出一些违反程序设计的操作，如果一定要从这些方法中选择一种的话，相对来说，<strong>自定义异常类和接口放在同一目录下，以及继承RpcException</strong>是对于程序侵入性更小的方式。</p>
<h3 id="其他解决方式"><a href="#其他解决方式" class="headerlink" title="其他解决方式"></a>其他解决方式</h3><p>参考 <a href="https://blog.csdn.net/yangzaizi/article/details/80638306">这篇文章</a>，提供了两种解决方式：</p>
<p>1.在配置文件中配置如下，效果是：关闭ExceptionFIlter，使所有异常绕过该过滤器直接返回。<strong>不推荐，Dubbo既然设置了这个异常过滤类，一定是出于安全和功能上的考虑，直接禁用可能会引发别的问题。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">provider:</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">-exception</span></span><br></pre></td></tr></table></figure>

<p>2.修改Dubbo源文件ExceptionFilter，使其遇到BusinessException也能直接返回。<strong>不推荐，相当于定制了本地的Dubbo包，是一个后续很容易被人忽略的大坑。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dubbo在处理自定义异常时，会直接返回RuntimeException，且抹去自定义异常的所有细节，导致无法处理。</p>
<p>本文写下的时候，Dubbo版本为2.7.3，该问题还没有非常完美的解决方案，相对来说，把<strong>自定义异常和接口类放在同一目录下</strong>是侵入性最小的方案。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>用ssh加密文件</title>
    <url>/2021/12/06/tech/%E7%94%A8ssh%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://www.agwa.name/blog/post/ssh_signatures">Andrew Ayer博客</a><br>翻译水平不佳，自己学习使用</p>
<hr>
<h2 id="现在可以使用SSH密钥给任意数据加密"><a href="#现在可以使用SSH密钥给任意数据加密" class="headerlink" title="现在可以使用SSH密钥给任意数据加密"></a>现在可以使用SSH密钥给任意数据加密</h2><p>你知道吗，你可以使用ssh-keygen命令加密和验证任意数据，比如文件和发行软件？尽管这个特性并不是特别新（在2019年随着OpenSSH 8.0发布），依然很少有人知道。<br>这就有点尴尬，因为这个功能非常有用而且可以作为PGP的有效替换用以加密数据。如果你现在在用PGP加密数据，你可以考虑转到SSH签名上。</p>
<p>以下是我喜欢用SSH签名的原因：</p>
<ul>
<li><strong>不是PGP。</strong> 多年来，安全专家已经<a href="https://latacora.micro.blog/2019/07/16/the-pgp-problem.html">对PGP做出了警告</a>，包括其最重要的组件GnuPG/GPG。<br>PGP太复杂了，用户体验非常糟糕，而且充斥着门槛很高的粗糙老旧的密码学原理，</li>
<li><strong>SSH无处不在，而且用户早就有SSH密钥了。</strong> 如果你用的是 Debian Bullseye 或者 Ubuntu 20.04以及更新的版本，你已经有了足够的SSH安装版本。如果你有用Github，<br>或者任何其他的借助SSH命令来验证的服务，你也早就有了一个SSH密钥用于创建签名了。这就是为什么我对SSH签名更热衷，而不是其他PGP的替代品，比如<a href="https://github.com/aperezdc/signify">signify</a> 或者<br><a href="https://jedisct1.github.io/minisign/">minisign</a>。后两者很优秀，但是需要你安装新的软件和创建一个新的密钥，这就会阻碍更大范围的兼容性。</li>
<li><strong>SSH密钥很容易分配。</strong> SSH公钥只用一行代码就可以轻松到处复制。你不需要网络白名单或者费心去配置密钥的”信任等级”。Github作为一个密钥分配服务早就演示过，比起原先的<br>PGP密钥服务器更加简易也更加安全。你可以通过访问网页<a href="https://github.com/USERNAME.keys%E5%8E%BB%E6%A3%80%E7%B4%A2%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%9A%84SSH%E5%85%AC%E9%92%A5%E3%80%82%EF%BC%88%E6%AF%94%E5%A6%82%EF%BC%8C%E6%88%91%E7%9A%84%E5%85%AC%E9%92%A5%E5%9C%A8[https://github.com/AGWA.keys](https://github.com/AGWA.keys)%EF%BC%89">https://github.com/USERNAME.keys去检索任意用户的SSH公钥。（比如，我的公钥在[https://github.com/AGWA.keys](https://github.com/AGWA.keys)）</a><br>（这个例子可能不适用于所有的情况，毕竟Github在这里作为一个可信任的第三方，而且你也必须相信他们不会对大众的公钥作假。但是依赖于Github这样的专业安全团队作为可信赖的第三方，应该比几乎不可能用到的PGP的网络白名单更好。<br>在实践中，如果你曾经想搞清楚如何审核透明度日志，那第三方的公钥的透明度需要考虑进去。）</li>
<li><strong>SSH有可选的轻量级证书。</strong> SSH证书不是必需的（而且大部分人也用不到），但是证书可以让你的操作更轻松，SSH有一套比X.509简单很多的轻量级证书系统。这使得SSH签名和S/MIME一样是一个好的选项。</li>
</ul>
<h2 id="你现在可以使用SSH给Git提交和标签加签名"><a href="#你现在可以使用SSH给Git提交和标签加签名" class="headerlink" title="你现在可以使用SSH给Git提交和标签加签名"></a>你现在可以使用SSH给Git提交和标签加签名</h2><p>给Git的提交和标签加签名可以帮助你确认你的的仓库在被别人使用的时候，代码未曾被篡改。但是，你必须用PGP或者S/MIME来做到这件事，而我个人从2018年PGP密钥过期后就没在这件事上被困扰过。<br>马上在Git 2.34这些都会改变了，这个版本支持了SSH签名。（TODO 咋翻译都不对。。）</p>
<h2 id="文件签名"><a href="#文件签名" class="headerlink" title="文件签名"></a>文件签名</h2><p>像这样直接对一个文件进行签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -Y sign -f ~/.ssh/id_ed25519 -n file file_to_sign</span><br></pre></td></tr></table></figure>
<p>需要更改的参数如下：</p>
<ul>
<li><p><code>~/.ssh/id_ed25519</code>是你私钥的路径。例子里的是你的SSH Ed25519私钥的标准路径。如果你有一个RSA密钥，改为使用id_rsa。</p>
</li>
<li><p><code>file</code> 参数是”命名空间”，用来描述签名的目的，对于一般文件的签名，SSH将其定义为<code>file</code>，邮件的签名定义为<code>email</code>，Git则使用<code>git</code>作为签名。<br>如果你的签名用于其他目的，比如一个一般协议，你必须指明你自己的命名空间。这样，你可以避免来自一个单一协议信息的合法签名被移除后，或者附属在不同的协议信息，发起的跨协议攻击。<br>如果对于协议签名不使用特定的命名空间，那第一个协议的签名就有可能被视作第二个签名的协议，从而被认为是合法的。<br>命名空间可以是随机字符。为了保证全局的命名空间的唯一性，SSH推荐对于你自己的签名使用email作为命名空间的一部分。比如，我会使用类似于<code>protocolname-v1@agwa.name</code>的名字作为命名空间。</p>
</li>
<li><p><code>file_to_sign</code> 是要被签名的文件的路径。</p>
</li>
</ul>
<p>签名会写入一个叫做<code>file_to_sign.sig</code>的新文件中，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----BEGIN SSH SIGNATURE-----</span><br><span class="line">U1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAg2rirQQddpzEzOZwbtM0LUMmlLG</span><br><span class="line">krl2EkDq4CVn/Hw7sAAAAEZmlsZQAAAAAAAAAGc2hhNTEyAAAAUwAAAAtzc2gtZWQyNTUx</span><br><span class="line">OQAAAEDyjWPjmOdG8HJ8gh1CbM8WDDWoGfm+TTd8Qa8eua9Bt5Cc+43S24i/JqVWmk98qV</span><br><span class="line">YXoQmOYL4bY8t/q7cSNeMH</span><br><span class="line">-----END SSH SIGNATURE----- </span><br></pre></td></tr></table></figure>
<p>如果你指明了文件名，那文件签名会从该标准输入并从该标准写出。</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>签名验证稍微更复杂点。首先你需要创建一个被允许的签名者文件，该文件将邮件地址映射到公钥，类似于这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alice@example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINq4q0EHXacxMzmcG7TNC1DJpSxpK5dhJA6uAlZ/x8O7</span><br><span class="line">alice@example.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfHGCK5jjI/Oib4vRBLB9rG30A8y/Br9U75rfAYsitwFPFfl/CaTAvfRlW1lIBqOCshLWxGsN+PFiJCiCWzpW4iILkD5X5KcBBYHTq1ojYXb70BrQXQ+QBDcGxqQjcOp/uTq1D9Z82mYq/usI5wdz6f1KNyqM0J6ZwRXMu6u7NZaAwmY7j1fV4DRiYdmIfUDIyEdqX4a1Gan+EMSanVUYDcNmeBURqmTkkOPYSg8g5xYgcXBMOZ+V0ZUjreV9paKraUD/mVDlZbb/VyWhJGT4FLMNXHU6UHC2FFgqANMUKIlL4vhqc23MoygKbfF3HgNB6BNfv3s+GYlaQ3+66jc5j</span><br><span class="line">bob@example.net ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBgQuuEvhUXerOTIZ2zoOx60M/HHJ/tcHnD84ZvTiX5b</span><br></pre></td></tr></table></figure>
<p>一旦你拥有了你的被允许的签名文件，验证的步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -Y verify -f allowed_signers -I alice@example.com -n file -s file_to_verify.sig &lt; file_to_verify</span><br></pre></td></tr></table></figure>
<p>你需要修改如下参数：</p>
<ul>
<li><code>allowed_signers</code> 是被允许的签名者文件的路径。</li>
<li><code>alice@example.com</code> 是对文件加签名的用户邮件地址。该邮件地址会在允许的签名者文件里进行查找到对应的公钥。</li>
<li><code>file</code> 是”命名空间”，该参数必须匹配前文描述的签名中的命名空间。</li>
<li><code>file_to_verify.sig</code> 是签名文件的路径。</li>
<li><code>file_to_verify</code> 是被验证的文件的路径。注意该文件是从标准读入的。在前面的命令中，<code>&lt;</code>这个shell操作符用于重定向标准到该文件。</li>
</ul>
<p>如果签名是有效的，命令行会返回状态0并打印如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Good <span class="string">&quot;file&quot;</span> signature <span class="keyword">for</span> alice@example.com with ED25519 key SHA256:ZGa8RztddW4kE2XKPPsP9ZYC7JnMObs6yZzyxg8xZSk</span><br></pre></td></tr></table></figure>
<p>否则，命令行会返回非0状态并打印错误信息。</p>
<h2 id="SSH密钥的复用安全吗？"><a href="#SSH密钥的复用安全吗？" class="headerlink" title="SSH密钥的复用安全吗？"></a>SSH密钥的复用安全吗？</h2><p>简单来说：安全。</p>
<p>对一个不同协议总是要小心的对密钥进行复用。如果不注意的话，有可能导致跨协议攻击的风险。比如，当一个Git签名信息的结构和SSH协议信息的结构相似，攻击者就可以通过SSH副本挪用签名，并伪造一个Git的人工提交。</p>
<p>幸运的是，SSH协议信息的结构和ssh-keygen签名信息的结构并不相似，因此并没有这方面风险的担忧。</p>
<p>为了证明这点，我们可以参考这篇<a href="https://datatracker.ietf.org/doc/html/rfc4252#section-7">RFC 4252 section 7</a>，阐明了SSH密钥是如何在传统用途上通过SSH验证用户登录服务器。<br>RFC指出输入的签名语法拥有如下结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string    session identifier</span><br><span class="line">byte      SSH_MSG_USERAUTH_REQUEST</span><br><span class="line">string    user name</span><br><span class="line">string    service name</span><br><span class="line">string    <span class="string">&quot;publickey&quot;</span></span><br><span class="line">boolean   TRUE</span><br><span class="line">string    public key algorithm name</span><br><span class="line">string    public key to be used <span class="keyword">for</span> authentication</span><br></pre></td></tr></table></figure>
<p>第一个字段是会话标识，是个字符串。在SSH协议中，字符串的前缀由一个<a href="https://datatracker.ietf.org/doc/html/rfc4251#section-5">32位字符</a>构成。会话标识是一个<a href="https://datatracker.ietf.org/doc/html/rfc4253#section-7.2">hash</a>值。除非hash值很短，否则一般的上述签名的前三位字符都会是0。</p>
<p>同时，<a href="https://github.com/openssh/openssh-portable/blob/d575cf44895104e0fcb0629920fb645207218129/PROTOCOL.sshsig">PROTOCOL.sshsig</a>分发OpenSSH仓库，表明了如何通过<code>ssh-keygen-generated</code>签名使用SSH密钥。以下是输入的签名语法的结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define MAGIC_PREAMBLE &quot;SSHSIG&quot;</span></span><br><span class="line"></span><br><span class="line">byte[6]   MAGIC_PREAMBLE</span><br><span class="line">string    namespace</span><br><span class="line">string    reserved</span><br><span class="line">string    hash_algorithm</span><br><span class="line">string    H(message)</span><br></pre></td></tr></table></figure>
<p>在这里，头三个字节是SSH，来自magic preamble（直译是魔法序言？）。SSH协议签名输入的头三个字节之后就开始和ssh-keygen签名输入不一样，SSH客户端和ssh-keygen不会生成同样的签名。因此，在这里不会有跨协议攻击的风险，我也有绝对的信心使用现存的SSH密钥，通过ssh-keygen来对信息加密。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次用代码分辨坑爹保险产品的经历</title>
    <url>/2021/11/19/tech/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E8%BE%A8%E5%9D%91%E7%88%B9%E4%BF%9D%E9%99%A9%E4%BA%A7%E5%93%81%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>这两天刚好一年交一次的保险开始催我交年费，最近由于基金太绿，手头实在有点紧，因此这个年费一直拖着还没交，于是我动了是不是要退保的想法。</p>
<p>而销售则继续去年的话术，说我这个交满20年就可以不交了，现在交到12年退保太可惜了之类的。</p>
<p>今年我没有轻易把这话听进去，于是我又去搜了下这个保险产品的条例，这个产品的介绍如下图。<br><img src="/2021/11/19/tech/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E8%BE%A8%E5%9D%91%E7%88%B9%E4%BF%9D%E9%99%A9%E4%BA%A7%E5%93%81%E7%9A%84%E7%BB%8F%E5%8E%86/1.png"></p>
<p>按照我当前的情况，排除意外身故的情况，简单概括下就是：</p>
<ul>
<li>我每年交7600，交20年</li>
<li>到66岁每两年领一次总保额(总保额是50000)的8%，我这份产品从19岁开始买，到66岁总共可以领23次</li>
<li>66岁一次性给100%全保额</li>
<li>66岁开始每年领一次总保额的8%，我假设我能活到88岁，那总共领22次<span id="more"></span></li>
</ul>
<h2 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h2><p>剔除别的因素，最简单的加减算法就是</p>
<ul>
<li>交的保费是20*7600 = 152000</li>
<li>到66岁每两年领一次8%，领23次，那就是23*(50000*0.08)=92000</li>
<li>66岁一次性领100%总保额，就是50000</li>
<li>66-88岁每年领一次8%，领22次，22*(50000*0.08)=88000<br>简单说来总保费是 <strong>152000</strong>，<strong>最后收益是230000</strong></li>
</ul>
<p>其实就算是这么简单的计算，也会发现这是一份很坑的产品，230000的最终收益前提是要活到88岁。而我在39岁就会交完152000的总保费，相当于从39岁<br>到88岁之间的49年时间，这份产品只帮我赚到了8万的收益，如果换算成一个理财产品的话，那这份产品的年收益是可怜的0.9%……</p>
<p>我感觉已经不用分析了，这破产品分析到这已经是垃圾中的战斗机了啊。</p>
<p>但是不行，我还要继续分析，因为如果考虑到通货膨胀率之类的东西，我得出的结论是，买这个产品，甚至收益完全是负的。。。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>之前的分析还是有点粗浅的，如果仔细分析的话其实还需要考虑至少下面几点</p>
<ul>
<li>产品分红会每年加到总保额里，每年收益应当是(50000+分红)*0.08</li>
<li>钱是会通货膨胀的，今年给你的收益4000，到明年就不值4000了</li>
<li>同样的因为通货膨胀，你今年交的保费7600，到明年可能就不值7600了</li>
</ul>
<p>我直接上代码解决吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countInsuranceIncome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> eachYearOut = <span class="number">7600</span>;<span class="comment">//每年缴纳费用</span></span><br><span class="line">    <span class="keyword">let</span> eachYearRate = <span class="number">0.08</span>;<span class="comment">//年金率</span></span><br><span class="line">    <span class="keyword">let</span> inflationRate = <span class="number">0.05</span>;<span class="comment">//每年通胀率</span></span><br><span class="line">    <span class="keyword">let</span> eachYearIncreaseRate = <span class="number">0.01</span>;<span class="comment">//每年获得分红率</span></span><br><span class="line">    <span class="keyword">let</span> allMoney = <span class="number">50000</span>;<span class="comment">//总保额</span></span><br><span class="line">    <span class="keyword">let</span> allOut = <span class="number">0</span>;<span class="comment">//总支出</span></span><br><span class="line">    <span class="keyword">let</span> allIn = <span class="number">0</span>;<span class="comment">//总收入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第二年开始算通胀</span></span><br><span class="line">            eachYearOut = eachYearOut * (<span class="number">1</span>-inflationRate);</span><br><span class="line">        &#125;</span><br><span class="line">        allOut = allOut + eachYearOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到66岁每两年领一次8%</span></span><br><span class="line">    <span class="comment">// 总共领23次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">23</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> rate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第二年开始算通胀</span></span><br><span class="line">            rate = <span class="number">1</span> + eachYearIncreaseRate - inflationRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总保额每年变化，由于是两年一次，所以乘两次</span></span><br><span class="line">        allMoney = allMoney * rate * rate;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次计算得总保额为&quot;</span> + allMoney.toFixed(<span class="number">2</span>));</span><br><span class="line">        allIn = allMoney * eachYearRate + allIn;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次年金为&quot;</span> + (allMoney * eachYearRate).toFixed(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 66岁一次性给100%</span></span><br><span class="line">    allIn = allIn + allMoney;</span><br><span class="line">    <span class="comment">//66岁开始假设活到88岁，每年领一次8%</span></span><br><span class="line">    <span class="comment">//总共领22次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">22</span>; i++) &#123;</span><br><span class="line">        allIn = allMoney * (<span class="number">1</span> + eachYearIncreaseRate - inflationRate) * eachYearRate + allIn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;总共支出&#x27;</span> + allOut.toFixed(<span class="number">2</span>) + <span class="string">&#x27;，总共收入&#x27;</span> + allIn.toFixed(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑基本上就是把我列的条件都写进去了，不多解释，总之最后的计算结果非常让我震惊。<br>假设从今年开始买这个产品，基于当前物价水平</p>
<ul>
<li>基于5%的通胀率，1%的分红率</li>
<li>付出<strong>97510.14</strong>元</li>
<li>收益<strong>65532.89</strong>元 </li>
<li>收益 <strong>-31977.25</strong>元</li>
</ul>
<p>也就是说考虑到通货膨胀，拉长到将近70年的周期，这份产品最终是让你倒亏3万多。<br>而通胀率我设置的其实不算高，5%算是偏低水平，1%的每年分红率我甚至还比现实更高。而且现实中也基本不太可能每年保持1%的分红率，如果调整成6%的通胀率，和0.9%的分红率，</p>
<ul>
<li>基于6%的通胀率，0.9%的分红率</li>
<li>付出<strong>89919.88</strong>元</li>
<li>收益<strong>49962.45</strong>元</li>
<li>收益 <strong>-39957.43</strong>元</li>
</ul>
<p>不得不说，算还是保险公司会算，你乍一看，只要交20年，然后长达70年给你持续分红和年金，似乎怎么想都是划算的，而且分红方式还按照不固定的分红增长，给人以更大的迷惑性。<br>让你如果不依靠专业的工具，自己根本算不清楚，只能任保险公司鱼肉。</p>
<p>最后，如果想要这份产品能够盈利，那最低条件是通胀率要小于等于3%，且年均分红率要稳定在1%，这样70年后能够血赚2000。。。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-Redis设计与实现-PartI</title>
    <url>/2022/07/05/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartI/</url>
    <content><![CDATA[<h2 id="1-SDS（Simple-Dynamic-String，简单动态字符串）"><a href="#1-SDS（Simple-Dynamic-String，简单动态字符串）" class="headerlink" title="1.SDS（Simple Dynamic String，简单动态字符串）"></a>1.SDS（Simple Dynamic String，简单动态字符串）</h2><ul>
<li>SDS获取字符串长度复杂度为O(1)，C字符串为O(N)<ul>
<li>SDS额外保存了一个len字段用于记录字符串长度，因此可以直接获取</li>
<li>C字符串需要遍历整个字符串，直到遇到空字符为止</li>
</ul>
</li>
<li>SDS可以防止字符串缓冲区溢出，C字符串不能<ul>
<li>C由于不记录自身长度，因此每次增加字符串长度时，会假设内存已经分配，如果假设不成立，就会溢出</li>
<li>SDS额外保存了一个free字段用于记录剩余内存空间，不足时会先进行空间扩展</li>
</ul>
</li>
<li>SDS可以减少修改字符串时带来的内存重分配次数<ul>
<li>SDS的free字段帮助实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略</li>
</ul>
</li>
<li>SDS可以处理二进制数据，C字符串不能<ul>
<li>原因是C字符串的最后一位是空字符，且C语言通过空字符判断字符串的结束，导致某些包含空字符格式的数据无法正确处理</li>
<li>SDS虽然也保留了最后一位空字符的特性，但是通过len属性判断字符是否结束，因此可以保存各种数据</li>
</ul>
</li>
<li>SDS保留最后一位空字符特性的好处是可以直接调用某些C字符串函数</li>
</ul>
<span id="more"></span>

<h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><ul>
<li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等</li>
<li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表</li>
<li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表</li>
<li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值</li>
</ul>
<h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h2><ul>
<li>Redis底层数据库由字典实现</li>
<li>也可作为redis哈希键的实现</li>
<li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</li>
<li>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li>
<li>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用<strong>MurmurHash2</strong>算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</li>
</ul>
<h2 id="4-跳跃表（skiplist）"><a href="#4-跳跃表（skiplist）" class="headerlink" title="4.跳跃表（skiplist）"></a>4.跳跃表（skiplist）</h2><ul>
<li>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</li>
<li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点</li>
<li>每个跳跃表节点的层高都是1至32之间的随机数</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的</li>
<li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序</li>
</ul>
<h2 id="5-整数（intset）"><a href="#5-整数（intset）" class="headerlink" title="5.整数（intset）"></a>5.整数（intset）</h2><ul>
<li>整数集合是集合键的底层实现之一</li>
<li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型</li>
<li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存<ul>
<li>类型为int16_t、int32_t或者int64_t的整数值，默认按照能存下当前数组的最小类型存储</li>
<li>当新的元素比当前存储的整数类型要大时，进行类型升级，同时将数组内的所有数也升级，然后内存空间再进行重排</li>
</ul>
</li>
<li>整数集合只支持升级操作，不支持降级操作</li>
</ul>
<h2 id="6-压缩列表（ziplist）"><a href="#6-压缩列表（ziplist）" class="headerlink" title="6.压缩列表（ziplist）"></a>6.压缩列表（ziplist）</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</li>
</ul>
<h2 id="7-对象"><a href="#7-对象" class="headerlink" title="7.对象"></a>7.对象</h2><ul>
<li>Redis数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis会共享值为0到9999的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-Redis设计与实现-PartII</title>
    <url>/2022/07/06/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartII/</url>
    <content><![CDATA[<h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><ul>
<li>服务器默认创建16个数据库，该数量由服务器配置的database选项决定。</li>
<li>通过select 0/1/2…命令进行切换数据库，redis没有返回当前目标数据库的命令，因此在进行整库操作时，最好先通过select命令切换到目标数据库</li>
<li>通过expire或者pexpire来对某个键设置过期时间，ttl查询剩余过期时间<ul>
<li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。</li>
<li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。</li>
<li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</li>
<li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</li>
<li>PERSIST命令可以移除一个键的过期时间</li>
</ul>
</li>
<li>过期键删除策略<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ul>
</li>
<li>数据库通知<ul>
<li>数据库通知是Redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</li>
<li>关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification）</li>
<li>键事件通知（key-event notification）的通知，它们关注的是“某个命令被什么键执行了”</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>
</li>
<li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
</ul>
<span id="more"></span>

<h2 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.RDB持久化"></a>2.RDB持久化</h2><ul>
<li>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态</li>
<li>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE<ul>
<li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li>
<li>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li>
</ul>
</li>
<li>AOF文件的更新频率通常比RDB文件的更新频率高<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态</li>
</ul>
</li>
<li>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</li>
<li>服务器每隔一段时间自动执行一次BGSAVE命令，只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行：<ul>
<li>服务器在900秒之内，对数据库进行了至少1次修改。</li>
<li>服务器在300秒之内，对数据库进行了至少10次修改。</li>
<li>服务器在60秒之内，对数据库进行了至少10000次修改</li>
</ul>
</li>
<li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间</li>
<li>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次</li>
<li>RDB文件结构<ul>
<li>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件</li>
<li>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版</li>
<li>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据<ul>
<li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li>
<li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同</li>
</ul>
</li>
<li>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了</li>
<li>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现</li>
</ul>
</li>
<li>使用od -cx dump.rdb 命令对RDB文件进行分析。</li>
</ul>
<h2 id="3-AOF（Append-Only-File）持久化"><a href="#3-AOF（Append-Only-File）持久化" class="headerlink" title="3.AOF（Append Only File）持久化"></a>3.AOF（Append Only File）持久化</h2><ul>
<li>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过<strong>保存Redis服务器所执行的写命令</strong>来记录数据库状态的<ul>
<li>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</li>
<li>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</li>
</ul>
</li>
<li>实现步骤<ul>
<li>命令追加：服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</li>
<li>AOF文件的写入与同步：服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</li>
</ul>
</li>
<li>三种持久化策略：<ul>
<li>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件</li>
<li>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且<strong>每隔一秒</strong>就要在子线程中对AOF文件进行一次同步</li>
<li>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制</li>
</ul>
</li>
<li>AOF重写，用以解决AOF文件快速膨胀的问题，通过将多个命令合并为一条来实现</li>
</ul>
<h2 id="4-事件"><a href="#4-事件" class="headerlink" title="4.事件"></a>4.事件</h2><ul>
<li>文件事件<ul>
<li>服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>文件事件处理器以<strong>单线程</strong>方式运行，但通过使用I/O多路复用程序来监听多个套接字<br><img src="/2022/07/06/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartII/redis-event1.png"></li>
<li>如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字</li>
<li>文件事件处理器是基于Reactor模式实现的网络通信程序</li>
<li>文件事件分为AE_READABLE事件（读事件）和AE_WRITABLE事件（写事件）两类。</li>
</ul>
</li>
<li>时间事件<ul>
<li>Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
<li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。</li>
<li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</li>
<li>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器</li>
</ul>
</li>
<li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占</li>
<li>时间事件的实际处理时间通常会比设定的到达时间晚一些。(原因是redis单线程处理，时间事件未到达时会先处理文件事件)</li>
</ul>
<h2 id="5-客户端"><a href="#5-客户端" class="headerlink" title="5.客户端"></a>5.客户端</h2><ul>
<li>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。</li>
<li>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。</li>
<li>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。</li>
<li>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。</li>
<li>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。</li>
<li>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。</li>
<li>当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。</li>
<li>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。</li>
<li>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</li>
</ul>
<h2 id="6-服务器"><a href="#6-服务器" class="headerlink" title="6.服务器"></a>6.服务器</h2><ul>
<li>一个命令请求从发送到完成主要包括以下步骤：<ul>
<li>客户端将命令请求发送给服务器；</li>
<li>服务器读取命令请求，并分析出命令参数；</li>
<li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；</li>
<li>服务器将命令回复返回给客户端。</li>
</ul>
</li>
<li>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。</li>
<li>服务器从启动到能够处理客户端的命令请求需要执行以下步骤：<ul>
<li>初始化服务器状态；</li>
<li>载入服务器配置；</li>
<li>初始化服务器数据结构；</li>
<li>还原数据库状态；</li>
<li>执行事件循环。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-Redis设计与实现-PartIII</title>
    <url>/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/</url>
    <content><![CDATA[<h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1.复制"></a>1.复制</h2><ul>
<li>通过SLAVEOF命令让一个服务器复制另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）</li>
</ul>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 服务器127.0.0.1:12345将成为127.0.0.1:6379的从服务器</span></span><br><span class="line">127.0.0.1:123456&gt; SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
<ul>
<li>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”</li>
<li>旧版复制（2.8版本之前）<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态<ul>
<li>从服务器向主服务器发送SYNC命令。</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态<br><img src="/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/redis-replicate1.png"></li>
</ul>
</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态<ul>
<li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态</li>
</ul>
</li>
<li>缺点<ul>
<li>断线后复制会重新执行sync命令，但是传输的rdb文件有可能大部分都是曾经同步过的，这会造成效率低下</li>
<li>本身sync命令就是非常耗费资源<ul>
<li>主服务器需要执行BGSAVE命令会耗费主服务器大量的CPU、内存和磁盘I/O资源。</li>
<li>主服务器需要将自己生成的RDB文件发送给从服务器会耗费主从服务器大量的网络资源（带宽和流量）</li>
<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>新版复制（2.8版本开始）<ul>
<li>PSYNC命令代替SYNC命令来执行复制时的同步操作<ul>
<li>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）</li>
<li>完整重同步用于处理初次复制情况，和sync命令一样</li>
<li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</li>
</ul>
</li>
<li>部分重同步的实现<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的</li>
</ul>
</li>
<li>主服务器的复制积压缓冲区（replication backlog）。<ul>
<li>主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</li>
<li>为了安全起见，可以将复制积压缓冲区的大小设为2<em>second</em>write_size_per_second，这样可以保证绝大部分断线情况都能用部分重同步来处理</li>
</ul>
</li>
<li>服务器的运行ID（run ID）<ul>
<li>每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID</li>
<li>根据运行ID是否相同，从服务器决定进行部分还是完整重同步操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PSYNC命令的执行逻辑<br>  <img src="/2022/07/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIII/redis-sync1.png"></li>
<li>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测</li>
</ul>
<h2 id="2-哨兵（Sentinel）"><a href="#2-哨兵（Sentinel）" class="headerlink" title="2.哨兵（Sentinel）"></a>2.哨兵（Sentinel）</h2><ul>
<li>哨兵（Sentinel）实例监视主从服务器状态，如果主服务器下线，哨兵会选择一个从服务器升级为主服务器<ul>
<li>Sentinel系统会挑选其中一个从服务器升级为新的主服务器。</li>
<li>Sentinel系统会向所有从服务器发送新的复制指令，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕</li>
<li>监视已下线的server1，重新上线时，设置为从服务器</li>
</ul>
</li>
<li>启动命令<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 执行以下两条命令之一</span></span><br><span class="line">$ redis-sentinel sentinel.conf</span><br><span class="line">$ redis-server sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></li>
<li>Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。</li>
<li>在一般情况下，Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。</li>
<li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在。</li>
<li>每个Sentinel也会从__sentinel__:hello频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。</li>
<li>Sentinel只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel与Sentinel之间则只创建命令连接。</li>
<li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时，Sentinel会将这个实例判断为主观下线。</li>
<li>当Sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。</li>
<li>当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</li>
</ul>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3.集群"></a>3.集群</h2><ul>
<li>节点通过握手来将其他节点添加到自己所处的集群当中。</li>
<li>集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。</li>
<li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li>
<li>对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。</li>
<li>如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。</li>
<li>MOVED错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。❑集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li>
<li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-Redis设计与实现-PartIV</title>
    <url>/2022/07/08/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-PartIV/</url>
    <content><![CDATA[<h2 id="1-发布与订阅"><a href="#1-发布与订阅" class="headerlink" title="1.发布与订阅"></a>1.发布与订阅</h2><ul>
<li>服务器状态在pubsub_channels字典保存了所有频道的订阅关系：SUBSCRIBE命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。</li>
<li>服务器状态在pubsub_patterns链表保存了所有模式的订阅关系：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。</li>
<li>PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。</li>
<li>PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。</li>
</ul>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h2><ul>
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。</li>
<li>带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。</li>
<li>只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。</li>
<li>Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</li>
</ul>
<h2 id="3-Lua脚本"><a href="#3-Lua脚本" class="headerlink" title="3.Lua脚本"></a>3.Lua脚本</h2><ul>
<li>Redis服务器在启动时，会对内嵌的Lua环境执行一系列修改操作，从而确保内嵌的Lua环境可以满足Redis在功能性、安全性等方面的需要。</li>
<li>Redis服务器专门使用一个伪客户端来执行Lua脚本中包含的Redis命令。</li>
<li>Redis使用脚本字典来保存所有被EVAL命令执行过，或者被SCRIPT LOAD命令载入过的Lua脚本，这些脚本可以用于实现SCRIPT EXISTS命令，以及实现脚本复制功能。</li>
<li>EVAL命令为客户端输入的脚本在Lua环境中定义一个函数，并通过调用这个函数来执行脚本。</li>
<li>EVALSHA命令通过直接调用Lua环境中已定义的函数来执行脚本。</li>
<li>SCRIPT FLUSH命令会清空服务器lua_scripts字典中保存的脚本，并重置Lua环境。</li>
<li>SCRIPT EXISTS命令接受一个或多个SHA1校验和为参数，并通过检查lua_scripts字典来确认校验和对应的脚本是否存在。</li>
<li>SCRIPT LOAD命令接受一个Lua脚本为参数，为该脚本在Lua环境中创建函数，并将脚本保存到lua_scripts字典中。</li>
<li>服务器在执行脚本之前，会为Lua环境设置一个超时处理钩子，当脚本出现超时运行</li>
</ul>
<h2 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h2><ul>
<li>SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作。</li>
<li>在默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序。</li>
<li>如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串的方式来进行排序。</li>
<li>SORT命令的排序操作由快速排序算法实现。</li>
<li>SORT命令会根据用户是否使用了DESC选项来决定是使用升序对比还是降序对比来比较被排序的元素，升序对比会产生升序排序结果，被排序的元素按值的大小从小到大排列，降序对比会产生降序排序结果，被排序的元素按值的大小从大到小排列。</li>
<li>当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作。</li>
<li>当SORT命令使用了LIMIT选项时，命令只保留排序结果集中LIMIT选项指定的元素。</li>
<li>当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素。</li>
<li>当SORT命令使用了STORE选项时，命令会将排序结果集保存在指定的键里面。</li>
<li>当SORT命令同时使用多个选项时，命令先执行排序</li>
</ul>
<h2 id="5-二进制位数组"><a href="#5-二进制位数组" class="headerlink" title="5.二进制位数组"></a>5.二进制位数组</h2><ul>
<li>Redis使用SDS来保存位数组。</li>
<li>SDS使用逆序来保存位数组，这种保存顺序简化了SETBIT命令的实现，使得SETBIT命令可以在不移动现有二进制位的情况下，对位数组进行空间扩展。</li>
<li>BITCOUNT命令使用了查表算法和variable-precision SWAR算法来优化命令的执行效率。</li>
<li>BITOP命令的所有操作都使用C语言内置的位操作来实现。</li>
</ul>
<h2 id="6-慢查询日志"><a href="#6-慢查询日志" class="headerlink" title="6.慢查询日志"></a>6.慢查询日志</h2><ul>
<li>Redis的慢查询日志功能用于记录执行时间超过指定时长的命令。<ul>
<li>slowlog get</li>
</ul>
</li>
<li>Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志。</li>
<li>打印和删除慢查询日志可以通过遍历slowlog链表来完成。</li>
<li>slowlog链表的长度就是服务器所保存慢查询日志的数量。</li>
<li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除。</li>
</ul>
<h2 id="7-监视器"><a href="#7-监视器" class="headerlink" title="7.监视器"></a>7.监视器</h2><ul>
<li>客户端可以通过执行MONITOR命令，将客户端转换成监视器，接收并打印服务器处理的每个命令请求的相关信息。</li>
<li>当一个客户端从普通客户端变为监视器时，该客户端的REDIS_MONITOR标识会被打开。</li>
<li>服务器将所有监视器都记录在monitors链表中。</li>
<li>每次处理命令请求时，服务器都会遍历monitors链表，将相关信息发送给监视器。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-人类简史</title>
    <url>/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/humanhistory.jpg"></p>
<h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><h3 id="人类：一种没什么特别的动物"><a href="#人类：一种没什么特别的动物" class="headerlink" title="人类：一种没什么特别的动物"></a>人类：一种没什么特别的动物</h3><ul>
<li>在历史的路上，有三大重要革命：<ul>
<li>大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动</li>
<li>大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展</li>
<li>而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局</li>
</ul>
</li>
<li>从同一个祖先演化而来的不同物种，会属于同一个“属”（genus）<ul>
<li>生物学家用拉丁文为生物命名，每个名字由两个词组成，第一个词是属名，第二个词则是种名</li>
<li>例如狮子就称为“Pantheraleo”，指的是豹属（Panthera）的狮种（leo）</li>
</ul>
</li>
<li>许多属还能再归类为同一科（family）</li>
<li>最早的人类是从大约250万年前的东非开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）<ul>
<li>在欧洲和西亚的人类成了“Homoneanderthalensis”，意为“来自尼安德谷（NeanderValley）的人”，一般简称为“尼安德特人”（Neanderthals）</li>
<li>在东方的亚洲，住的则是“Homoerectus”（直立人），一共存续了将近200万年，是目前所知存续最久的人类物种</li>
<li>在印度尼西亚的爪哇岛，则住着“Homosoloensis”（梭罗人，拉丁文意为“来自梭罗谷的人”）</li>
<li>人类的摇篮继续养育着许多新品种，例如“Homorudolfensis”（鲁道夫人，“来自鲁道夫湖的人”）、“Homoergaster”（匠人，“工作的人”）</li>
<li>而我们也颇为厚颜地把自己命名为“Homosapiens”（智人，“明智的人”）</li>
</ul>
</li>
<li>人类不是线性发展的，在某一个时期同时存在多种人中，智人也是其中之一<ul>
<li>大脑容量大<ul>
<li>大脑结构脆弱，不利于活动</li>
<li>能耗很大，只占重量2%，却要消耗25%的能量</li>
<li>令人困惑的是，在接近200万年的时间里，大脑并没有带来显著的优势，却一直偏执的在这条路上进化</li>
</ul>
</li>
<li>直立行走<ul>
<li>手解放出来做更精细的事</li>
<li>促进了神经系统的进化</li>
<li>导致背痛，颈脖部位的酸痛</li>
</ul>
</li>
<li>人类都是早产儿<ul>
<li>促使人类成为强社交生物，因为需要群体帮助照顾幼儿</li>
</ul>
</li>
<li>用火<ul>
<li>一些本无法消化的食物变为主食（如小麦，水稻，马铃薯等）</li>
<li>食物中的病菌和寄生虫被杀死</li>
<li>咀嚼和消化时间大幅缩减</li>
<li>缩小牙齿、减少肠的长度<ul>
<li>一种说法认为，这减少了消化时所需的能量，从而使得大脑得到发育的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>长久以来，智人一直只是稳定位于食物链的中间位置，直到最近才有改变<ul>
<li>在先前长达数百万年的时间里，人类会猎杀小动物、采集种种能得到的食物，但同时也会遭到较大型肉食动物猎杀</li>
<li>一直要到40万年前，有几种人种才开始固定追捕大型猎物，而要到10万年前智人崛起，人类才一跃而居于食物链顶端</li>
<li>人类转眼就登上顶端，不仅让生态系统猝不及防，就连人类自己也不知所措</li>
</ul>
</li>
<li>智人如何成为唯一存活的人种<ul>
<li>混种繁衍理论，即智人是和其他人种互通繁衍，从而融合为同一人种</li>
<li>替代理论，即除了智人之外的其他人种灭绝了<ul>
<li>这种理论更加政治正确，毕竟世界上的人都有同样的祖先比较不会引起种族方面的讨论</li>
<li>然而目前，已经找到证据证明各个地区的人身上携带者不同远古人种的DNA</li>
</ul>
</li>
<li><strong>智人胜出的根本原因很可能是因为有独特的语言</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="知善恶树"><a href="#知善恶树" class="headerlink" title="知善恶树"></a>知善恶树</h3><ul>
<li>大约就是在距今7万到3万年前，出现了新的思维和沟通方式，这也正是所谓的<strong>认知革命</strong><ul>
<li>智人的语言并不是世界上的第一种语言。每种动物都有着某种语言。</li>
<li>最常见的理论，认为人类语言最为灵活</li>
<li>第二种理论，也同意人类语言是沟通关于世界的信息的方式。然而，最重要的信息不是关于狮子和野牛，而是关于人类自己。<strong>我们的语言发展成了一种八卦的工具</strong></li>
<li>只有智人能够表达关于从来没有看过、碰过、耳闻过的事物，而且讲得煞有其事。<strong>讨论虚构的事物”正是智人语言最独特的功能</strong></li>
</ul>
</li>
<li>社会学研究指出，借由八卦来维持的最大“自然”团体大约是150人<ul>
<li>在这个规模下，只需要靠人际关系就可以维持正常运作，而不需要什么特定的纪律约束</li>
<li>超过这个规模，就需要依靠虚构的故事。例如宗教，国家历史，法律故事等</li>
</ul>
</li>
<li><strong>所谓“想象的现实”指的是某件事人人都相信，而且只要这项共同的信念仍然存在，力量就足以影响世界</strong></li>
<li>自从认知革命之后，智人就能依据不断变化的需求迅速调整行为。这等于开启了一条采用“<strong>文化演化</strong>”的快速道路，而不再停留在“基因演化”这条总是堵车的道路上<ul>
<li>在认知革命之后，虽然智人的基因和环境都没什么改变，但智人还是能够迅速改变行为，并将新的行为方式传给下一代</li>
<li>最典型的例子，就是人类社会总会出现不生育的精英阶层</li>
<li>过去远古人类的行为模式可能维持几万年不变，但对现代智人来说，只要十几二十年，就可能改变整个社会结构、人际交往关系和经济活动<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/human1.png">   </li>
</ul>
</li>
</ul>
<h3 id="亚当和夏娃的一天"><a href="#亚当和夏娃的一天" class="headerlink" title="亚当和夏娃的一天"></a>亚当和夏娃的一天</h3><ul>
<li>演化心理学<ul>
<li>这个领域的学者认为，即使到了现在，我们的大脑和心灵都还是以狩猎和采集的生活方式在思维</li>
<li>比如爱吃甜食和高热量食物来自于祖先一辈缺乏这种摄入，因此看到这些食物就得大量摄入以免失去机会</li>
<li>一夫一妻制和”远古公社”都存在于人类社会</li>
</ul>
</li>
<li>远古的采集生活与后来的农业和工业生活相比，最明显的区别在于极少使用人造物品<ul>
<li>无法光靠现存的文物来了解远古狩猎采集生活</li>
<li>即使是在类似的生态、同样的基因组成下出现的人类，也能够创造出非常不同的想象现实，表现出来就成了不同的规范和价值观</li>
<li>从认知革命之后，智人的“自然生活方式”从来就不止一种。真正存在的只有“<strong>文化选择</strong>”</li>
</ul>
</li>
<li>在个人层面上，远古的采集者则是有史以来最具备多样知识和技能的人类<ul>
<li>等到农业和工业时代开展，人类开始能靠着别人的技能生存下来，就算是低能的人也开始有了生存空间</li>
<li>采集经济，能让大多数人都过着比在农业或工业社会中更有趣的生活</li>
<li>采集者之所以能够免受饥饿或营养不良的困扰，秘诀就在于多样化的饮食。相较之下，之后农民的饮食往往种类极少，而且不均衡。</li>
<li>远古采集者也比较少碰到传染病的问题</li>
</ul>
</li>
<li>多数学者都同意，远古的采集者普遍信奉泛神论的信仰（animism，源自拉丁文的“anima”，意义“灵魂”或“精神”）<ul>
<li>泛神论相信，几乎任何一个地点、任何一只动物、任何一株植物、任何一种自然现象，都有其意识和情感，并且能与人类直接沟通</li>
<li>泛神论者认为，人类和其他的灵之间并没有障碍，可以直接通过言语、歌曲、舞蹈和仪式来沟通</li>
</ul>
</li>
<li>我们已经看到，采集社会可能有许多不同的宗教和社会结构，可以预测他们也同样有不同的暴力倾向。可能在某些时期，某些地区一片平静祥和，但在其他地区却是动乱不断。</li>
<li>整个动物界从古至今，最重要也最具破坏性的力量，就是这群四处游荡、讲着故事的智人</li>
</ul>
<h3 id="毁天灭地的人类洪水"><a href="#毁天灭地的人类洪水" class="headerlink" title="毁天灭地的人类洪水"></a>毁天灭地的人类洪水</h3><ul>
<li>在历史上，人类首次抵达澳大利亚绝对算是大事一件，重要性不亚于哥伦布抵达美洲或是阿波罗11号登上月球</li>
<li>智人灭绝澳大利亚大型动物的证据<ul>
<li>大多数动物在智人来之前都活过了多次冰河期，但却基本都在智人登陆后灭绝</li>
<li>同样是在澳大利亚，在那里的海洋生物却没有什么灭绝的变化</li>
<li>这种灭绝现象，出现的时间点基本都是智人登陆的时间点</li>
</ul>
</li>
<li>智人如何造成澳大利亚的生物灭绝<ul>
<li>大型动物的繁衍周期较长，即使智人只是几个月捕杀一只，也会超过大型动物的生殖速度，使得在几千年时间内缓慢灭绝</li>
<li>火耕技术改变了地貌，彻底改变生态</li>
<li>气候变迁加上人类狩猎</li>
</ul>
</li>
<li>智人的第一波殖民正是整个动物界最大也最快速的一场生态浩劫<ul>
<li>在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物</li>
<li>等到农业革命的时候，只剩下大约100属</li>
<li>远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝</li>
</ul>
</li>
</ul>
<h2 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h2><h3 id="史上最大骗局"><a href="#史上最大骗局" class="headerlink" title="史上最大骗局"></a>史上最大骗局</h3><ul>
<li>从采集走向农业的转变，始于大约公元前9500年~公元前8500年，发源于土耳其东南部、伊朗西部和地中海东部的丘陵地带</li>
<li>人到现代还有着远古狩猎采集者的心，以及远古农民的胃</li>
<li>人类以为自己驯化了植物，但其实是植物驯化了智人<ul>
<li>小麦以什么理由成为了智人的主要食谱？<ul>
<li>人类是杂食动物，谷物并不能带来更好的消化</li>
<li>小麦也并非经济安全，以某种特定谷物为生，显然不会比食用数十种食物更安全</li>
<li>以人类暴力而言，小麦也不会更安全，会引来争夺和战斗</li>
<li>也不能说因为给人类长远利益为由，毕竟对于当时的智人而言，并不会为了千年后的人类而去放弃当下的利益</li>
</ul>
</li>
<li>小麦成功的原因<ul>
<li>冰河时代结束，气候变得适宜小麦生长</li>
<li>由于食物普遍需要进一步加工导致小麦在携带回家的过程中落在路上，得以在智人居住地附近生长</li>
<li>刀耕火种导致小麦进一步独占阳光和养分</li>
</ul>
</li>
<li>公元前8500年至9500年左右，人类开始从采集者变成耕种者</li>
</ul>
</li>
<li>种植小麦带来的烦恼<ul>
<li>族群变大，使得疾病更容易肆虐，儿童成活率不高</li>
<li>小麦种植规模的扩大使得人类变得更加幸苦忙绿</li>
<li>单一作物更容易遭受旱灾</li>
</ul>
</li>
<li><strong>种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上的最后一次</strong></li>
<li>公元前9500年的哥贝克力石阵可能表明先有信仰中心再形成人类聚落</li>
<li>驯化动物<ul>
<li>按照演化的观点来看，驯化的动物无疑问是成功的，拥有大量的基因拷贝</li>
<li>然而对于动物个体来说，却是经历历史上最大的痛苦</li>
</ul>
</li>
</ul>
<h3 id="盖起金字塔"><a href="#盖起金字塔" class="headerlink" title="盖起金字塔"></a>盖起金字塔</h3><ul>
<li>农民和采集者的不同<ul>
<li>农业革命之后，农民的活动范围相比采集时代被大大缩小了，从而让人们的心里开始更加以自我为中心</li>
<li>开始改造周围环境，变成一个隔绝野生环境的人工孤岛</li>
<li>采集者只顾当下，农民开始顾虑未来<ul>
<li>担心未来使得农民会用别的办法减少当前风险，比如多种一些粮食，多开垦一些土地</li>
<li>而这些正是政治和社会制度的基础</li>
</ul>
</li>
</ul>
</li>
<li>粮食剩余养活了更多的人，使得更多人聚集在一块，形成部落乃至国家<ul>
<li>大约公元前8500年，全球最大的聚落大概就是像杰里科这样的村落，大概有几百个村民</li>
<li>而到了公元前7000年，位于今日土耳其的加泰土丘（ÇatalHöyük）城镇大约有5000到10000人</li>
<li>再到了公元前5世纪到公元前4世纪，肥沃月湾（FertileCrescent）一带已经有了许多人口达万人的城市</li>
<li>公元前3100年，整个下尼罗河谷统一，成为史上第一个埃及王朝，法老王统治的领土有数千平方公里辽阔，人民达数十万</li>
<li>在公元前2250年，萨尔贡大帝（SargontheGreat）建立起第一个帝国：阿卡德帝国，号称拥有超过100万的子民，常备军队达5400人</li>
<li>公元前1000年到公元前500年之间，在中东开始出现大型帝国：亚述帝国、巴比伦帝国和波斯帝国。这些帝国统治人数达数百万，军队人数也有上万人</li>
<li>到了公元1年，古罗马统一了整个地中海地区，纳税人口达1亿。有了这些钱，古罗马得以维持人数达25万到50万的常备军</li>
</ul>
</li>
<li>由想象所建构的秩序<ul>
<li>不管是《汉谟拉比法典》还是美国《独立宣言》，都声称自己说的是普遍且永恒的公平正义原则</li>
<li>想象着这个世界有着放诸四海皆准、永恒不变的正义原则</li>
<li>这种由想象所建构的秩序绝非邪恶的阴谋或是无用的空谈，而是唯一能让大群人类合作的救命仙丹</li>
</ul>
</li>
<li>想象所建构出来的秩序总是有一夕崩溃的风险<ul>
<li>为了维持想象建构出来的秩序，必须持续投入大量心力，甚至还得掺入些暴力和胁迫的成分</li>
<li>军队、警察、法院和监狱来进行维持</li>
</ul>
</li>
<li>人类不会发现组织自己生活的种种秩序其实是想象<ul>
<li>想象建构的秩序深深与真实的世界结合</li>
<li>想象建构的秩序塑造了我们的欲望</li>
<li>想象建构的秩序存在于人和人之间思想的连接</li>
</ul>
</li>
<li>身为人类，我们不可能脱离想象所建构出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</li>
</ul>
<h3 id="记忆过载"><a href="#记忆过载" class="headerlink" title="记忆过载"></a>记忆过载</h3><ul>
<li>在农业革命之后，社会开始变得格外复杂，另一种全新的信息类型也变得至关重要：数字</li>
<li>在公元前3500年~公元前3000年之间，苏美尔人所发明的这套数字处理系统，正是“书写文字”<ul>
<li>苏美尔文字只能部分表意</li>
<li>安第斯文化中的结绳语准确而高效，在西班牙人殖民之后被废弃</li>
</ul>
</li>
<li>文字发展<ul>
<li>在公元前3000年~公元前2500年间，苏美尔文字发展为楔形文字</li>
<li>中国在大约公元前1200年、中美洲各地在公元前1000年至公元前500年间，也都发展出了完整表意的文字</li>
</ul>
</li>
<li>文字对人类历史所造成的最重要的影响：它逐渐改变了人类思维和看待这个世界的方式。过去的自由连接、整体思考，已经转变为分割思考、官僚制度</li>
<li>文字本来应该是人类意识的仆人，但现在正在反仆为主。计算机并不能理解智人如何说话、感觉和编织梦想，所以我们现在反而是用一种计算机能够理解的数字语言来教智人如何说话、感觉和编织梦想</li>
</ul>
<h3 id="历史从无正义"><a href="#历史从无正义" class="headerlink" title="历史从无正义"></a>历史从无正义</h3><ul>
<li>是人类创造出了由想象建构的秩序、发明了文字，以这两者补足我们基因中的不足</li>
<li>制度的制定者们认为一切的阶级划分和等级差别都是自然形成的，天生如此</li>
<li><strong>阶级有其重要功能</strong>。有了阶级之后，陌生人不用浪费时间和精力真正了解彼此，也能知道该如何对待对方</li>
<li>传统的印度社会是用种姓制度来分阶级，土耳其人用宗教，美国用种族<ul>
<li>这种传统深入社会底层，很难被打破</li>
<li>这种传统观念导致受歧视的人群很难接受公平的机会，从而导致他们更难以获得认可，从而导致恶性循环 </li>
</ul>
</li>
<li>人类社会普遍重男轻女<ul>
<li>在中国古代，生下女孩被认为不吉利</li>
<li>很多地区强奸女人不算犯罪或者只是轻罪</li>
</ul>
</li>
<li>天生自然的生物学，可能性几乎无穷无尽。然而，文化却要求必须实现某些可能性，而又封闭了其他可能性<ul>
<li>文化总会说，它只是禁止“不自然的事”。但从生物学的角度来看，这世界上根本没有什么是不自然的。只要有可能发生的事，就是自然</li>
<li>真正完全“不自然”的事，是指违背了自然规律，但这种事情根本就不会存在，所以也没有禁止的必要</li>
<li>从这个观点来说，只要是人类会作出的事情，就是自然允许的事情，包括同性恋</li>
</ul>
</li>
<li>男性和女性的文化认同<ul>
<li>肌肉理论<ul>
<li>认为男人比女人强壮，于是靠着他们肌肉的力量迫使女人就范</li>
</ul>
</li>
<li>流氓理论<ul>
<li>男性占有主导地位靠的不是力气，而是好侵略的个性</li>
</ul>
</li>
<li>父权基因理论<ul>
<li>认为在数百万年的演化过程中，男人和女人发展出了不同的生存和繁殖策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="人类的融合统一"><a href="#人类的融合统一" class="headerlink" title="人类的融合统一"></a>人类的融合统一</h3>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-数据结构和算法图解</title>
    <url>/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/1.jpg"></p>
<h2 id="第一章-数据结构为何重要"><a href="#第一章-数据结构为何重要" class="headerlink" title="第一章 数据结构为何重要"></a>第一章 数据结构为何重要</h2><ul>
<li><strong>操作的速度，并不按时间计算，而是按步数计算。理解这个观点</strong>，因为不同机器其实运行速度都会有差异，真正决定效率的是一个操作的步数。</li>
<li>读取是一步到位，意味着是读取数组的索引<ul>
<li>计算机的内存可以看成一堆格子，内存的格子是地址连续的</li>
<li>声明数组时，是在内存中划分出一些连续的格子</li>
<li>查找任意索引，最多都是只需要1步</li>
</ul>
</li>
<li>查找意味着从数组中寻找是否存在某个值<ul>
<li>计算机需要从索引0开始寻找，即线性查找</li>
<li>查找任意内容，最多步骤为数组的索引长度N</li>
</ul>
</li>
<li>计算机知道数组的索引开始位置和结束位置<ul>
<li>插入末尾只需要一步，直接在末尾插入即可</li>
<li>开头或中间的位置，需要先移动其他元素的位置，再进行插入</li>
<li>最复杂的插入，是在数组开头插入，意味着需要将N个元素都右移，再将元素插入，即N+1步</li>
</ul>
</li>
<li>删除任意元素都需要将右边的元素左移，以保持数组的连续性和完整性</li>
<li>最复杂的删除是删除开头元素，删除为1步，之后将N-1个元素左移，最终为N步</li>
<li>集合是一种不允许元素重复的数据结构<ul>
<li>读取，查找，删除和数组的效率是一致的</li>
<li>插入的效率和数组不同<ul>
<li>需要先确定这个元素在不在集合内，因此需要先查找一遍，如前文所诉，最多需要N步</li>
<li>确定要插入的元素不在集合内后，进行插入，和数组一样，最多需要N+1步</li>
<li>因此集合的插入最终的复杂度为2N+1步<span id="more"></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-算法为何重要"><a href="#第二章-算法为何重要" class="headerlink" title="第二章 算法为何重要"></a>第二章 算法为何重要</h2><ul>
<li>和数组的区别就在于里面的元素是按照规则排序的。读取和删除跟数组效率一样。</li>
<li>插入元素<ul>
<li>首先需要根据排序规则，从索引0的位置开始遍历，找到这个元素在有序数组中的位置，最多N步</li>
<li>将该位置的元素右移，然后插入，这是2步，因此最多N+2步。</li>
</ul>
</li>
<li>查找元素<ul>
<li>有序数组的查找比数组的查找效率更高，因为排列有序，所以如果某个元素比查找元素要大，那就可以停止查找。</li>
</ul>
</li>
<li>二分查找的前提是有序数组</li>
<li>数组长度每次翻倍，二分查找的操作步数只会+1。而线性查找却会跟着一起翻倍。</li>
</ul>
<h2 id="第三章-大O记法"><a href="#第三章-大O记法" class="headerlink" title="第三章 大O记法"></a>第三章 大O记法</h2><ul>
<li>无论数组多大，操作都只要一步，记为O(1)</li>
<li>数组长度为N，操作需要用N步，记为O(N)</li>
<li>当数据增长时，步数如何变化？<ul>
<li>O(N) 被称为线性时间，随着数组长度增长，步数每次+1</li>
<li>O(1) 被称为常数时间，表示随着数组长度增长，步数不变</li>
</ul>
</li>
<li>线性查找的最好情况是O(1)，最坏情况是O(N)。</li>
<li>二分查找的复杂度记为O(log N)</li>
</ul>
<h2 id="第四章-利用大O给代码提速"><a href="#第四章-利用大O给代码提速" class="headerlink" title="第四章 利用大O给代码提速"></a>第四章 利用大O给代码提速</h2><ul>
<li><p>冒泡排序</p>
<ul>
<li>基本步骤<ul>
<li>指针首先指向头两个元素，比较大小，如果左边大于右边，则交换位置</li>
<li>将指针右移一位，重复第一步</li>
<li>到列表末尾，重新到列表头部重复第一二步</li>
<li>直到顺序正确，退出循环</li>
</ul>
</li>
<li>按照最复杂的情况看，也就是完全倒序的列表进行冒泡排序的话，复杂度为O(N^2)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二次问题</p>
<ul>
<li>解决一个数组中是否存在重复元素的问题</li>
<li>时间复杂度为O(N^2)的解决办法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasDuplicateValue</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vari=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(varj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!==j&amp;&amp;array[i]==array[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度为O(N)的解决办法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasDuplicateValue</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> existingNumbers=[];</span><br><span class="line">    <span class="keyword">for</span>(vari=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 将元素成员作为下标</span></span><br><span class="line">        <span class="keyword">if</span>(existingNumbers[array[i]]===<span class="literal">undefined</span>)&#123;</span><br><span class="line">            existingNumbers[array[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第五章-用或不用大O来优化代码"><a href="#第五章-用或不用大O来优化代码" class="headerlink" title="第五章 用或不用大O来优化代码"></a>第五章 用或不用大O来优化代码</h2><ul>
<li>选择排序<ul>
<li>基本步骤<ul>
<li>从索引0开始，遍历数组，找到最小的数，将其和索引0的数字调换位置</li>
<li>第二次循环从索引1开始，找到最小数，和索引1的数字调换位置</li>
<li>如此循环，到最后一个数时就完成了排序</li>
</ul>
</li>
<li>和冒泡排序一样，时间复杂度都表示为O(N^2)，但是实际效率比冒泡排序快一倍，也就是虽然更高效，但是没有指数上的差别</li>
<li><strong>从这个角度说，性能调优不应该盲目只看大O记法所表示的复杂度，如果不能有数量级的差别，也应该具体分析后进行同一数量级的调优</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                minIndex = j; <span class="comment">// 获取最小的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[minIndex];</span><br><span class="line">        nums[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第六章-乐观地调优"><a href="#第六章-乐观地调优" class="headerlink" title="第六章 乐观地调优"></a>第六章 乐观地调优</h2><ul>
<li>假设排序数组并不是按照最差的情况进行排序，则总是会有更好更高效的方式进行排序</li>
<li>插入排序<ul>
<li>基本步骤<ul>
<li>从索引1开始，将索引1的数字取出作为一个对比数字，然后从索引0开始，直到索引1结束，比较数字和对比数字的大小</li>
<li>遇到比它大的往右移动一位，遇到比它小的数字，或者索引左边的所有数字都右移了就停止这次循环</li>
<li>从索引2开始，重复1，2步骤    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(array)):</span><br><span class="line">        position = index</span><br><span class="line">        temp_value = array[index]</span><br><span class="line">        <span class="keyword">while</span> position &gt; <span class="number">0</span> <span class="keyword">and</span> array[position-<span class="number">1</span>] &gt; temp_value:</span><br><span class="line">            array[position] = array[position-<span class="number">1</span>]</span><br><span class="line">            position = position - <span class="number">1</span> </span><br><span class="line">        array[position] = temp_value</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>实际时间复杂度为O(N^2 + 2N - 2)，忽略常数和只看最高次的N，则还是O(N^2)</li>
<li><strong>看似时间复杂度一样，但是在平均情况下，插入排序的效率是更高的</strong></li>
</ul>
<h2 id="第七章-查找迅速的散列表"><a href="#第七章-查找迅速的散列表" class="headerlink" title="第七章 查找迅速的散列表"></a>第七章 查找迅速的散列表</h2><ul>
<li>散列表即map，或称字典，映射，关联数组</li>
<li>查找效率为O(1)</li>
<li>简单原理：暂且把散列中的键值对应关系视为乘法关系，如BAD值，转为字母表中的214，对应键为8</li>
<li>散列值计算过程（简化）<ul>
<li>散列表可以看成是一行能够存储数据的格子，就像数组那样。每个格子都有对应的编号</li>
<li>函数对键进行计算，如BAD=2<em>1</em>4=8</li>
<li>将BAD存到第8个格子上</li>
<li>当需要查找BAD对应的值时，计算机计算键BAD的散列值=8，因此直接找到第8个位置的值，复杂度为O(1)</li>
</ul>
</li>
<li>冲突解决<ul>
<li>如上所诉的过程，如果又要存储DAB的值，算出来的散列值也是8，也要存到同一个位置上</li>
<li>将8的位置换成一个数组，即8这个位置可以存储多个键值对</li>
<li>DAB的查找过程就变成，先计算散列值为8，然后找到8这个位置的数组，再用线性查找遍历数组，找到DAB</li>
<li>为了减少冲突，散列表的设计需要减少这种冲突，因此实际设计中散列值的计算要复杂很多</li>
</ul>
</li>
<li>散列表的效率决定因素<ul>
<li>要存多少数据</li>
<li>有多少可用的格子</li>
<li>用什么样的散列函数</li>
<li>要避免冲突，就要增加存储空间，需要找到平衡</li>
</ul>
</li>
</ul>
<h2 id="第八章-用栈和队列来构造灵巧的代码"><a href="#第八章-用栈和队列来构造灵巧的代码" class="headerlink" title="第八章 用栈和队列来构造灵巧的代码"></a>第八章 用栈和队列来构造灵巧的代码</h2><ul>
<li>栈 LIFO（lastin，firstout）后进先出。<ul>
<li>只在末尾插入数据</li>
<li>只能读取末尾数据</li>
<li>只能一处末尾数据</li>
<li><strong>栈的末尾叫栈顶，栈的开头成为栈尾</strong></li>
<li>往栈里插入数据，称为<strong>压栈</strong></li>
<li>从栈顶移出数据，称为<strong>出栈</strong></li>
<li>一般来说，栈都是用来实现某些特殊算法（当数据的处理顺序要与接收顺序相反时），而不会用于存储数据</li>
</ul>
</li>
<li>队列 先进先出<ul>
<li>只能在末尾插入数据（这跟栈一样）</li>
<li>只能读取开头的数据（这跟栈相反）</li>
<li>只能移除开头的数据（这也跟栈相反）</li>
<li>可用于处理网络数据接收处理等任务</li>
</ul>
</li>
</ul>
<h2 id="第九章-递归"><a href="#第九章-递归" class="headerlink" title="第九章 递归"></a>第九章 递归</h2><ul>
<li>递归必需设置基准情形，即结束递归的条件</li>
<li>计算机是用栈来记录每个调用中的函数。这个栈就叫作调用栈，也就是在递归场景中，按照321顺序调用，123顺序完成</li>
<li>递归十分适用于那些无法预估计算深度的问题</li>
</ul>
<h2 id="第十章-飞快的递归算法"><a href="#第十章-飞快的递归算法" class="headerlink" title="第十章 飞快的递归算法"></a>第十章 飞快的递归算法</h2><ul>
<li>快速排序<ul>
<li>基本步骤<ul>
<li>首先找一个基准数，比如找最右边的数</li>
<li>两个指针分别指向数组开头和结尾（排除基准数之外）</li>
<li>两个指针每次都向中间各移动一步，左指针遇到大于等于基准数的数值时就停止移动，右指针遇到小于等于基准数的数值时停止移动</li>
<li>两指针所在数值的位置互换</li>
<li>重复2-4步骤，直到两个指针重合</li>
<li>将基准数与左指针指向的数值互换</li>
</ul>
</li>
<li>以上步骤是以基准数为中心，将数组分为比基准数大的分区和比基准数小的分区，并没有完成最终排序</li>
<li><strong>结合递归，在每个分区内再分别进行快速排序，最终就可以完成排序</strong></li>
<li><strong>可以近似看作长度为N的数组，要进行N个分区的二分查找，二分查找的效率为logN，所以快速排序的效率近似为O(NlogN)</strong></li>
<li>大部分情况下都是表现最好的排序方式，因此多数语言内置排序都以快速排序实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    temp = a[left]; <span class="comment">// temp中存的就是基准数</span></span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="comment">// 顺序很重要，要先从右边开始找</span></span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">// 再找左边的</span></span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// 交换两个数在数组中的位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终将基准数归位</span></span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line"></span><br><span class="line">    quickSort(a, left, i - <span class="number">1</span>);<span class="comment">// 继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">    quickSort(a, i + <span class="number">1</span>, right);<span class="comment">// 继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>快速选择<ul>
<li>用于查找无序数组中指定大小的数字，比如长度为10的数组中查找第二小的数字</li>
<li>结合快速排序和二分法，先用快速排序对数组进行分区，每次分完区之后，基准数落下的位置就是这个数组中第几大的数字</li>
<li>根据这个方法，快速选择可以用O(N)的复杂度获取到需要的数字</li>
</ul>
</li>
</ul>
<h2 id="第十一章-基于结点的数据结构"><a href="#第十一章-基于结点的数据结构" class="headerlink" title="第十一章 基于结点的数据结构"></a>第十一章 基于结点的数据结构</h2><ul>
<li>链表<ul>
<li>和数组不同的是，链表中的各个元素不是连续的，这种不相邻的格子叫做<strong>结点</strong></li>
<li>每个结点存储数据以及下一个结点的地址来实现链表，这些存储下个结点地址的额外数据就是<strong>链</strong></li>
<li>链表的好处是不需要内存分配连续的空间</li>
<li>读取<ul>
<li>不像连续数组，计算机不知道某个结点的地址，只知道开头结点的地址，因此需要遍历</li>
<li>读取的复杂度为O(N)</li>
</ul>
</li>
<li>查找：读取一样，需要从链表开头进行逐一遍历，复杂度为O(N)</li>
<li>插入<ul>
<li>链表的插入需要先找到插入的位置，如前所述，这个过程的时间复杂度为O(N)</li>
<li>随后将插入位置的上一个结点指向的地址改为当前结点的地址，复杂度为O(1)</li>
<li>和有序列表相反的是，在表头插入数据步骤是最少的，在最后一位插入步骤是最多的</li>
</ul>
</li>
<li>删除：大致上和插入的原理差不多，时间复杂度同样为O(N)</li>
</ul>
</li>
<li><strong>为什么用链表</strong><ul>
<li>从上述分析看，链表增删改查的效率并没有比数组快</li>
<li>但在某些业务场景下，比如从一堆数组中删除指定条件的无效数据<ul>
<li>数组的操作过程是，每次找到一条无效数据后，先进行删除，然后将右边的数据进行左移，如果在最坏的情况下，无效数据都在数组开头，那每次删除都相当于要移动一遍整个数组</li>
<li>链表的操作过程，省略了每次删除后左移的过程，只需遍历一次数组即可</li>
<li>增加数据也是同理</li>
</ul>
</li>
<li>因此，相比数组，链表的增删效率更高</li>
</ul>
</li>
<li>双向链表<ul>
<li>即每个结点除了存储下个结点的地址，还会存储上一个结点的地址</li>
<li>增删改查可以从头部或者尾部开始</li>
<li>这种特性可以使双向链表作为队列的底层实现，这样增删复杂度都是O(1)</li>
</ul>
</li>
</ul>
<h2 id="第十二章-二叉树"><a href="#第十二章-二叉树" class="headerlink" title="第十二章 二叉树"></a>第十二章 二叉树</h2><ul>
<li>前文提到，有序列表的查找(二分法 O(logN))和读取 (O(1))非常快，但是插入和删除效率较低(O(N))；而散列表的查找，插入和删除效率较高(O(1))，但却是无序的<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree.png"></li>
<li>二叉树<ul>
<li>每个结点链接着另外两个结点</li>
<li>最上面的那一结点（此例中的“j”）被称为<strong>根</strong></li>
<li>此例中，“j”是“m”和“b”的<strong>父结点</strong>，反过来，“m”和“b”是“j”的<strong>子结点</strong>。“m”又是“q”和“z”的父结点，“q”和“z”是“m”的子结点</li>
<li>树可以分<strong>层</strong>。此例中的树有3层</li>
<li>每个结点的子结点数量可为0、1、2</li>
<li>如果有两个子结点，<strong>则其中一个子结点的值必须小于父结点，另一个子结点的值必须大于父结点</strong></li>
</ul>
</li>
<li>二叉树查找的原理类似于二分法，因此复杂度为O(logN)</li>
<li>插入同样也是O(logN)，因为找到需要插入的结点即可，无需像有序数组那样移动</li>
<li><strong>需要乱序生成的二叉树才能高效，原理看图可知</strong><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree2.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree3.png"></li>
<li>二叉树的删除<ul>
<li>规则较多，如果是删除最底下的子结点复杂度为O(logN)，但是如果删除某个父结点，需要考虑</li>
<li>如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上</li>
<li>如果要删除的结点有两个子结点，则从其子结点中选取后继结点。后继结点的选取规则是，所有比被删除结点大的子结点中，最小的那个。下图例子中就是将61作为替换<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree4.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree5.png"></li>
<li>查找后继结点的方法：跳到被删除结点的右子结点，然后一路只往左子结点上跳，直到没有左子结点为止，则所停留的结点就是被删除节点的后继结<ul>
<li>如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree6.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree7.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree8.png"></li>
</ul>
</li>
<li>尽管看起来规则复杂，然而这些额外步骤都是寥寥几步就可以完成，删除的主要过程依然是查找结点的过程，所以复杂度还是O(logN)</li>
</ul>
</li>
</ul>
<h2 id="第十三章-连接万物的图"><a href="#第十三章-连接万物的图" class="headerlink" title="第十三章 连接万物的图"></a>第十三章 连接万物的图</h2><p><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/graph.png"></p>
<ul>
<li>每个结点都是一个<strong>顶点</strong>，每条线段都是一条<strong>边</strong>。当两个顶点通过一条边联系在一起时，我们会说这两个顶点是相邻的。</li>
<li>以Facebook和twitter为例，facebook是双向的关系，而twitter是单向的<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/graph2.png"></li>
<li>可用散列表来实现图</li>
<li>广度优先搜索<ul>
<li>需要用队列记录后续要处理哪些顶点</li>
<li>找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。）</li>
<li>如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。</li>
<li>如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，那么算法完成。</li>
<li>简单点说就是每次只处理下一层的数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-算法-第三章</title>
    <url>/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第三章-查找"><a href="#第三章-查找" class="headerlink" title="第三章 查找"></a>第三章 查找</h2><ul>
<li><p>符号表</p>
<ul>
<li>符号表最主要的目的就是将一个键和一个值联系起来</li>
<li>能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值</li>
<li>设计原则<ul>
<li>每个键只对应着一个值（表中不允许存在重复的键）</li>
<li>当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值</li>
<li>键不能为空</li>
<li>不允许有空值</li>
<li>删除操作<ul>
<li>延时删除<ul>
<li>put(key,null)是delete(key)的一种简单的（延时型）实现</li>
</ul>
</li>
<li>即时删除</li>
</ul>
</li>
<li>基础API<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/search1.png"></li>
<li>有序的符号表API<ul>
<li>通过实现comparabel接口带来接口的有序性<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/search2.png"></li>
</ul>
</li>
<li>最大键和最小键<ul>
<li>区别在于优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作更多</li>
</ul>
</li>
<li>向下取整和向上取整<ul>
<li>向下取整（floor）操作（找出小于等于该键的最大键）</li>
<li>向上取整（ceiling）操作（找出大于等于该键的最小键）</li>
</ul>
</li>
<li>排名和选择</li>
<li>范围查找</li>
<li>例外情况<ul>
<li>当一个方法需要返回一个键但表中却没有合适的键可以返回时，我们约定抛出一个异常（另一种合理的方法是在这种情况下返回空）</li>
</ul>
</li>
</ul>
</li>
<li>成本模型<ul>
<li>统计比较的次数（等价性测试或是键的相互比较）</li>
<li>在内循环不进行比较（极少）的情况下，我们会统计数组的访问次数</li>
</ul>
</li>
</ul>
</li>
<li><p>无序链表的顺序查找</p>
<ul>
<li>符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对<ul>
<li>每次查找遍历链表，使用equals方法进行比较</li>
<li>插入也是遍历链表，如果匹配，则进行更新，没有匹配的就插入</li>
</ul>
</li>
<li><strong>我们使用命中表示一次成功的查找，未命中表示一次失败的查找</strong><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/noseqmap1.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/noseqmap2.png"></li>
<li>注意其中的node构建方法，以及get和put方法</li>
<li>性能分析<ul>
<li>在含有N对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~(N^2)/2次比较<ul>
<li>查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总时间除以N。</li>
<li>在查找表中的每个键的可能性都相同的情况下时，这个结果就是一次查找平均所需的比较数。我们将它称为<strong>随机命中</strong><span id="more"></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有序数组中的二分查找</p>
<ul>
<li><strong>使用的数据结构是一对平行的数组，一个存储键一个存储值</strong></li>
<li>核心是rank()方法，它返回表中小于给定键的键的数量，其实就相当于返回这个给定键应该所处的位置<ul>
<li>get()方法，只要给定的键存在于表中，rank()方法就能够精确地告诉我们在哪里能够找到它</li>
<li>put()方法，只要给定的键存在于表中，rank()方法就能够精确地告诉我们到哪里去更新它的值<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/binarysearch1.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/binarysearch2.png"></li>
<li>递归的rank()保留了以下性质<ul>
<li>如果表中存在该键，rank()应该返回该键的位置，也就是表中小于它的键的数量</li>
<li>如果表中不存在该键，rank()还是应该返回表中小于它的键的数量<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/binarysearch3.png"></li>
</ul>
</li>
</ul>
</li>
<li>效率分析<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/binarysearch4.png"></li>
</ul>
</li>
<li><p>顺序查找和二分查找的效率对比<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/binarysearch5.png"></p>
</li>
<li><p>二叉查找树</p>
<ul>
<li>定义<ul>
<li>我们所使用的数据结构由结点组成，结点包含的链接可以为空（null）或者指向其他结点</li>
<li>在二叉树中，每个结点只能有一个父结点（只有一个例外，也就是根结点，它没有父结点），而且每个结点都只有左右两个链接，分别指向自己的左子结点和右子结点</li>
<li>左子结点小于父节点，右子结点大于父结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree1.png"></li>
</ul>
</li>
<li>基本实现<ul>
<li>数据表示<ul>
<li>我们嵌套定义了一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器</li>
<li>一棵二叉查找树代表了一组键（及其相应的值）的集合，而同一个集合可以用多棵不同的二叉查找树表示<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree2.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree3.png"></li>
</ul>
</li>
<li>查找<ul>
<li>在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中</li>
<li>如果被查找的键和根结点的键相等，查找命中</li>
<li>否则我们就（递归地）在适当的子树中继续查找</li>
<li>如果被查找的键较小就选择左子树，较大则选择右子树<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree4.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree5.png"></li>
</ul>
</li>
<li>插入<ul>
<li>和查找很类似，找到对应的父节点，比父节点大就插入右边，比父节点小就插入左边<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree6.png"></li>
</ul>
</li>
</ul>
</li>
<li>分析<ul>
<li>最好的情况就是二叉树左右两边的子结点是完全平衡的，这样找到子结点最多次数是lgN</li>
<li>最差的情况就是所有的子结点都在左半边或者右半边，找到子结点最多次数是N<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree7.png"></li>
<li>在由N个随机键构造的二叉查找树中，查找命中平均所需的比较次数为～2lnN（约1.39lgN）</li>
</ul>
</li>
<li>其他操作<ul>
<li>最大键和最小键<ul>
<li>如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么树中的最小键就是左子树中的最小键</li>
<li>如果根结点的右链接为空，那么一棵二叉查找树中最大的键就是根结点；如果右链接非空，那么树中的最大键就是右子树中的最大键  </li>
</ul>
</li>
<li>向上取整和向下取整<ul>
<li>如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键floor(key)一定在根结点的左子树中</li>
<li>如果给定的键key大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree8.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree9.png"></li>
</ul>
</li>
<li><strong>删除操作</strong><ul>
<li>思路<ul>
<li>从其子结点中选取后继结点。后继结点的选取规则是，所有比被删除结点大的子结点中，最小的那个</li>
</ul>
</li>
<li>代码操作方式<ul>
<li>将指向即将被删除的结点的链接保存为t；将x指向它的后继结点min(t.right)</li>
<li>将x的右链接（原本指向一棵所有结点都大于x.key的二叉查找树）指向deleteMin(t.right)，也就是在删除后所有结点仍然都大于x.key的子二叉查找树</li>
<li>将x的左链接（本为空）设为t.left（其下所有的键都小于被删除的结点和它的后继结点）<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree10.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree11.png"></li>
</ul>
</li>
</ul>
</li>
<li>范围查找<ul>
<li>我们首先需要一个遍历二叉查找树的基本方法，叫做<strong>中序遍历</strong><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree13.png">  </li>
<li>将所有落在给定范围以内的键加入一个队列Queue并跳过那些不可能含有所查找键的子树<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree12.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree14.png"></li>
</ul>
</li>
</ul>
</li>
<li>性能分析<ul>
<li>总结<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/tree15.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>平衡查找树</p>
<ul>
<li>2-3查找树<ul>
<li>我们将一棵标准的二叉查找树中的结点称为2结点（含有一个键和两条链接），而现在我们引入3结点，它含有两个键和三条链接</li>
<li>定义<ul>
<li>2结点，含有一个键（及其对应的值）和两条链接，左链接指向的23树中的键都小于该结点，右链接指向的23树中的键都大于该结点</li>
<li>3结点，含有两个键（及其对应的值）和三条链接，左链接指向的23树中的键都小于该结点，中链接指向的23树中的键都位于该结点的两个键之间，右链接指向的23树中的键都大于该结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree1.png"></li>
</ul>
</li>
<li>基本操作<ul>
<li>查找：大于或者小于的情况类似，不过多了一种在三结点中如果目标值落在两个值中间，那么就要找中间的子结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree2.png"></li>
<li>插入<ul>
<li>向2-结点中插入键，那就把2-结点变成3-结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree3.png"></li>
<li>向一棵只含有一个3-结点的树中插入新键，那就把3-结点变成4-结点，然后再分解成为2-3树<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree4.png"></li>
<li>向一个父结点为2-结点的3-结点中插入新键，看图比较清楚，就不文字解释了<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree5.png">  </li>
<li>向一个父结点为3-结点的3-结点中插入新键，看图比价清楚，就不文字解释了<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree6.png"></li>
<li>分解根结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/2-3tree7.png"></li>
</ul>
</li>
</ul>
</li>
<li>这些局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的</li>
<li>在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</li>
<li>需要考虑的变换情况太多，代码比较难完全顾及到，<strong>因此暂且看作是一个概念，作为其他树的基础</strong></li>
</ul>
</li>
<li>红黑二叉查找树<ul>
<li>定义<ul>
<li>红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树</li>
<li><strong>红链接将两个2-结点连接起来构成一个3-结点</strong></li>
<li><strong>黑链接则是2-3树中的普通链接</strong><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree.png"></li>
<li>这样的红黑树同时也满足：<ul>
<li>红链接均为左链接</li>
<li>没有任何一个结点同时和两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同</li>
</ul>
</li>
<li>红黑树都既是二叉查找树，也是2-3树，将其平铺开来，就是一棵2-3树<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree2.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree3.png"> </li>
</ul>
</li>
<li>实现方案<ul>
<li>颜色表示<ul>
<li>在结点中定义一个变量存储红黑值，规定指向它的父节点的链接如果是红色的，该变量定为true，如果是黑色则为false<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree4.png"></li>
</ul>
</li>
<li>旋转<ul>
<li>出现红色右链接或者两条连续的红链接时需要进行旋转</li>
<li><strong>我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点</strong><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree5.png"></li>
</ul>
</li>
<li>插入新结点<ul>
<li>tips：可以理解为所有的插入都是新增一个红色的链接，而我们要处理的就是调整这个红色的链接，以保持红黑树中的平衡</li>
<li>向单个2- 结点中插入新键<ul>
<li>如果新键在老键的左侧加入，那就是一个合理的红色结点，这个2- 结点会变成一个3- 结点（<strong>由一条红色左链接相连的两个2- 结点表示一个3- 结点</strong>）</li>
<li>如果新键在老键的右侧加入，那就是一个错误的红色结点，需要进行旋转，通过左旋来完成<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree6.png"></li>
</ul>
</li>
<li>向树底部的2- 结点插入新键<ul>
<li>如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个3- 结点</li>
<li>如果指向新结点的是父结点的右链接，这就是一个错误的3- 结点，但一次左旋转就能够修正它<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree7.png"></li>
</ul>
</li>
<li>向一棵双键树（即一个3- 结点）中插入新键<ul>
<li>如果新键大于原3-结点中的两个值，加到父节点的右链接，此时出现两个红链接，因此调整为将两个红链接变黑，下面两种情况最终也会变成这种结果</li>
<li>如果新键小于原3-结点中的两个值，加到左子结点的左链接，此时左边链接出现连续两个红链接，此时进行两步操作<ul>
<li>将父节点进行<strong>右旋</strong></li>
<li>将两个红链接变黑</li>
</ul>
</li>
<li>如果新键介于原3-结点的两个值中间，加到左子结点的右链接，此时出现右边的红链接，需要进行三步操作<ul>
<li>将左子结点进行左旋，此时变成连续两个红链接</li>
<li>将父节点右旋</li>
<li>将两个红链接变黑<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree8.png">                   </li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>：上述过程将两个红链接变黑的情况下，也会将再上一层的父节点变红，如果这个变红的结点引起连锁的红黑树不平衡问题，也需要按照之前的原则进行转换<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree9.png"></li>
<li>向树底部的3- 结点插入新键<ul>
<li>跟上一种情况差不多，只不过多了一步父节点变红之后的转换<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree10.png"></li>
</ul>
</li>
<li><strong>将红链接在树中向上传递</strong><ul>
<li>如果右子结点是红色的而左子结点是黑色的，进行左旋转</li>
<li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转</li>
<li>如果左右子结点均为红色，进行颜色转换<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree11.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree12.png"></li>
</ul>
</li>
</ul>
</li>
<li>删除操作<ul>
<li>自上而下的2-3-4树<ul>
<li>如果根结点是4结点，我们就将它分解成三个2结点，使得树高加1</li>
<li>如果遇到一个父结点为2结点的4结点，我们将4结点分解为两个2结点并将中间键传递给它的父结点，使得父结点变为一个3结点</li>
<li>如果遇到一个父结点为3结点的4结点，我们将4结点分解为两个2结点并将中间键传递给它的父结点，使得父结点变为一个4结点</li>
</ul>
</li>
<li>用红黑树的方式实现2-3-4树<ul>
<li>将4结点表示为由三个2结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连；</li>
<li>在向下的过程中分解所有4结点并进行颜色转换</li>
<li>和插入操作一样，在向上的过程中用旋转将4结点配平2</li>
</ul>
</li>
<li>删除最小键<ul>
<li>从树底部删除一个3-结点中的键最简单，删除最小键之后直接留下一个2-结点即可</li>
<li>从树底部删除一个2-结点的键，会留下一个空链接，破坏了树的平衡，所以我们的做法是把2-结点变成3-结点或者4-结点<ul>
<li>如果当前结点的左子结点不是2结点，完成</li>
<li>如果当前结点的左子结点是2结点而它的亲兄弟结点不是2结点，将左子结点的兄弟结点中的一个键移动到左子结点中</li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4结点，使父结点由3结点变为2结点或者由4结点变为3结点<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree13.png"></li>
</ul>
</li>
</ul>
</li>
<li>一般删除<ul>
<li>删除非树底部的结点，依然是按照删除最小键的逻辑，只是删除后需要按照二叉树查找后继结点的逻辑补上去</li>
</ul>
</li>
</ul>
</li>
<li>性能分析<ul>
<li>一棵大小为N的红黑树的高度不会超过2lgN</li>
<li>一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为lgN<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/redtree14.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>散列表</p>
<ul>
<li>散列算法<ul>
<li>第一步是用散列函数将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。</li>
<li>第二步就是一个处理碰撞冲突的过程：：拉链法和线性探测法</li>
</ul>
</li>
<li>散列函数<ul>
<li>易于计算并且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应</li>
<li>正整数<ul>
<li>除留余数法：我们选择大小为<strong>素数</strong>M的数组，对于任意正整数k，计算k除以M的余数（用素数可以最大程度降低计算出重复的索引）</li>
</ul>
</li>
<li>浮点数<ul>
<li>如果键是0到1之间的实数，我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值</li>
<li><strong>或者将键表示为二进制数然后再使用除留余数法（Java就是这么做的）</strong></li>
</ul>
</li>
<li>字符串<ul>
<li>将字符串作为大整数即可<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/hash1.png"></li>
</ul>
</li>
<li>组合键<ul>
<li>如果键的类型含有多个整型变量，我们可以和String类型一样将它们混合起来<br>int hash= ( ( ( day * R + month ) % M ) * R + year ) % M</li>
</ul>
</li>
<li>java中的约定<ul>
<li>Java令所有数据类型都继承了一个能够返回一个32比特整数的hashCode()方法</li>
<li>每一种数据类型的hashCode()方法都必须和equals()方法一致</li>
<li>a.equals(b)返回true，那么a.hashCode()的返回值必然和b.hashCode()的返回值相同</li>
<li>但如果两个对象的hashCode()方法的返回值相同，这两个对象也有可能不同，我们还需要用equals()方法进行判断</li>
</ul>
</li>
<li>设计原则<ul>
<li>一致性：等价的键必然产生相等的散列值</li>
<li>高效性：计算简便</li>
<li>均匀性：均匀地散列所有的键</li>
</ul>
</li>
</ul>
</li>
<li>拉链法<ul>
<li>将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对</li>
<li>查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/hash2.png"><br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/hash3.png"></li>
<li>散列表的大小<ul>
<li>选择适当的数组大小M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间</li>
</ul>
</li>
</ul>
</li>
<li>线性探测法<ul>
<li>实现散列表的另一种方式就是用大小为M的数组保存N个键值对，其中M&gt;N</li>
<li>我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为<strong>开放地址散列表</strong></li>
<li><strong>具体做法</strong><ul>
<li>当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加1），此时可能：<ul>
<li>命中，该位置的键和被查找的键相同</li>
<li>未命中，键为空（该位置没有键）</li>
<li>继续查找，该位置的键和被查找的键不同。</li>
</ul>
</li>
<li>例如：有下列键值对分别put，A-2，C-4，S-0，H-5。其中通过键值分别算出的散列值是A=4，C=5，S=6，H=4。可以看到，在A，C，S分别插入到数组中后，插入H时，4的位置已经有A了，此时顺延至5的位置，但是5的位置也有C，所以只能一直顺延至7的位置。<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/hash4.png"></li>
<li>删除操作<ul>
<li>删除就不能直接删除改键，因为有上述线性顺延的逻辑，可想而知，如果我们删除了C，那就没办法找到H，所以需要将被删除键的右侧所有键都重新插入散列表</li>
</ul>
</li>
</ul>
</li>
<li>开放地址类的散列表的性能也依赖于N/M的比值，但意义有所不同。我们将其称为散列表的使用率。对于基于拉链法的散列表，是每条链表的长度，因此一般大于1；对于基于线性探测的散列表，是表中已被占用的空间的比例，它是不可能大于1的</li>
<li>键簇<ul>
<li>元素在插入数组后聚集成的一组连续的条目，也叫做键簇</li>
<li>在之前的例子中A-C-S-H就是一个键簇</li>
<li>长键簇更长的可能性比短键簇更大</li>
</ul>
</li>
<li>当散列表快满的时候查找所需的探测次数是巨大的，保证N/M的值不大于1/2<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/hash5.png"></li>
</ul>
</li>
<li>散列表的弊端<ul>
<li>每种类型的键都需要一个优秀的散列函数</li>
<li>性能保证来自于散列函数的质量</li>
<li>散列函数的计算可能复杂而且昂贵</li>
<li>难以支持有序性相关的符号表操作</li>
</ul>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>相对二叉查找树，散列表的优点在于代码更简单，且查找时间最优（常数级别，只要键的数据类型是标准的或者简单到我们可以为它写出满足（或者近似满足）均匀性假设的高效散列函数即可）</li>
<li>二叉查找树相对于散列表的优点在于抽象结构更简单（不需要设计散列函数）</li>
<li>红黑树可以保证最坏情况下的性能且它能够支持的操作更多（如排名、选择、排序和范围查找）<br><img src="/2022/04/01/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%89%E7%AB%A0/search3.png"></li>
<li>使用原始数据类型进行存储键值可以更高效</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-算法-第二章</title>
    <url>/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h2><p><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/basesort.png"></p>
<ul>
<li>初级排序算法<ul>
<li>排序就是将数组的<strong>主键</strong>按照某种方式排序</li>
<li>排序成本模型：我们需要计算<strong>比较</strong>和<strong>交换</strong>的数量。对于不交换元素的算法，我们会计算访问数组的次数</li>
<li>java的compareTo方法必须实现一个全序关系：<ul>
<li>自反性：对于所有的v，v=v</li>
<li>反对称性：对于所有的v&lt;w都有w&gt;v，且v=w时w=v</li>
<li>传递性：对于所有的v，w和x，如果v&lt;=w且w&lt;=x，则v&lt;=x</li>
</ul>
</li>
</ul>
</li>
<li>选择排序<ul>
<li>基本步骤<ul>
<li>找到数组中最小的那个元素</li>
<li>将它和数组的第一个元素交换位置</li>
<li>在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，如此反复</li>
</ul>
</li>
<li>分析效率<ul>
<li>对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换</li>
<li>为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息</li>
<li>可以看到，对于长度为N的数组，交换次数固定为N次，是所有数组中，交换步数最少的</li>
<li>简单，但效率颇低<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/selectsort.png"> </li>
</ul>
</li>
</ul>
</li>
<li>插入排序<ul>
<li>基本步骤<ul>
<li>从索引1开始，对比索引1的数字和索引0的数字，如果索引0数字比索引1数字大，则两个数字交换位置</li>
<li>索引移到2，对比索引2和索引1所在数字，同样的，如果索引1比索引2数字大，则交换位置</li>
<li>接下来对比索引1和索引0，以此类推</li>
</ul>
</li>
<li>分析效率<ul>
<li>对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要(N^2)/4次比较以及(N^2)/4次交换。最坏情况下需要(N^2)/2次比较和(N^2)/2次交换，最好情况下需要N-1次比较和0次交换。</li>
<li>插入排序对于实际应用中常见的某些类型的非随机数组很有效<ul>
<li>数组中每个元素距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
<li>当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/insertsort.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>排序算法可视化<span id="more"></span>
<img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/visualsort.png"></li>
<li>选择排序和插入排序效率对比<ul>
<li>对于随机排序数组，两者的运行时间都是平方级别的</li>
<li>从大量数据实验来看，两者的运行时间没有数量级的差别，但是实际跑下来，插入排序会比选择排序快将近2倍</li>
</ul>
</li>
<li>希尔排序<ul>
<li>基本思路<ul>
<li>使数组中任意间隔为h的元素都是有序的</li>
<li>一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组</li>
<li>在进行排序时，如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便</li>
</ul>
</li>
<li>基本步骤<ul>
<li>确定一个间隔值h，一开始可以很大，为了方便，可以根据数组长度来确定h<ul>
<li>其中一种h的算法，N为数组长度：<ul>
<li>int h = 1;<br>while(h&lt;N/3) h=3*h+1;</li>
</ul>
</li>
</ul>
</li>
<li>随后的基本过程和插入排序类似，只不过改成以h为长度<ul>
<li>从索引h开始，对比索引h的数字和索引0的数字，如果索引0数字比索引h数字大，则两个数字交换位置</li>
<li>索引移到h+1，对比索引h+1和索引1所在数字，同样的，如果索引1比索引h+1数字大，则交换位置</li>
<li>接下来对比索引h和索引0，以此类推</li>
</ul>
</li>
<li>完成以此以h为长度的排序后，将h缩减，比如将h/3，在重新开始上述循环，直到h=1的循环结束后，排序完成</li>
</ul>
</li>
<li>分析效率<ul>
<li>基本上，无法确切的计算出希尔排序的准确效率，只能说在各种实验中都比插入排序更加高效</li>
<li>即使最坏的情况下，也不会达到平方级别，接近于O((N^3)/2)</li>
<li>某种情况下，可以认为是性价比极高的排序算法，因为比较简单快速，且不需要用到额外的存储空间</li>
<li>希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/hillsort.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/hillsort2.png"></li>
</ul>
</li>
</ul>
</li>
<li>归并排序<ul>
<li>基本思路<ul>
<li>将一个大的数组分成两半，分别排序</li>
<li>将两个小的有序数组合并之后，进行<strong>归并排序</strong></li>
<li><strong>注意</strong>，归并的前提是两半的数组都已经分别有序</li>
</ul>
</li>
<li>原地归并的基本步骤<ul>
<li>先将所有元素复制到aux[]中，然后再归并回a[]中</li>
<li>左半边用尽（取右半边的元素）</li>
<li>右半边用尽（取左半边的元素）</li>
<li>右半边的当前元素小于左半边的当前元素（取右半边的元素）</li>
<li>右半边的当前元素大于等于左半边的当前元素（取左半边的元素）<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort2.png">  </li>
</ul>
</li>
<li>递归的归并<ul>
<li>和原地归并思路差不多，不过将每个半边再继续分一半，按照递归的思路不断切分成最小的数组进行归并<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort3.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort4.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort5.png">  </li>
</ul>
</li>
<li>分析效率<ul>
<li>将大数组递归成更小数组，这个过程最多需要lgN步</li>
<li>最小数组只包含两个元素，仅需要进行一次位置交换</li>
<li>合并成一个大数组后，交换次数最多也是N步</li>
<li>省略一部分数学推导，时间复杂度是和N*lgN成正比的</li>
<li>从时间效率来说毫无疑问是高效的，然而缺点是越大的数组需要的额外数组越多，空间复杂度越大</li>
</ul>
</li>
<li>改进空间<ul>
<li>对于分割出来的小数组，可以不必每次都用归并排序，适当使用插入排序解决小数组，可以使得效率更高</li>
</ul>
</li>
<li><strong>研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它</strong></li>
<li>自下而上的归并排序<ul>
<li>与原地归并的思路相反，不将大数组分割成小数组，而是直接从小数组出发，先两两归并，再四四归并，如此类推<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort6.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/mergesort7.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>排序算法的复杂度</strong><ul>
<li>排序算法的极限效率是lg(N!)~N*lgN次<ul>
<li>证明过程和二叉树相关，看不太明白，需要研究的看书P386</li>
</ul>
</li>
<li><strong>准确的上界为软件工程师保证性能提供了空间</strong></li>
<li><strong>准确的下界可以为我们节省很多时间，避免因不可能的性能改进而投入资源</strong></li>
<li>尽管归并排序很有可能是最高效的排序，然而现实中也很可能不使用归并排序<ul>
<li>归并排序的空间复杂度不是最优的</li>
<li>在实践中不一定会遇到最坏情况</li>
<li>除了比较，算法的其他操作（例如访问数组）也可能很重要</li>
<li>不进行比较也能将某些数据排序</li>
<li>在随机生成的数组中，也证实了归并排序和希尔排序的效率差不多，只会快常数级别的效率  </li>
</ul>
</li>
</ul>
</li>
<li>快速排序<ul>
<li>基本思路<ul>
<li>和归并排序类似的是，将一个大数组分成两个小数组，将两部分独立的排序</li>
<li>前提是数组需要打乱，并取出一个中间元素</li>
<li>此时将左右半边进行排序，左半边要求不大于中间元素，右半边要求不小于中间元素</li>
<li>完成后再将左半边和右半边进行递归处理，按照1-3的步骤<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort2.png"></li>
</ul>
</li>
<li>基本步骤<ul>
<li>快速排序递归地将子数组a[lo..hi]排序</li>
<li>先用partition()方法将a[j]放到一个合适位置</li>
<li>然后再用递归调用将其他位置的元素排序</li>
</ul>
</li>
<li>切分数组<ul>
<li>如下所示，取出第一个数作为切分元素</li>
<li>分别维护数组两头的指针，向中间移动</li>
<li>左边找到比切分元素大的数字，右边找到比切分元素小的数字</li>
<li>交换两个数字的位置</li>
<li>不断重复这个过程，直到没有数字可以交换<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort3.png"></li>
</ul>
</li>
<li>注意事项：快速排序效率高，但是比较脆弱，稍不注意的点可能导致效率骤降<ul>
<li>原地切分<ul>
<li>不要在递归的切分方法中创建数组，而是传递初始数组对象进去处理</li>
</ul>
</li>
<li>别越界</li>
<li>保持随机性<ul>
<li>数组元素必须是乱序的，如有必要，可以在切分数组时，随机选择一个切分元素</li>
</ul>
</li>
<li>终止循环<ul>
<li>一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素</li>
</ul>
</li>
</ul>
</li>
<li>分析效率<ul>
<li>切分方法的内循环会用一个递增的索引将数组元素和一个定值比较<ul>
<li>非常短小精悍的内循环</li>
</ul>
</li>
<li>只要数组是随机的，那么平均而言，切分元素都能落在数组的中间，这样也就能保证快速排序的最好效率</li>
<li>将长度为N的无重复数组排序，快速排序平均需要2N*lnN次比较</li>
<li>最糟的情况就是每次选择切分元素都选到了最小的，这样需要(N^2)/2次的比较</li>
<li>总的来说，可以肯定的是对于大小为N的数组，快速的运行时间在1.39N*lgN的某个常数因子的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多39%），因为它移动数据的次数更少</li>
</ul>
</li>
<li>快速排序的改进<ul>
<li>切换到插入排序<ul>
<li>插入排序对于小数组的处理总是更加高效</li>
<li>设定数组切分到一定大小的时候，切换为插入排序<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort4.png"> </li>
</ul>
</li>
<li>三取样切分<ul>
<li>为防止切分元素的位置过于极端导致的效率下降，采用从小数组中取三个数中的中位数来作为切分元素</li>
</ul>
</li>
<li>熵最优的排序（三向切分）<ul>
<li>考虑和切分元素相等的情况</li>
<li>对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多</li>
<li>在实际应用中，不能忽视重复元素的影响<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort5.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/quicksort6.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>优先队列<ul>
<li>不是所有情况下都要数组完全有序，很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素</li>
<li>基于其目的需要实现两种功能：<strong>删除最大元素和插入元素</strong><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/sort.png"></li>
<li>初级实现<ul>
<li>无序数组<ul>
<li>添加一段类似于选择排序的内循环的代码，将最大元素和边界元素交换然</li>
</ul>
</li>
<li>有序数组<ul>
<li>最大的元素总会在数组的一边，优先队列的删除最大元素操作就和栈的pop()操作一样了</li>
</ul>
</li>
<li>链表表示法<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/prioritysort.png">  </li>
</ul>
</li>
<li>二叉堆<ul>
<li>每个元素都要保证大于等于另两个特定位置的元素</li>
<li>这些位置的元素又至少要大于等于数组中的另两个元素</li>
<li>当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为<strong>堆有序</strong><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/prioritysort2.png">  </li>
</ul>
</li>
<li>堆的算法<ul>
<li><strong>对于某个节点K，父结点的位置为k/2，而它的两个子结点的位置则分别为2K和2K+1</strong></li>
<li>用长度N+1的数组pq[]表示一个大小为N的堆，堆元素放在pq[1]至pq[N]中，不从0开始</li>
<li>当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要由下至上恢复堆的顺序。<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort1.png"></li>
<li>如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort3.png"></li>
<li><strong>插入元素</strong>：我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置</li>
<li><strong>删除最大元素</strong>：我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置</li>
<li>简而言之，插入元素是插到堆的末尾，然后再上浮到合适位置。删除元素，从顶端将最大元素和末尾元素交换位置，然后删除最大元素，再将末尾元素下沉到合适位置。<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort5.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort6.png">       </li>
<li>sink方法的逻辑<ul>
<li>输入k之后，将2k和2k+1的值进行比较（这两个值是k的子结点），找到这两个值中更大的那个</li>
<li>将k和1步骤中找到的更大值进行比较，如果k更小，则k和该值的位置交换</li>
<li>继续将k和子结点进行比较，重复该过程，直到k不比任何子结点小，或者到达最末尾后结束循环<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort4.png"></li>
</ul>
</li>
<li>swim方法的逻辑<ul>
<li>输入k之后，将k和k/2的值进行比较（k/2是k的父节点）</li>
<li>如果k比k/2更大，则将两个值的位置交换</li>
<li>继续将k和其父节点比较，重复该过程，直到k不比任何父节点大，或者到达根结点后结束循环<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort2.png"></li>
</ul>
</li>
</ul>
</li>
<li>堆的效率<ul>
<li>对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较</li>
</ul>
</li>
<li>多叉堆<ul>
<li>基于二叉堆的原理可以构建三叉堆<ul>
<li>对于数组中1至N的N个元素，位置的结点大于等于位于3K-1、3K和3K+1的结点，小于等于位于(k+1)/3的结点</li>
</ul>
</li>
</ul>
</li>
<li>索引优先队列<ul>
<li>给每个元素一个索引，从而使得优先队列中的元素可以被外部引用</li>
<li>理解这种数据结构的一个较好方法是将它看成一个能够快速访问其中最小元素的数组</li>
<li>在一个大小为的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（removetheminimum）操作所需的比较次数和lgN成正比</li>
</ul>
</li>
<li><strong>堆排序</strong><ul>
<li>由堆的上浮下沉过程可以对一个数组进行排序</li>
<li>用swim()保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可          </li>
<li>基本思路<ul>
<li>我们将原始数组重新组织安排进一个堆中</li>
<li>然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果</li>
</ul>
</li>
<li>基本步骤<ul>
<li>输入数组a[]后，先将其构造成堆</li>
<li>构造堆的方法是将索引小于N/2的元素都进行下沉操作，这样可以保证创造一个深度不超过lgN的堆，同时会把最大值放在头部</li>
<li>然后遍历堆，第一步将头部元素和末尾元素调换位置，再将末尾元素下沉到合适位置</li>
<li>第二次循环，将头部元素和倒数第二个元素调换位置，再将倒数第二个元素下沉到合适位置，以此类推<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort7.png"><br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/stacksort8.png"></li>
</ul>
</li>
<li>效率分析<ul>
<li>是我们所知的唯一能够同时最优地利用空间和时间的方法</li>
<li>在最坏的情况下它也能保证使用～2NlgN次比较和恒定的额外空间</li>
<li>但现代系统的许多应用很少使用它，因为它无法利用缓存(?)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>排序的应用<ul>
<li>在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多</li>
<li>应用领域：数据压缩、计算机图形学、计算生物学、供应链管理、组合优化、社会选择和投票等</li>
<li>使用comparator进行排序<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/sort3.png"></li>
<li>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是稳定的</li>
<li>排序算法比较<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/sort4.png"></li>
<li><strong>快速排序是最快的通用排序算法</strong><ul>
<li>内循环的指令很少</li>
<li>能够利用缓存</li>
</ul>
</li>
<li>Kendall tau距离就是在两组数列中顺序不同的数对的数目<ul>
<li>例如，0316254和1036425之间的Kendalltau距离是4，因为01、31、24、54这4对数字在两组排列中的相对顺序不同，但其他数字的相对顺序都是相同的</li>
</ul>
</li>
<li>使用快速排序中的切分法来查找中位数    <ul>
<li>按照快速排序的规则，选择第一个数作为切分元素，切分完成后，左边的数都小于它，右边的数都大于它</li>
<li>此时检查切分元素所在的位置，如果正好是数组元素的中间位置，则这个切分元素就是中位数，如果位置大于中间位置，则重新切分左半边，如果位置小于中间位置，则重新切分右半边</li>
<li>以此循环，直到切分元素的位置刚好在中间位置，就找到了中位数<br><img src="/2022/03/29/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0/sort5.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-算法-第五章</title>
    <url>/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第五章-字符串"><a href="#第五章-字符串" class="headerlink" title="第五章 字符串"></a>第五章 字符串</h2><ul>
<li>Java字符串<ul>
<li>String是由一系列字符组成的。字符的类型是char，可能有个值。</li>
<li>不可变性。String对象是不可变的，因此可以将它们用于赋值语句、作为函数的参数或是返回值，而不用担心它们的值会发生变化</li>
<li>索引。我们最常完成的操作就是从某个字符串中提取一个特定的字符，即Java的String类的charAt()方法。我们希望charAt()方法能够在常数时间内完成，就好像字符串是保存在一个char[]数组中一样</li>
<li>长度。在Java中，String类型的length()方法实现了获取字符串的长度的操作。同样，我们也希望length()方法能够在常数时间内完成</li>
<li>子字符串。Java的substring()方法实现了提取特定的子字符串的操作。同样，我们也希望这个方法能够在常数时间内完成，Java的标准实现也做到了这一点</li>
<li>字符串的连接。在Java中通过将一个字符串追加到另一个字符串的末尾创建一个新字符串的操作是一个内置的操作（使用“+”运算符），所需的时间与结果字符串的长度成正比<ul>
<li>我们会避免将字符一个一个地追加到字符串中，因为在Java里这个过程所需的时间将会是<strong>平方级别</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>字母表<ul>
<li>字母表的API<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string1.png"></li>
<li>标准字母表<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string2.png"></li>
</ul>
</li>
<li>字符串排序<ul>
<li>键索引计数法<ul>
<li>频率统计<ul>
<li>使用int数组count[]计算每个键出现的频率。<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string3.png"></li>
</ul>
</li>
<li>将频率转换为索引<ul>
<li>使用count[]来计算每个键在排序结果中的<strong>起始索引位置</strong><br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string4.png"></li>
</ul>
</li>
<li>数据分类<ul>
<li>将count[]数组转换为一张索引表之后，将所有元素（学生）移动到一个辅助数组aux[]中以进行排序</li>
<li>每个键都有起始位置，就是第二步获得的起始位置<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string5.png"></li>
</ul>
</li>
<li>回写<ul>
<li>最后一步就是将排序的结果复制回原数组中</li>
</ul>
</li>
<li>对于小整数键排序非常有效<ul>
<li>键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组11N+4R+1次 </li>
<li>突破了NlogN的排序算法时间下限<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string6.png"></li>
</ul>
</li>
</ul>
</li>
<li>低位优先（LeastSignificantDigitFirst，LSD）的字符串排序<ul>
<li>适用于定长字符串，如车牌号，银行卡，身份证等</li>
<li>如果将一个字符串看作一个256进制的数字，那么从右向左检查字符串就等价于先检查数字的最低位</li>
<li><strong>如果字符串的长度均为W，那就从右向左以每个位置的字符作为键，用键索引计数法将字符串排序W遍</strong><ul>
<li>从右向左排相当于最左边的位数最后排<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string7.png"></li>
<li>charAt(d) + 1 的作用是将任意字符转换为ASCII数字<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string8.png"></li>
</ul>
</li>
</ul>
</li>
<li>高位优先（MSD）的字符串排序，首先查看的是最高位的字符<ul>
<li>针对非定长字符串的处理</li>
<li>具体实现<ul>
<li>首先用键索引计数法将所有字符串按照首字母排序</li>
<li>然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每一类中的所有字符串的首字母都是相同的）</li>
<li><strong>增加了一个条件语句以在子数组较小时切换插入排序</strong><ul>
<li>小型子数组对于高位优先的字符串排序的性能至关重要</li>
<li>考虑不周的程序在从ASCII切换到Unicode后运行时间从几分钟暴涨到几个小时<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string9.png"><br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string10.png"></li>
</ul>
</li>
</ul>
</li>
<li>对于含有大量等值键的子数组的排序会较慢<ul>
<li>如果相同的子字符串出现得过多，切换排序方法条件将不会出现，那么递归方法就会检查所有相同键中的每一个字符</li>
<li>键索引计数法无法有效判断字符串中的字符是否全部相同<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string11.png"></li>
</ul>
</li>
</ul>
</li>
<li>三向字符串快速排序<ul>
<li>以根据高位优先的字符串排序算法改进快速排序，根据键的首字母进行三向切分，仅在中间子数组中的下一个字符（因为键的首字母都与切分字符相等）继续递归排序<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string12.png"></li>
<li>三向字符串快速排序能够很好处理等值键、有较长公共前缀的键、取值范围较小的键和小数组——所有高位优先的字符串排序算法不擅长的各种情况<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string13.png"></li>
<li>在所有的递归算法中，我们都可以通过对小型子数组进行特殊处理（一般来说就是切换为插入排序）来提高效率<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string14.png"></li>
<li>性能<ul>
<li>标准快速排序的性能与字符串的长度乘以2N*lnN成正比</li>
<li>三向字符串排序的运行时间则与N乘以字符串的长度（需要发现所有的相同开头字母）再加上2N*lnN次比较（对剩下的较短部分进行排序）的和成正比</li>
</ul>
</li>
</ul>
</li>
<li>字符串排序算法的选择<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string15.png"></li>
</ul>
</li>
<li>单词查找树<ul>
<li>定义<ul>
<li>由字符串键中的所有字符构造而成，允许使用被查找键中的字符进行查找</li>
<li>和各种查找树一样，单词查找树也是由链接的结点所组成的数据结构，这些链接可能为<strong>空</strong>，也可能指向其他结点</li>
<li>每个结点都只可能有一个指向它的结点，称为它的<strong>父结点</strong>（只有一个结点除外，即根结点，没有任何结点指向根结点）</li>
<li>每个结点都含有条链接，其中为字母表的大小</li>
<li><strong>值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作</strong><br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string16.png"></li>
</ul>
</li>
<li>查找操作<ul>
<li>单词查找树中的每个结点都包含了下一个可能出现的所有字符的链接，直到到达键的最后一个字母所指向的结点或是遇到了一条空链接。这时可能：</li>
<li>键的尾字符所对应的结点中的值非空（如图shells和she的示例）。这是一次命中的查找——键所对应的值就是键的尾字符所对应的结点中保存的值</li>
<li>键的尾字符所对应的结点中的值为空（如图shell的示例）。这是一次未命中的查找——符号表中不存在被查找的键</li>
<li>查找结束于一条空链接（如图shore的示例）。这也是一次未命中的查找<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string17.png"></li>
</ul>
</li>
<li>插入操作<ul>
<li>在插入之前进行一次查找，如前文所述，可能遇到以字母结点为结尾或者空链接为结尾<ul>
<li>在到达键的尾字符之前就遇到了一个空链接<ul>
<li>在这种情况下，单词查找树中不存在与键的尾字符对应的结点</li>
<li>因此需要为键中还未被检查的每个字符创建一个对应的结点并将键的值保存到最后一个字符的结点中</li>
</ul>
</li>
<li>在遇到空链接之前就到达了键的尾字符<ul>
<li>在这种情况下，和关联数组一样，将该结点的值设为键所对应的值（无论该值是否为空）<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string18.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>结点的表示<ul>
<li>每个结点都含有R个链接，对应着每个可能出现的字符</li>
<li>字符和键均隐式地保存在数据结构中<br><img src="/2022/04/11/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%BA%94%E7%AB%A0/string19.png"> </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-算法-第四章</title>
    <url>/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第四章-图"><a href="#第四章-图" class="headerlink" title="第四章 图"></a>第四章 图</h2><ul>
<li>无向图<ul>
<li>定义<ul>
<li>图是由一组顶点和一组能够将两个顶点相连的边组成的</li>
<li>边（edge）仅仅是两个顶点（vertex）之间的连接</li>
<li>一般使用0至V-1来表示一张含有V个顶点的图中的各个顶点</li>
<li>我们用v-w的记法来表示连接v和w的边，w-v是这条边的另一种表示方法<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph1.png"></li>
</ul>
</li>
<li>特殊的图<ul>
<li>自环，即一条连接一个顶点和其自身的边</li>
<li>连接同一对顶点的两条边称为平行边<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph2.png"></li>
</ul>
</li>
<li>术语定义<ul>
<li>当两个顶点通过一条边相连时，我们称这两个顶点是<strong>相邻的</strong>，并称这条边<strong>依附于</strong>这两个顶点</li>
<li>某个顶点的<strong>度数</strong>即为依附于它的边的总数。<strong>子图</strong>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图</li>
<li>在图中，<strong>路径</strong>是由边顺序连接的一系列顶点</li>
<li><strong>简单路径</strong>是一条没有重复顶点的路径</li>
<li><strong>环</strong>是一条至少含有一条边且起点和终点相同的路径</li>
<li><strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环</li>
<li>路径或者环的<strong>长度</strong>为其中所包含的边数</li>
<li>大多数情况下，我们研究的都是简单环和简单路径并会省略掉<strong>简单</strong>二字</li>
<li>当允许重复的顶点时，我们指的都是<strong>一般</strong>的路径和环</li>
<li>当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是<strong>连通</strong>的</li>
<li><strong>无环图</strong>是一种不包含环的图</li>
<li><strong>树</strong>是一幅无环连通图。互不相连的树组成的集合称为<strong>森林</strong>。连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树</li>
<li>图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph3.png"></li>
<li>图的<strong>密度</strong>是指已经连接的顶点对占所有可能被连接的顶点对的比例<ul>
<li>在<strong>稀疏图</strong>中，被连接的顶点对很少；而在<strong>稠密图</strong>中，只有少部分顶点对之间没有边连接</li>
<li>如下图中，V=顶点数，E=边数<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph5.png"></li>
</ul>
</li>
<li><strong>二分图</strong>是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分<ul>
<li>看下图例子，即每条边的两个顶点颜色不一样，分属不同的集合<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph4.png"></li>
</ul>
</li>
</ul>
</li>
<li>无向图的数据表示<ul>
<li>无向图的API<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph6.png"></li>
<li>最常用的图处理代码<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph7.png"></li>
<li>图的几种表示方式<ul>
<li>基本要求<ul>
<li>它必须为可能在应用中碰到的各种类型的图预留出足够的空间</li>
<li>Graph的实例方法的实现一定要快——它们是开发处理图的各种用例的基础</li>
</ul>
</li>
<li>方案<ul>
<li><strong>邻接矩阵</strong>。我们可以使用一个V乘V的布尔矩阵。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素值为true，否则为false<ul>
<li>这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的，V^2个布尔值所需的空间是不能满足的</li>
<li>无法表示平行边</li>
</ul>
</li>
<li><strong>边的数组</strong>。我们可以使用一个Edge类，它含有两个int实例变量<ul>
<li>这种表示方法很简洁但不满足第二个条件——要实现adj()需要检查图中的所有边</li>
</ul>
</li>
<li><strong>邻接表数组</strong>。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表，参见下图<ul>
<li>这种数据结构能够同时满足典型应用所需的以上两个条件，我们会在本章中一直使用它<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph8.png"></li>
<li>性能：<ul>
<li>使用的空间和V+E成正比</li>
<li>添加一条边所需的时间为常数</li>
<li>遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数）</li>
</ul>
</li>
<li><strong>边的插入顺序决定了Graph的邻接表中顶点的出现顺序</strong><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph9.png"></li>
</ul>
</li>
</ul>
</li>
<li>graph数据类型<ul>
<li>这份Graph的实现使用了一个由顶点索引的整型链表数组。每条边都会出现两次，即当存在一条连接v与w的边时，w会出现在v的链表中，v也会出现在w的链表中<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph10.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph11.png">  </li>
</ul>
</li>
</ul>
</li>
<li>典型Graph实现的性能复杂度<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph12.png"></li>
<li>图的处理算法的设计模式<ul>
<li>需要设计search方法：找到和起点s连通的所有顶点<ul>
<li>第一章的union-find算法是一种实现</li>
</ul>
</li>
<li>设计marked方法：判断v和s是联通的吗</li>
<li>设计count方法：计算与s联通的顶点数<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graph13.png"> <span id="more"></span></li>
</ul>
</li>
</ul>
</li>
<li>深度优先搜索算法（DFS）<ul>
<li>迷宫的Tremaux搜索<ul>
<li>选择一条没有标记过的通道，在你走过的路上铺一条绳子</li>
<li>标记所有你第一次路过的路口和通道</li>
<li>当来到一个标记过的路口时（用绳子）回退到上个路口</li>
<li>当回退到的路口已没有可走的通道时继续回退</li>
<li>绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch1.png"></li>
</ul>
</li>
<li>深度优先搜索（DFS）<ul>
<li>要搜索一幅图，只需用一个递归方法来遍历所有顶点<ul>
<li>将它标记为已访问</li>
<li>递归地访问它的所有没有被标记过的邻居顶点<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch2.png"></li>
</ul>
</li>
</ul>
</li>
<li>单向通道<ul>
<li>在Tremaux搜索中，要么是第一次访问区别了边的遍历方向的画法一条边，要么是沿着它从一个被标记过的顶点退回</li>
<li>在无向图的深度优先搜索中，在碰到边vw时，要么进行递归调用（w没有被标记过），要么跳过这条边（w已经被标记过）<ul>
<li>顶点2是顶点0之后第一个被访问的顶点，因为它正好是0的邻接表的第一个元素</li>
<li>深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch3.png"></li>
</ul>
</li>
</ul>
</li>
<li>深度优先搜索的详细轨迹<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch4.png"></li>
<li>寻找路径<ul>
<li>构造函数接受一个起点s作为参数，计算s到与s连通的每个顶点之间的路径<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch6.png"></li>
<li>实现方式<ul>
<li>记住每个顶点到起点的路径，而不是记录当前顶点到起点的路径</li>
<li>在由边v-w第一次访问任意w时，将edgeTo[w]设为v来记住这条路径。换句话说，v-w是从s到w的路径上的最后一条已知的边</li>
<li>类似于union-find算法，在到达s之前，将遇到的所有顶点都压入栈中。将这个栈返回为一个Iterable对象帮助用例遍历s到v的路径</li>
<li>edgeTo[w]=v表示v-w是第一次访问w时经过的边。edgeTo[]数组是一棵用父链接表示的以s为根且含有所有与s连通的顶点的树<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch5.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch7.png"> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>广度优先搜索算法（BFS）<ul>
<li>深度优先算法无法解决找出某个点到起始点的最短路径</li>
<li><strong>从s开始，在所有由一条边就可以到达的顶点中寻找v，如果找不到我们就继续在与s距离两条边的所有顶点中查找v，如此一直进行</strong><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch8.png"> </li>
<li>相比深度优先算法，<strong>使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可</strong>（从实现上来说，这几乎就是唯一的区别）<ul>
<li>先将起点加入队列，然后重复以下步骤直到队列为空</li>
<li>取队列中的下一个顶点v并标记它</li>
<li>将与v相邻的所有未被标记过的顶点加入队列<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch9.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch10.png"> </li>
<li>代码实现<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch11.png"> </li>
<li>和深度优先搜索一样，一旦所有的顶点都已经被标记，余下的计算工作就只是在检查连接到各个已被标记的顶点的边而已</li>
</ul>
</li>
</ul>
</li>
<li>具体问题解决<ul>
<li>连通分量<ul>
<li>问题描述：给定一副图，找出其中相连的顶点，如1-2-3-4相连，7-8相连，则输出两组数据，1-2-3-4和7-8</li>
<li>具体实现<ul>
<li>深度优先算法<ul>
<li>使用了marked[]数组来寻找一个顶点作为每个连通分量中深度优先搜索的起点</li>
<li>第一次调用的参数是顶点0——它会标记所有与0连通的顶点</li>
<li>然后构造函数中的for循环会查找每个没有被标记的顶点并递归调用dfs()来标记和它相邻的所有顶点</li>
<li>另外，它还使用了一个以顶点作为索引的数组id[]，将同一个连通分量中的顶点和连通分量的标识符关联起来（int值）<ul>
<li>这里，标识符0会被赋予第一个连通分量中的所有顶点，1会被赋予第二个连通分量中的所有顶点，依此类推<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch12.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch13.png"> </li>
</ul>
</li>
</ul>
</li>
<li>union-find算法<ul>
<li>具体实现见第一章</li>
<li>和深度优先算法的比较<ul>
<li>理论上，深度优先搜索更快，因为它能保证所需的时间是常数而union-find算法不行<ul>
<li>实际应用中还是union-find算法更快</li>
</ul>
</li>
<li>不需要完整地构造并表示一幅图</li>
<li>union-find算法是一种动态算法（我们在任何时候都能用<strong>接近常数</strong>的时间检查两个顶点是否连通，甚至是在添加一条边的时候）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>判断一个图是否是无环图<ul>
<li>问题描述：给定一副图，假设不存在自环和平行边，判断该图不存在环（<strong>环</strong>是一条至少含有一条边且起点和终点相同的路径）<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch14.png"></li>
</ul>
</li>
<li>判断一个图是否是二分图（又称双色问题）<ul>
<li>问题描述，给定一副图，能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同吗<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/graphsearch15.png"></li>
</ul>
</li>
</ul>
</li>
<li>符号图<ul>
<li>处理字符串形式的顶点</li>
<li>定义输入<ul>
<li>顶点名为字符串</li>
<li>用指定的分隔符来隔开顶点名（允许顶点名中含有空格）</li>
<li>每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点</li>
<li>顶点总数V和边的总数E都是隐式定义的<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/stringgraph1.png"></li>
</ul>
</li>
<li>二分图可以实现反向索引（？）TODO<ul>
<li>举例来说，用电影名查到演员是正向索引，那么用演员查到电影名就是反向索引</li>
</ul>
</li>
<li>实现<ul>
<li>用到了以下3种数据结构<ul>
<li>一个符号表st，键的类型为String（顶点名），值的类型为int（索引）</li>
<li>一个数组keys[]，用作反向索引，保存每个顶点索引所对应的顶点名</li>
<li>一个Graph对象G，它使用索引来引用图中顶点<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/stringgraph2.png"></li>
</ul>
</li>
</ul>
</li>
<li>间隔的度数问题（？）TODO</li>
</ul>
</li>
</ul>
</li>
<li>有向图<ul>
<li>术语定义<ul>
<li>一幅有方向性的图（或有向图）是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点</li>
<li>我们称一条有向边由第一个顶点指出并指向第二个顶点</li>
<li>一个顶点的<strong>出度</strong>为由该顶点指出的边的总数</li>
<li>一个顶点的<strong>入度</strong>为指向该顶点的边的总数</li>
<li>一条有向边的第一个顶点称为它的<strong>头</strong>，第二个顶点则被称为它的<strong>尾</strong></li>
<li>在一幅有向图中，<strong>有向路径</strong>由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点</li>
<li><strong>有向环</strong>为一条至少含有一条边且起点和终点相同的有向路径</li>
<li><strong>简单有向环</strong>是一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环</li>
<li>路径或者环的<strong>长度</strong>即为其中所包含的边数<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph1.png"></li>
</ul>
</li>
<li>有向图的数据类型<ul>
<li>有向图的API<ul>
<li>Digraph的API中还添加了一个方法reverse()。它返回该有向图的一个副本，但将其中所有边的方向反转<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph2.png"></li>
</ul>
</li>
<li>有向图的表示：我们使用邻接表来表示有向图，其中边v→w表示为顶点v所对应的邻接链表中包含一个w顶点</li>
<li>Digraph数据类型与Graph数据类型基本相同，**区别是addEdge()只调用了一次add()**，而且它还有一个reverse()方法来返回图的反向图<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph3.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph4.png"></li>
<li>有向图的可达性<ul>
<li>单点可达性。给定一幅有向图和一个起点s，回答“是否存在一条从s到达给定顶点v的有向路径？”等类似问题。</li>
<li>多点可达性。给定一幅有向图和顶点的集合，回答“是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？”等类似问题。<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph5.png"></li>
<li>DirectedDFS使用了解决图处理的标准范例和标准的深度优先搜索来解决这些问题。它对每个起点调用递归方法dfs()，以标记遇到的任意顶点。<ul>
<li>使用深度优先搜索在一幅有向图中寻找能够从顶点0到达的所有顶点的轨迹<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph6.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph7.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph8.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>标记清除的垃圾收集<ul>
<li>在一幅有向图中，一个顶点表示一个对象，<strong>一条边则表示一个对象对另一个对象的引用</strong></li>
<li>程序执行的任何时候都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收以便释放内存</li>
<li>标记清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph9.png"></li>
</ul>
</li>
<li>环和有向无环图<ul>
<li>调度问题<ul>
<li>优先级限制：它指明了哪些任务必须在哪些任务之前完成。不同类型的限制条件会产生不同类型不同难度的调度问题</li>
<li>优先级限制下的调度问题<ul>
<li>给定一组需要完成的任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何安排并完成所有任务</li>
<li>转换成有向图的问题描述：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph10.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph11.png"></li>
</ul>
</li>
<li>一般来说，如果一个有优先级限制的问题中存在有向环，那么这个问题肯定是无解的<ul>
<li>一旦我们找到了一条有向边v→w且w已经存在于栈中，就找到了一个<strong>环</strong>，因为栈表示的是一条由w到v的有向路径，而v→w正好补全了这个环<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph12.png"><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph13.png"></li>
</ul>
</li>
</ul>
</li>
<li>拓扑排序<ul>
<li><strong>当且仅当一幅有向图是无环图时它才能进行拓扑排序</strong></li>
<li>拓扑排序的API<br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph14.png"></li>
<li>前序：在递归调用之前将顶点加入<strong>队列</strong></li>
<li>后序：在递归调用之后将顶点加入<strong>队列</strong></li>
<li>逆后序：在递归调用之后将顶点压入<strong>栈</strong><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph15.png"></li>
<li><strong>一幅有向无环图的拓扑顺序即为所有顶点的逆后序排列</strong></li>
</ul>
</li>
</ul>
</li>
<li>强连通性<ul>
<li>如果两个顶点v和w是互相可达的，则称它们为<strong>强连通</strong>的，注意和无向图的区别</li>
<li>如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是<strong>强连通</strong>的</li>
<li>强连通性将所有顶点分为了一些等价类，每个等价类都是由相互均为强连通的顶点的最大子集组成的。我们将这些子集称为<strong>强连通分量</strong><br><img src="/2022/04/07/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0/digraph16.png"></li>
<li>Kosaraju算法（？）TODO<br>// 待续 TODO</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-置身事内</title>
    <url>/2022/03/14/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</url>
    <content><![CDATA[<p><img src="/2022/03/14/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/1.jpg"></p>
<h2 id="第一章-地方政府的权力和事务"><a href="#第一章-地方政府的权力和事务" class="headerlink" title="第一章 地方政府的权力和事务"></a>第一章 地方政府的权力和事务</h2><ul>
<li>第一节 政府治理的特点<ul>
<li>五级政府管理体系：中央-省-市-县区-乡镇</li>
<li><strong>四套领导班子：党委、政府、人大、政协等，在五级政府下都完全复制</strong><ul>
<li>条条块块：既有垂直的上下关系，又有横向的行政区划</li>
<li>如县教育局受上级的市教育局管辖，又受县市政府管辖</li>
</ul>
</li>
<li>官僚体系<ul>
<li>官员学习和贯彻统一的意识形态</li>
<li>由上级任命</li>
<li>地方官在多地轮流任职</li>
</ul>
</li>
</ul>
</li>
<li>第二节 外部性和经济规模<ul>
<li>公共服务<ul>
<li>覆盖区域使用人数越多越好</li>
<li>行政区划的范围</li>
<li>边远地区是否有必要建设公共服务</li>
</ul>
</li>
<li>人口密度<ul>
<li>云南-腾冲线：43%东边面积占了94%人口</li>
<li>密度高的地方区划要小，密度低的地方区划要大</li>
<li>政策上会对城市群进行规划，以打破交界</li>
<li>人为划分意图消除边界不一定有好效果，主要还是受地理因素影响</li>
</ul>
</li>
<li>行政交界处<ul>
<li>交界处三不管，经济一般更差</li>
<li>边界处交通网路会更疏</li>
<li>环境问题，污染排向边界处</li>
<li>长期看，需要进行深化的市场化改革</li>
<li>中短期通过行政区划调整和都市圈</li>
</ul>
</li>
</ul>
</li>
<li>第三节 复杂信息<ul>
<li><strong>实际权威来自信息优势</strong></li>
<li>下级具有信息优势</li>
<li>上级只有形式权威，办事最终还是要看下级意愿</li>
</ul>
</li>
<li>第四节 激励相容<ul>
<li>专业性较强的部门一般受垂直上下级的约束较大，如海关，工商部门等</li>
<li>完全受垂直上下级管理，会减弱地方监管力度，因此需要平衡</li>
<li>中央做好约束，同时也让地方发挥更大的自治权</li>
</ul>
</li>
<li><strong>第二至第四节就是事权划分的三大原则</strong></li>
<li>第五节 招商引资<ul>
<li>地方政府给予企业土地开发支持</li>
<li>地方政府给予企业金融支持</li>
<li>地方政府给予补贴和税收优惠</li>
<li>地方政府提供招工服务<span id="more"></span>    </li>
</ul>
</li>
</ul>
<h2 id="第二章-财税与政府行为"><a href="#第二章-财税与政府行为" class="headerlink" title="第二章 财税与政府行为"></a>第二章 财税与政府行为</h2><ul>
<li>第一节 分税制改革<ul>
<li>财政包干 1985-1993<ul>
<li>农村土地承包，城市企业承包，政府财政承包</li>
<li>地方根据实际进行不同形式的承包和分账<ul>
<li>北京确定一个增长比例，超过部分归北京所有，没超过部分和中央55分账</li>
<li>广州按照1987年上缴的基数，每年递增9%归中央，剩余归自己</li>
<li>上海定额上缴，每年缴105亿</li>
</ul>
</li>
<li>地方比较有动力增加财政收入，促进了企业的发展</li>
<li>地方财政收入增长较快，但是由于承包上缴，导致中央的财政收入增长很慢，造成中央政府很穷</li>
<li>地方也通过各种手段帮助企业减税，进一步导致中央收入变少</li>
<li>影响中央对于整体经济的调控</li>
</ul>
</li>
<li>分税制改革<ul>
<li>分为中央税、地方税、共享税</li>
<li>同时分设国税、地税两套机构，与地方财政部门脱钩</li>
<li>中央设立税收返还机制，防止地方税收急剧下降</li>
<li>改革后中央收入剧增，增强了宏观调控能力</li>
</ul>
</li>
</ul>
</li>
<li>第二节 土地财政<ul>
<li>招商引资<ul>
<li>地方财政更喜欢重资产的制造业<ul>
<li>投资规模大</li>
<li>增值税在生产环节增收，跟生产规模挂钩</li>
<li>制造业可以吸收低技能劳动力，并带动第三产业发展</li>
</ul>
</li>
<li>重生产而轻环保，轻民生</li>
</ul>
</li>
<li>土地公有制<ul>
<li>城市土地归国家所有，农村土地归集体所有</li>
<li>农村土地要建设，必须先转为国有</li>
<li>土地转让金额随着城市化进展开始大幅增加</li>
</ul>
</li>
<li>任期内政府过度借债导致下任政府难以为继</li>
</ul>
</li>
<li>第三节 纵向不平衡和横向不平衡<ul>
<li>基层财政<ul>
<li>落后地区的税收收入较低，导致政府很难展开工作</li>
<li><strong>三农问题：农民苦，农村穷，农业危险</strong><ul>
<li>统筹城乡发展</li>
<li>废除农业税</li>
<li>农村公共服务开支纳入国家财政</li>
<li>转移支付制度中加入激励机制，以精简政府机构</li>
<li>地方财政归上一级政府统筹，乡财县管</li>
<li>放权给县级政府，缩小城乡差距</li>
</ul>
</li>
<li>“乡财县管”和“省直管县”改革，只适用于浙江等发达地区，不发达地区效果不佳</li>
</ul>
</li>
<li>地区间不平等<ul>
<li>中央转移支付，使得落后地区的平均财政支出和发达地区差不多</li>
<li>一般转移支付：条件少，可以自行决定用途。导致越穷的地方拿到越多，影响创收动力。</li>
<li>专项转移支付：项目专项资金。由于发达地区更可能做好项目，导致发达地区拿到越多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章-政府投融资与债务"><a href="#第三章-政府投融资与债务" class="headerlink" title="第三章 政府投融资与债务"></a>第三章 政府投融资与债务</h2><ul>
<li>第一节 城投公司与土地金融<ul>
<li>地方政府不能从银行贷款，因此通过成立国资企业进行融资<ul>
<li>持有政府的土地使用权，因此可以撬动银行贷款，快速扩展</li>
<li>盈利状况依赖政府补贴</li>
<li>可以获得政府担保，融资更容易</li>
</ul>
</li>
<li>工业园区开发<ul>
<li>一种由国企承当，投资大，盈利低，靠后期运营来实现盈利</li>
<li>一种由私企承当，通过开发房地产来反哺工业区实现盈利</li>
</ul>
</li>
</ul>
</li>
<li>第二节 地方政府债务<ul>
<li>城投公司，始于国开行</li>
<li>城商行由地方政府控制，和国开行相比<ul>
<li>资金多来于中短期存款，风险较大</li>
<li>存款来源不稳定</li>
</ul>
</li>
<li>地方债务水平<ul>
<li>估计占gdp六成左右，虽然不低，但和美日相比依然不算多</li>
<li>低一级的政府以及落后地区债务风险大</li>
</ul>
</li>
<li>债务治理<ul>
<li>债务置换，用地方政府的公债替换融资公司的银行贷和城投债</li>
<li>推动融资平台转型，剥离为政府融资的功能</li>
<li>约束银行和金融机构的资金流入融资平台</li>
<li>对过度负债终身追责</li>
</ul>
</li>
</ul>
</li>
<li>第三节 招商引资中的地方官员<ul>
<li>官员政绩<ul>
<li>经济发展是官员的主要政绩，因此新官上任都会大兴土木，导致城市规模虽然变大，但是整体效率较低</li>
<li>中央强调不已gdp作为政绩考核的主要指标</li>
<li>除了晋升和激励，内在的道德驱动也是官员的重要动力</li>
</ul>
</li>
<li>腐败问题<ul>
<li>近年来的腐败多与土地开发有关</li>
<li>腐败与经济高速发展长期并存</li>
<li>官商勾连腐败，政府将项目给关系户<ul>
<li>长期偏重投资导致资本收入增长高于老百姓收入增长</li>
<li>扭曲投资和信贷资源配置，把大量资金浪费在效益不高的关系户项目上，推升债务负担和风险</li>
<li>扩大贫富差距</li>
<li>形成利益集团，不利于市场发展</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四章-工业化中的政府角色"><a href="#第四章-工业化中的政府角色" class="headerlink" title="第四章 工业化中的政府角色"></a>第四章 工业化中的政府角色</h2><ul>
<li>第一节 京东方与政府投资<ul>
<li>20世纪90年代，液晶屏巨头们联手抬高价格，垄断市场</li>
<li>京东方在此背景下获得了政府大量投资<ul>
<li>初代时购买了价格峰值的液晶面板，在低谷时生产出了成品，导致大量亏损</li>
<li>改用股权融资：先向地方政府筹本金，不足部分再贷款</li>
<li>新的融资方式获得了更多资金，同时也赶来智能手机的爆发，获得了盈利</li>
</ul>
</li>
<li>政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应</li>
<li>新兴制造业在地理上的集聚效应很强</li>
<li>政府扶持也吸引了一些并无技术实力和竞争力的小企业进入该行业，引发了对产能过剩的担忧</li>
</ul>
</li>
<li>第二节 光伏发展和政府补贴<ul>
<li>2000 - 2010年，大量光伏企业获得政府补贴，急剧扩张</li>
<li>随着金融危机，以及成本高于煤电，光伏企业累积了大量的债务，导致倒闭</li>
<li>补贴电价下调，但是企业的技术积累和成本降幅依然快于补贴降幅，使得光伏迅猛发展</li>
<li>政府补贴造就了光伏的需求</li>
<li>政府补贴有助于新技术起步时的发展</li>
<li>产业政策要有推出机制<ul>
<li>政策本身要有推出机制，如光电补贴逐步降低</li>
<li>低效企业破产退出的渠道要畅通</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-城市化与不平衡"><a href="#第五章-城市化与不平衡" class="headerlink" title="第五章 城市化与不平衡"></a>第五章 城市化与不平衡</h2><ul>
<li>第一节 房价与居民债务<ul>
<li>土地供需<ul>
<li>现代经济集聚效应很强，经济活动及就业越来越向大城市集中</li>
<li>地区房价差异的主要原因是供需失衡</li>
<li>中国对建设用地指标实行严格管理，每年的新增指标由中央分配到省，再由省分配到地方</li>
<li>建设用地指标不能在全国交易，土地使用效率很难提高</li>
</ul>
</li>
<li>欧美房价与居民债务<ul>
<li>二战之前，欧美自有住房比例很低，大部分为租房</li>
<li>欧美自有住房比例上升后<ul>
<li>房产在居民资产中的比例上升</li>
<li>政府开始降低卖房门槛和按揭比例</li>
</ul>
</li>
<li>美国出于政治选票因素，大量房贷给低收入者买房，导致坏账变多，引发次贷危机<ul>
<li>导致房价降低</li>
<li>进而抑制消费</li>
</ul>
</li>
<li>房地产常被称作“经济周期之母”<ul>
<li>银行可以通过按揭创造无限的购买力</li>
<li>不可再生的城市土地供给有限</li>
</ul>
</li>
</ul>
</li>
<li>我国房价与居民债务<ul>
<li>2008年后，房价急速上升<ul>
<li>居民债务负担上涨3倍多，占GDP的54%</li>
<li>平均债务约等于居民1.6倍年收入</li>
</ul>
</li>
<li>影响消费</li>
</ul>
</li>
<li>房价与居民债务风险<ul>
<li>拉大各地的资产差距</li>
<li>消费下滲：刺激低收入者举债消费</li>
<li>借贷比例上升，影响未来收入增长，导致债务负担变重</li>
<li>负债率高更容易受到房价下跌的影响</li>
<li>我国的金融危机概率低<ul>
<li>首付比例30%，不会如美国可以低到0</li>
<li>信贷资产没有层层嵌套，导致风险放大</li>
<li>资本账户管制，限制外国资产参与我国房市</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二节 不平衡与要素市场改革<ul>
<li>低收入者到发达城市是提高收入最简单的途径</li>
<li>地方政府偏重投资，收入分配偏向资本，降低劳动收入占比</li>
<li>需要平衡人均规模，而不是总体规模</li>
<li>关键要让劳动力自由流动<ul>
<li>提高城市市场规模，分工细，使得低技能者也能有高收入</li>
<li>低技能者服务业支撑城市生活质量</li>
<li>城市规模的上升也能促进地区间的分工和流动</li>
</ul>
</li>
<li>土地流转<ul>
<li>2008年提出城乡统一的建设用地市场与国有土地享有平等权益</li>
<li>2015年试点三块地改革，即农村土地征收、集体经营性建设用地入市以及宅基地制度改革</li>
<li>2017年在租赁住房供需矛盾突出的超大和特大城市，开展集体建设用地上建设租赁住房试点</li>
<li>三条底线<ul>
<li>土地公有制性质不变</li>
<li>耕地红线不突破</li>
<li>农民利益不受损</li>
</ul>
</li>
</ul>
</li>
<li>户籍改革<ul>
<li>逐步取消农业户口和非农业户口差别</li>
<li>2019年发改委提出放宽各类城市落户限制</li>
<li>未来方向<ul>
<li>建立健全城乡统一的建设用地市场</li>
<li>深化户籍制度改革</li>
<li>以经常居住地登记户口制度</li>
<li>基本公共服务与常住人口挂钩机制，推动公共资源按常住人口规模配置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三节 经济发展与贫富差距<ul>
<li>全球贫困人口急剧下降，主要贡献来自于中国</li>
<li>70后，经济快速增长使得财富继承的重要性下降，个人更看重自己的劳动收入</li>
<li>80，90后，房价的上涨使得财富继承重要性上升，拉大贫富差距</li>
<li>隧道效应：经济增长放缓，对穷人的影响更大</li>
</ul>
</li>
</ul>
<h2 id="第六章-债务与风险"><a href="#第六章-债务与风险" class="headerlink" title="第六章 债务与风险"></a>第六章 债务与风险</h2><ul>
<li>第一节 债务与经济衰退<ul>
<li>债务危机的爆发和蔓延非常迅速<ul>
<li>负债率高的经济中，资产价格下降速度也更快</li>
<li>资产价格下跌引起信贷收缩，导致资金链断裂</li>
<li>债务常常将风险集中到承受能力最弱的穷人身上</li>
</ul>
</li>
</ul>
</li>
<li>第二节 欧美债务的教训<ul>
<li>布雷顿森林体系<ul>
<li>各国货币以固定比例与美元挂钩</li>
<li>美元以固定比例与黄金挂钩</li>
<li>各国需要充足的外汇干预市场，防止汇率波动</li>
<li>因此国际资本流动规模不能太大，否则会冲破某些国家的外汇储备</li>
<li>因此要限制国内银行放贷，这样就能限制居民的进出口消费</li>
</ul>
</li>
<li>自由化浪潮<ul>
<li>各国实现浮动汇率</li>
<li>放松了贷款限制</li>
<li>银行危机风险加剧，在布雷顿森林体系下，1945-1970，只发生2次银行危机，自由化浪潮下，1980-2010发生了153次银行危机</li>
</ul>
</li>
<li>金融危机源头<ul>
<li>银行规模大，杠杆高</li>
<li>银行借进来的钱很多是短期的（比如活期存款），但贷出去的钱却大都是长期的（比如企业贷款），这种负债和资产的期限不匹配会带来流动性风险。</li>
<li>银行信贷大都和房地产有关，常常与土地和房产价值一同起落，放大经济波动</li>
<li>银行很少雪中送炭，却常常晴天送伞，繁荣时慷慨解囊、助推经济过热，衰退时却捂紧口袋、加剧经济下行</li>
<li>银行风险会传导到其他金融部门</li>
</ul>
</li>
<li>不平衡问题<ul>
<li>东亚贸易不平衡使得中国1997年金融危机中美元储备不足导致经济受损，因此之后大量买入美国国债</li>
<li>欧洲和美国贸易平衡，但是总量大，交易规模变大后，风险也变大</li>
<li>富人借债给穷人，拉大贫富差距</li>
</ul>
</li>
<li>实体企业投资不足<ul>
<li>投资流向了发展中国家</li>
<li>通信技术发展，使得资产涌入非失业和服务业</li>
<li>大企业规模越来越大，竞争性不足</li>
</ul>
</li>
</ul>
</li>
<li>第三节 中国债务与风险<ul>
<li>相比其他发展中国家，我国债务水平较低</li>
<li>债务累计过程<ul>
<li>08年为应对金融危机，出台4万亿计划</li>
<li>降准降息，放宽信贷</li>
<li>10-11年，经济过热，通胀加剧</li>
<li>欧债危机爆发后，国内制造业吃紧，央行继续降准降息</li>
<li>15年股灾后，美国量化宽松，导致资本外流，人民币汇率降低</li>
<li>导致央行的进一步降准降息，带动房价上涨</li>
</ul>
</li>
<li>企业债务<ul>
<li>地方政府投资基建，投资回报率低</li>
<li>国进民退问题，国企快速扩张，效率却较低，提升整体债务负担</li>
<li>推进改革<ul>
<li>推进国企混改，限制地方政府干预</li>
<li>加强金融监管，从源头上拧紧资金的水龙头</li>
<li>在要素市场上推行更加全面的改革，让市场力量在资金、土地、技术、劳动力等生产要素配置中发挥更大作用</li>
<li>改革和完善《企业破产法》，在债务重整过程中“去行政化”，避免地方官员主导企业破产重组，损害债权人利益</li>
</ul>
</li>
<li>房地产债务占总体债务比重较大</li>
<li>优质抵押物或者政府担保，可以使得银行的借贷风险降低                                                </li>
<li>影子银行<ul>
<li>银行通过卖理财产品筹得钱款</li>
<li>筹来的钱委托给信托公司  </li>
<li>信托公司将钱借给公司</li>
<li>理财产品不算银行储蓄，委托给信托公司的钱不算银行贷款，因此摆脱对银行的监管，成了影子银行</li>
</ul>
</li>
<li>2018年资管新规出台，打压了影子银行，同时也打压了小企业的融资渠道</li>
</ul>
</li>
</ul>
</li>
<li>第四节 化解债务危机<ul>
<li>压缩支出的方式<ul>
<li>收入减少是连锁反应，导致经济整体下行</li>
<li>债务负担可能反而上升</li>
<li>让债权人和债务人都痛苦</li>
</ul>
</li>
<li>增发货币<ul>
<li>08年金融危机前的主流做法</li>
<li>刺激投资和消费</li>
<li>温和的通货膨胀</li>
<li>没有明显的受损方</li>
</ul>
</li>
<li><strong>量化宽松</strong><ul>
<li>金融危机后主流做法</li>
<li>增发货币买入资产，维持资产价值</li>
<li>相当于将其他地方的负债转移到央行</li>
<li>理论上央行可以无限印钱，所以可以无限消化负债</li>
<li>不会过度通货膨胀，因为其他地方挣了钱会优先还债，支出并没有显著增加</li>
<li>难以刺激消费，依然帮助了富人消化债务，拉大贫富差距</li>
</ul>
</li>
<li>赤字货币化<ul>
<li>政府加大财政支出去刺激经济，由财政部发债融资，央行直接印钱买过来，无需其他金融机构参与也无需支付利息</li>
<li>用无利率的货币替代有利率的债务，以政府预算收支的数量代替金融市场的价格（即利率）来调节经济资源配置</li>
<li>会引发物价飞涨的恶性通货膨胀（国民党的教训）</li>
</ul>
</li>
<li>遏制新债务<ul>
<li>围绕供给侧结构性改革所推行的一系列重大经济金融改革</li>
<li>资本市场改革，改变以银行贷款为主的间接融资体系，拓展直接融资渠道，既降低债务负担，也提高资金使用效率</li>
<li><strong>我国债务风险的本质不是金融投机的风险，而是财政和资源分配机制的风险</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-国内国际失衡"><a href="#第七章-国内国际失衡" class="headerlink" title="第七章 国内国际失衡"></a>第七章 国内国际失衡</h2><ul>
<li>第一节 低消费与产能过剩<ul>
<li>消费不足<ul>
<li>2018年消费占gdp比重只有44%，而美国这一比例达到70%</li>
<li>从1980到2010年，消费比重从65%降到50%</li>
<li>居民可支配收入下降</li>
<li>居民储蓄率上升</li>
</ul>
</li>
<li>高储蓄率<ul>
<li>20世纪90年代储蓄率达到了25-30%，欧美这一比例一般在10%左右</li>
<li>计划生育导致下一代数量减少，养儿防老不可靠，导致需要存钱应对老年</li>
<li>政府民生支出不足</li>
<li>房价上升拉低消费，提高了储蓄</li>
</ul>
</li>
<li>地方政府推动工业化的方式加速了资本份额的上升和劳动份额的下降</li>
<li>国民经济分配中居民占比下降，政府和企业的占比就必然上升</li>
<li>经济到一定阶段后，不再是任何投资都有回报<ul>
<li>基础设施和工业体系已经比较完善， 投资难度加大</li>
<li>由于老百姓收入和消费不足，无法消化投资形成的产能，很多投资不能变成有效的收入，都浪费掉了，所以债务负担越积越重，带来了一系列风险</li>
<li>劳动收入份额下降和资本收入份额上升，会扩大贫富差距</li>
<li>由于消费不足和投资过剩，过剩产能必须向国外输出，输出产能会加重全球贸易失衡，引发贸易冲突</li>
</ul>
</li>
<li><strong>居民收入增长快于经济增长，居民收入份额才能提高</strong></li>
<li>过多的无用投资没带来收入，虽然gdp增长了，但是债务会积累，在未来爆发</li>
<li>对外贸易失衡也是内部结构失衡的延续</li>
</ul>
</li>
<li>第二节 中美贸易冲突<ul>
<li>只要全世界还信任美元的价值，美国就可以源源不断地用美元去换取他国实际的产品和资源</li>
<li>美国所谓的中国制造抢走美国工作并不确切<ul>
<li>美国制造业就业本身就一直在下降</li>
<li>制造业gdp占比一直很稳定，事实上是机器效率提高取代了人工</li>
</ul>
</li>
<li>民粹主义和全球化情绪爆发，引发美国人对于贸易保护的倾向</li>
<li>制造业和科学领域，各项指标已经开始毕竟甚至赶超美国</li>
<li>工业制造是科学进步的基础</li>
</ul>
</li>
<li>第三节 <strong>再平衡与国内大循环</strong><ul>
<li>要提高居民收入，就要继续推进城市化，让人口向城市尤其是大城市集聚</li>
<li>从目前的技术发展和发达国家的经验看，制造业的进一步发展吸纳不了更多就业</li>
<li>改革的关键是转变地方政府在经济中扮演的角色，遏制其投资冲动，降低其生产性支出，加大民生支出</li>
<li>要提高居民收入，还要扩宽居民的财产性收入，发展各种直接融资渠道，让更多人有机会分享经济增长的果实，这就涉及金融体系和资本市场的改革</li>
<li>“双循环”战略在强调“再平衡”和扩大国内大市场的同时，也强调了要扩大对外开放</li>
</ul>
</li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li>英国史学家艾伦的《全球经济史》（2015）</li>
<li>乔治梅森大学戈德斯通的《为什么是欧洲？世界史视角下的西方崛起》（2010）</li>
<li>哈佛大学弗里登的《20世纪全球资本主义的兴衰》（2017）</li>
<li>西北大学戈登的《美国增长的起落》（2018）</li>
<li>哈佛大学教授傅高义《邓小平时代》</li>
<li>《经济落后的历史透视》（格申克龙，2012）</li>
<li>《大转型：我们时代的政治与经济起源》（波兰尼，2020）</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>新闻翻译.1</title>
    <url>/2019/10/10/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-1/</url>
    <content><![CDATA[<p><a href="https://www.latimes.com/politics/story/2019-10-09/trumps-legal-strategy-against-impeachment-shaky-constitutional-grounds-scholars-say">原文链接</a>  </p>
<h2 id="Trump’s-legal-strategy-against-impeachment-is-on-shaky-constitutional-grounds-scholars-say"><a href="#Trump’s-legal-strategy-against-impeachment-is-on-shaky-constitutional-grounds-scholars-say" class="headerlink" title="Trump’s legal strategy against impeachment is on shaky constitutional grounds, scholars say"></a>Trump’s legal strategy against impeachment is on shaky constitutional grounds, scholars say</h2><h3 id="学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据"><a href="#学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据" class="headerlink" title="学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据"></a>学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据</h3><p>1.Washington —  Constitutional lawyers said Wednesday that President Trump’s<br>vow not to cooperate with the impeachment inquiry is both unprecedented and<br>unlikely to spare him from being formally charged by the House.<br>In fact, they say, it may only increase the chances that he will be impeached.<br>华盛顿报道 - 宪法律师周三声明, 川普总统发誓不会与弹劾调查进行合作的言论是<br>前所未有的, 而且也很可能使他面临众议院的正式指控. 并且, 他们还说到, 这有可能<br>增加川普被弹劾的可能.</p>
<p>2.The Constitution says the “House of Representatives shall have the sole<br>power of impeachment,” and it does not give the president a specific role<br>in the process. A president is in some sense like an ordinary defendant<br>who may be subject to a criminal investigation and an indictment,<br>all without his participation or involvement, scholars say.<br>美国宪法里写到, “众议院拥有弹劾的唯一权力”, 而且没有赋予总统在此过程中的任何<br>特殊角色. 学者认为, 总统在整个过程中都不会参与到弹劾中, 某种意义上和普通被告一样,<br>可能面临刑事调查和指控.  </p>
<p>3.“The president’s cooperation is not required or needed,” said University of<br>North Carolina law professor Michael J. Gerhardt, an expert on impeachment.<br>And “the House may make that defiance grounds for impeachment,” he added,<br>noting that in 1974, a House committee approved articles of impeachment against<br>President Nixon based in part on his refusal to comply with congressional subpoenas.<br>北卡罗莱纳大学的法律学教授, 同时也是研究弹劾的专家, Michael J.Gerhardt认为,<br>“总统的配合并不是必需的, 众议院可以把这作为违抗理由去弹劾”. 他还补充到, 1974年,<br>众议院委员会通过了一项弹劾决议, 其部分原因就是尼克松总统拒绝了来自国会的传票. </p>
<span id="more"></span>
<p>4.Though both Nixon and President Clinton tried behind the scenes to slow<br>or stop impeachment proceedings, they also attempted to cooperate at times,<br>or at least appear to, out of respect for the process and fear they might<br>look like they were hiding something.<br>尽管尼克松和克林顿总统都试图在幕后减缓或者阻止弹劾的进程, 但至少他们在当时都是<br>试图配合弹劾工作的, 至少看上去是. 对于弹劾的不尊重和害怕会让他们看起来隐藏了<br>一些事.</p>
<p>5.“There is no precedent for the president doing what President Trump is<br>doing here: saying I will flatly refuse to cooperate and ordering all<br>employees of the executive branch to refuse to cooperate as well,”<br>said professor Frank O. Bowman, who teaches impeachment law at the<br>University of Missouri and Georgetown.<br>来自密苏里和乔治敦大学, 教弹劾法律的教授Frank O.Bowman说:”之前从来没有<br>一份先例像川普总统这样, 说自己断然拒绝合作, 而且还命令所有的行政雇员也拒绝合作.”</p>
<p>6.In Tuesday’s eight-page letter to House Democrats, White House Counsel<br>Pat Cipillone pronounced Trump innocent of wrongdoing and the inquiry<br>“unconstitutional.”<br>周四一份来自白宫的法律顾问Pat Cipillone的八页信件发往了众议院的民主党派,<br>他宣称川普的错误做法是无辜的, 而且弹劾调查也是违宪的.</p>
<p>7.He said Trump’s July 25 phone call asking the new president of Ukraine<br>to do him “a favor” and investigate former Vice President Joe Biden and<br>his son Hunter was “completely appropriate. The president did nothing wrong,<br>and there is no legitimate basis for an impeachment inquiry.”<br>他说, 川普在7月25号致电给乌克兰新总统, 要求他帮助和调查前副总统Joe Biden以及<br>他的儿子Hunter是”完全合理的. 总统没有做错什么, 而且也没有一个合法的法律依据<br>可以支撑弹劾的调查”</p>
<p>8.Legal experts, however, say Trump’s actions were exactly the kinds of<br>things that framers were thinking of when they included an impeachment<br>provision in the Constitution. Trump has acknowledged that even as he asked<br>Ukraine to investigate one of his political opponents, he had ordered<br>that nearly $400 million in aid to Ukraine be withheld.<br>然而法律专家认为, 川普的行为恰好就是制宪者将弹劾条款加入宪法时所考虑过的.<br>川普认识到即使他要求乌克兰去调查他其中的一个政治对手, 他下令资助给乌克兰的<br>将近40亿美元的援助也将被扣留.</p>
<p>9.The White House letter suggests that the inquiry is invalid because<br>there was no formal House vote to launch it, and that Trump and Republicans<br>have so far not been given the right to see evidence and call witnesses.<br>Based on this conclusion, he said, “President Trump and his administration<br>cannot participate in your partisan and unconstitutional inquiry.”<br>白宫的信件认为调查是无效的, 因为没有任何正式的众议院决议去启动这项调查, 而且<br>川普和共和党至今甚至没有权力见到证据和传唤目击者. 基于这些结论, 他说: “川普<br>总统和他的管理团队不会参与到你们的党派和违宪的调查中去”</p>
<p>10.Lawyers took to social media to express surprise and disdain, noting<br>that no such rights or requirements exist in the Constitution.<br>律师在社交媒体上表达了他的惊讶和蔑视, 指出在宪法中不存在这样的权力和请求.</p>
<p>11.“This letter is bananas. A barely-lawyered temper tantrum,” tweeted<br>Gregg Nunziata, a former counsel for Senate Republicans.<br>前任的共和党法律顾问, Gregg Nunziata发推说道:”这封信就是胡闹, 一份没有法律<br>常识的脾气的宣泄”</p>
<p>12.University of Texas law professor Steve Vladeck said it was remarkable<br>for the top White House lawyer to say in writing that it “is completely<br>appropriate for the president of the United States to actively solicit<br>foreign intervention in U.S. presidential elections. Let’s not lose<br>sight of just how insane that is.”<br>德克萨斯大学的法律教授Steve Vladeck表示, 对于一个顶级的白宫律师, 以书面形式<br>说”美国总统积极的寻求外国介入到美国的总统选择中是完全合理的. 让我们不要忘记<br>这是多么疯狂”, 真是太出色了.(这段真是不知道怎么翻译…)</p>
<p>13.Lisa Kern Griffin, a Duke law professor, described the letter as a<br>“political stunt that misinterprets the Constitution, ignores relevant<br>precedents and defies common sense.” She said the letter sets the stage<br>for a constitutional crisis.<br>杜克的法律教授, Lisa Kern Griffin形容这个信是”曲解宪法的政治手段, 忽略了<br>相关的先例, 否决了共识”. 她说这封信为宪法的危机奠定了一个基础.</p>
<p>14.“Of course, the House can proceed with impeachment based on the testimony<br>and evidence it can access, but it strikes me as dangerous for the entire<br>executive branch to defy congressional oversight.”<br>“理所当然的, 众议院可以继续根据已有的证词和证据进行弹劾, 但是令我感到危险的是<br>整个行政部门都违抗国会的监督”</p>
<p>15.Neal K. Katyal, who was acting solicitor general during the Obama administration,<br>noted that Trump’s lawyers have insisted that he is immune from criminal charges,<br>shielded from congressional and state legal demands, including for his tax returns,<br>and now shielded from an impeachment inquiry.<br>在奥巴马政府期间担任代理司法部副部长的Neal K. Katyal指出, 川普的律师坚持他(川普)<br>是免于刑事指控的, 受国会和国家法律要求的保护, 包括他的报税表, 所以现在也保护他免<br>于收到弹劾的调查.</p>
<p>16.Gerhardt said the White House letter “shows nothing but contempt for the<br>law and the Constitution. Its principal argument is that the president is<br>above the law. In fact, he is not. Impeachment is one of the unique constitutional<br>processes for holding the president accountable for abusing his power.”<br>Gerhardt认为白宫信件”展示了对于法律和宪法的蔑视. 这里面的主要内容就是总统<br>凌驾于法律之上. 但事实上, 他是错的. 弹劾是宪法中用于控制总统滥用职权的独特<br>法律条文之一”</p>
<p>17.It’s not clear how or whether House Democrats will respond to Trump’s<br>vow of noncooperation. In recent weeks, leaders of the House inquiry signaled<br>they are reluctant to go to court or seek to hold officials in criminal<br>contempt for refusing to comply with a subpoena.<br>还不清楚众议院民主党派怎么回应或者是否会回应川普拒绝合作的承诺. 在最近几周,<br>众议院调查团队的负责人发出信号, 他们不愿意因为拒绝传票而走上法庭或者让官方<br>人员陷于刑事指控的境地.</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-算法-第一章</title>
    <url>/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm.jpg"></p>
<p><strong>配套网站：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
<h2 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h2><ul>
<li>无论在任何应用领域，精心设计的算法都是解决大型问题最有效的方法</li>
<li>我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为<strong>基础编程模型</strong></li>
<li>java程序的基本语法，同时也是多数程序语言的通用语法<ul>
<li>原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。<ul>
<li>int    32位整数(2^31=2147483648)<ul>
<li>在java中int可表示的范围为（-2147483648——2147483647），2147483648会溢出变为-2147483648，因此Math.abs(-2147483648)=-214783648</li>
</ul>
</li>
<li>double 64位双精度实数</li>
<li>布尔型  true or false</li>
<li>string 字符串</li>
<li>long   64位整数</li>
<li>short  16位整数(2^15=32768)</li>
<li>char   16位字符</li>
<li>byte   8位整数(2^7=128)</li>
<li>float  32位单精度实数</li>
</ul>
</li>
<li>语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：<strong>声明、赋值、条件、循环、调用和返回</strong><ul>
<li>java是一种强类型语言，编译器会检查类型一致性</li>
</ul>
</li>
<li>数组：数组是多个同种数据类型的值的集合</li>
<li>静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序</li>
<li>字符串：字符串是一连串的字符，Java内置了对它们的一些操作</li>
<li>标准输入/输出：标准输入输出是程序与外界联系的桥梁</li>
<li>数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程</li>
</ul>
</li>
<li>不同程序语言的运算符计算优先级会有不同，因此通常情况下用括号来进行优先级的改变</li>
<li>方法的性质<ul>
<li>方法的参数按值传递<ul>
<li>调用方法时传递对象名也是值传递，意味着传递的是对象的别名，也就是对象的引用地址，所以在方法内修改其内容也会影响原始值</li>
</ul>
</li>
<li>方法名可以重载</li>
<li>方法只能返回一个值，但是可以包含多个返回语句</li>
<li>方法可以产生副作用：在本书中，返回值是void的方法就是副作用</li>
</ul>
</li>
<li><strong>递归原则</strong><ul>
<li>递归总是在第一行就要包含一个包含return的条件语句</li>
<li>递归总是尝试先解决一个更小的问题</li>
<li>递归的父问题和子问题之间不应该有交集</li>
</ul>
</li>
<li><strong>API的目的是将调用和实现分离</strong></li>
<li>重定向和管道输入<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/redirect.png"></li>
<li>Java表达式1/0和1.0/0.0的值是什么<ul>
<li>第一个表达式会产生一个运行时除以零异常（它会终止程序，因为这个值是未定义的）；第二个表达式的值是Infinity（无穷大）。</li>
</ul>
</li>
<li>为什么数组的起始索引是0而不是1<ul>
<li>这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将起始索引设为1要么会浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减1</li>
</ul>
</li>
<li>每次使用new来创建一个对象时，系统都会<ul>
<li>为新的对象分配内存空间</li>
<li>调用构造函数初始化对象中的值</li>
<li>返回该对象的一个引用 </li>
</ul>
</li>
<li>为什么要区别原始数据类型和引用类型？为什么不只用引用类型<ul>
<li>因为性能。Java提供了Integer、Double等和原始数据类型对应的引用类型，以供希望忽略这些类型的区别的程序员使用。原始数据类型更接近计算机硬件所支持的数据类型，因此使用它们的程序比使用引用类型的程序运行得更快</li>
</ul>
</li>
<li>指针是什么？<ul>
<li>和Java的引用一样，可以把指针看做机器地址。在许多编程语言中，指针是一种原始数据类型，程序员可以用各种方法操作它。</li>
<li>但众所周知，指针的编程非常容易出错，因此需要精心设计指针类的操作以帮助程序员避免错误。Java将这种观点发挥到了极致（许多主流编程语言的设计者也赞同这种做法）。</li>
<li>在Java中，创建引用的方法只有一种（new），且改变引用的方法也只有一种（赋值语句）。也就是说，程序员能对引用进行的操作只有创建和复制。</li>
<li>在编程语言的行话里，Java的引用被称为安全指针，因为Java能够保证每个引用都会指向某种类型的对象（而且它能找出无用的对象并将其回收）。</li>
</ul>
</li>
<li>栈用于带括号的运算符计算<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/dijkstra.png" alt="dijkstra双栈算术表达式求值"></li>
</ul>
<span id="more"></span>
<ul>
<li><strong>Java标准库中有栈和队列吗</strong><ul>
<li>Java有一个内置的库，叫做java.util.Stack，但你需要栈的时候请不要使用它。</li>
<li>它新增了几个一般不属于栈的方法，例如获取第i个元素。它还允许从栈底添加元素（而非栈顶），所以它可以被当做队列使用</li>
<li>java.util.Stack的API是<strong>宽接口</strong>的一个典型例子</li>
</ul>
</li>
<li><strong>算法分析</strong><ul>
<li>一个程序运行的总时间主要和两点有关<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>
</li>
<li>常见的增长数量级函数<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm1.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm2.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm3.png"></li>
<li>从增长率来看，效率排行是<strong>常数&gt;logN&gt;N&gt;N^2&gt;2^N&gt;N^3</strong></li>
</ul>
</li>
<li>解决3-sum问题<ul>
<li>即在给定的数组中找到和为0的三个数</li>
<li>解决2-sum问题<ul>
<li>使用归并排序对数组进行排序，复杂度为NlogN</li>
<li>遍历数组，第一个数找到后使用二分查找在排序后的数组中获取相反数，时间复杂度为NlogN</li>
<li>因此整个2-sum问题的时间复杂度为logN</li>
</ul>
</li>
<li>将解决2-sum问题的方法推广<ul>
<li>使用归并排序对数组进行排序，复杂度为NlogN</li>
<li>遍历数组，但是这时，需要遍历两遍，相当于先把两个数相加后再用二分法去找数组中的相反数，因此时间复杂度为(N^2)*logN</li>
<li>这样3-sum的问题的时间复杂度为(N^2)*logN</li>
</ul>
</li>
<li>可以看到，针对这样的问题，先排序一遍所需的成本在总成本中几乎可以忽略不计，而排序后可以使用二分法则可以将整个时间复杂度降一个量级<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm4.png"></li>
</ul>
</li>
<li>考虑数量级的注意事项<ul>
<li>大常数，考虑数量级一般情况下不需要去考虑常数，如2N^2 + cN，通常情况下是看成N^2，然而如果某些情况下，c的值非常大，大到在具体业务场景中无法忽略的话，还是需要将常数考虑进去</li>
<li>非决定性的内循环<ul>
<li>内循环是决定性因素的假设并不总是正确的</li>
<li>有些程序在内循环之外也有大量指令需要考虑</li>
</ul>
</li>
<li>指令时间<ul>
<li>每条指令执行所需的时间总是相同的假设并不总是正确的</li>
<li>例如，大多数现代计算机系统都会使用缓存技术来组织内存</li>
</ul>
</li>
<li>系统因素<ul>
<li>Java只是争夺资源的众多应用程序之一，而且Java本身也有许多能够大大影响程序性能的选项和设置</li>
<li>某种垃圾收集器或是JIT编译器或是正在从因特网中进行的下载都可能极大地影响实验的结果</li>
</ul>
</li>
<li><strong>对输入的依赖</strong><ul>
<li>某些特殊值导致的运行时间的陡然差异不应该考虑进我们对于程序整体运行时间的评估</li>
<li>考虑最坏情况下对于性能的保证</li>
<li>引入随机化算法<ul>
<li>需要模拟随机数的输入</li>
</ul>
</li>
<li>考虑操作序列<ul>
<li>即某些情况下，进行ABC操作和进行CBA操作的顺序可能也会对性能造成影响</li>
</ul>
</li>
<li>均摊分析<ul>
<li>提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>速度太慢的程序和错误的程序一样无用</strong></li>
<li><strong>union-find算法</strong><ul>
<li>问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数pq可以被理解为“p和q是相连的”</li>
<li>规则<ul>
<li>自反性：p和p是相连的</li>
<li>对称性：如果p和q是相连的，那么q和p也是相连的</li>
<li>传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的</li>
</ul>
</li>
<li>动态连通性问题<ul>
<li>当程序从输入中读取了整数对pq时，如果已知的所有整数对都不能说明p和q是相连的，那么则将这一对整数写入到输出中</li>
<li>如果已知的数据可以说明p和q是相连的，那么程序应该忽略pq这对整数并继续处理输入中的下一对整数</li>
<li>比如没有连通数据时，输入1，3，将其连通，输出1-3；接下来再输入3，5，将其连通，输出3-5；这样在输出记录中，存在1-3-5的连通记录；此时，输入1，5，根据连通规则，1和5是连通的，所以忽略这对数据<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/unionfind.png"></li>
</ul>
</li>
<li>用处<ul>
<li>这个程序能够判定我们是否需要在p和q之间架设一条新的连接才能进行通信，或是我们可以通过已有的连接在两者之间建立通信线路</li>
<li>这些整数表示的可能是社交网络中的人，而整数对表示的是朋友关系</li>
</ul>
</li>
<li>术语<ul>
<li>将对象称为<strong>触点</strong>，将整数对称为<strong>连接</strong>，将等价类称为<strong>连通分量</strong>或是简称<strong>分量</strong></li>
</ul>
</li>
<li>实现方法<ul>
<li>用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量</li>
<li>定义四个基本API<br>  <img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/unionfind2.png">   </li>
<li>quick-find算法<ul>
<li>connected(p,q)只需要判断id[p]==id[q]</li>
<li>我们需要遍历整个数组，将所有和id[p]相等的元素的值变为id[q]的值。我们也可以将所有和id[q]相等的元素的值变为id[p]的值——两者皆可<ul>
<li>举例来说，1-3本来相连，则数组id[]中id[1]和id[3]的值相等，比如都等于1</li>
<li>这时需要连接另一对触点，比如5-6，数组id[]中id[5]和id[6]的值相等，比如都等于5</li>
<li>现在需要将3和5连接，此时遍历数组，找到与id[3]和id[5]的值相同的索引，即1和6，此时将索引1,3,5,6的值都改为1或者都改为5<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind2.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind3.png"></li>
</ul>
</li>
<li>union方法包含三步，一步是find，找到各自对应的值，复杂度为O(1)，第二步是遍历数组，复杂度为O(N)，第三步是修改数组中的值，根据连通量的不同，可能需要1——N-1步</li>
<li>最差的情况下，只得到一个连通分量，如1-5的数组，最终连通分路只有一条1-2-3-4-5，其复杂度接近O(N^2)<ul>
<li>两个数组连通每次都需要N+3步，即两次find为2步，遍历数组N步，改变值1步，2+N+1=N+3步</li>
<li>只有一个通路的情况下，数组中依次比较需要N-1步，如1-5的数组，步骤为1-2,2-3,3-4,4-5。</li>
<li>所以最终步骤为(N+3)*(N-1)，时间复杂度记为O(N^2)</li>
<li>这个时间复杂度在数据量达到上亿的情况下显然效率过低，不予考虑</li>
</ul>
</li>
</ul>
</li>
<li>quick-union算法<ul>
<li>每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称，称为<strong>链接</strong><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion.png">  </li>
<li>在数组被初始化之后，每个节点的链接都指向它自己</li>
<li>每次union之后节点都会指向某个父节点，id[i]的值除非是根节点，否则不会等于自身，因此代码中的find会一直追溯到父结点<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion2.png"></li>
<li>与quick-find相比，最明显的改变就是每次union的操作无需遍历数组，只需将子节点指向父节点即可，这个过程只需一步<ul>
<li>相比之下，就要付出额外的成本去追溯父节点，这个过程最快1步，最慢需要N-1步</li>
</ul>
</li>
<li>在最坏的情况下，所有的节点的链接都指向前一个节点，那么每次find都需要遍历之前的每个节点，总的find的步骤就是3+5+6+……+(2N-1)～N^2<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion3.png">       </li>
<li>在一般情况下都会比quick-find更快，但是无法保证出现最坏情况下仍然是O(N^2)的时间复杂度</li>
</ul>
</li>
<li>加权quick-union算法<ul>
<li>记录每一棵树的大小并总是将较小的树连接到较大的树上</li>
<li>需要添加一个数组和一些代码来记录树中的节点数<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/weightquickunion.png">        </li>
<li>对于N个触点，加权quickunion算法构造的森林中的任意节点的深度最多为lgN</li>
<li>多出来记录节点数量的数组并不会增加多少复杂度，只会在每次union中多出两步操作</li>
<li>使得find成本大大降低，随着数量级的提升，时间复杂度只会以lgN的数量级增长</li>
</ul>
</li>
<li>路径压缩的加权quick-union算法<ul>
<li>我们希望每个节点都直接链接到它的根节点上，但我们又不想像quickfind算法那样通过修改大量链接做到这一点</li>
<li>要实现路径压缩，只需要为find()添加一个循环，将在路径上遇到的所有节点都直接链接到根节点</li>
<li>我们所得到的结果是几乎完全扁平化的树，它和quickfind算法理想情况下所得到的树非常接近</li>
<li>是目前的最优解  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>新闻翻译-2</title>
    <url>/2021/12/09/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-2/</url>
    <content><![CDATA[<p><a href="https://www.smithsonianmag.com/smart-news/chinese-rover-spots-weird-cube-on-the-moon-180979174/">原文链接</a> </p>
<h2 id="Chinese-Rover-Spots-Weird-Large-‘Cube’-on-the-Moon"><a href="#Chinese-Rover-Spots-Weird-Large-‘Cube’-on-the-Moon" class="headerlink" title="Chinese Rover Spots Weird, Large ‘Cube’ on the Moon"></a>Chinese Rover Spots Weird, Large ‘Cube’ on the Moon</h2><h2 id="中国航天器在月球发现了诡异巨大的”方块”"><a href="#中国航天器在月球发现了诡异巨大的”方块”" class="headerlink" title="中国航天器在月球发现了诡异巨大的”方块”"></a>中国航天器在月球发现了诡异巨大的”方块”</h2><h3 id="The-geometric-lunar-feature-dubbed-a-‘mystery-hut’-has-stumped-scientists-who-say-they-plan-to-take-a-closer-look"><a href="#The-geometric-lunar-feature-dubbed-a-‘mystery-hut’-has-stumped-scientists-who-say-they-plan-to-take-a-closer-look" class="headerlink" title="The geometric lunar feature dubbed a ‘mystery hut’ has stumped scientists, who say they plan to take a closer look"></a>The geometric lunar feature dubbed a ‘mystery hut’ has stumped scientists, who say they plan to take a closer look</h3><h3 id="这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看"><a href="#这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看" class="headerlink" title="这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看"></a>这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看</h3><p><img src="/2021/12/09/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-2/1.png"><br><em>The rover will spend two to three lunar days, which is about two to three months time on Earth, traversing the lunar landscape to take a closer look at the object. CNSA/Our Space/Gizmodo</em><br><em>航天器将花费两到三个月球日，相当于地球上两到三个月的时间，通过月球表面来更近的观察这个物体。<a href="https://mp.weixin.qq.com/s/dpKkjWHk9tay3JERnrfuUw">CNSA/Our Space/Gizmodo</a></em></p>
<p>An intriguing cube-shaped object spotted on the far side of the moon has attracted the attention of scientists.<br>一个有趣的方块形状物体，在月球的另一端被发现，这引起了科学家的注意。</p>
<p>China’s Yutu 2 rover captured images of the mystery structure from around 260 feet away while navigating across the Von Kármán crater in the South Pole-Aitken Basin on the moon, reports Popular Science’s Margo Milanowski. Chinese scientists have already rerouted the rover to take a closer look, but it will take a few months for Yutu 2 to reach the bizarre lunar feature.<br>据<a href="https://www.popsci.com/science/chinas-rover-mysterious-hut-on-moon/">《流行科学》</a>的Margo Milanowski报道，中国的月兔2号航天器在月球的北部<code>Pole-Aitken</code>盆地，正在穿越<code>Von Kármán</code>坑时，拍摄到一张260英尺外的神秘结构的物体。中国的科学家已经调整航天器的方向以更近的观察，但是这将花费月兔2号几个月的时间去靠近这个奇特的月球物体。</p>
<p>The shape was spotted on the horizon in November during the mission’s 36th lunar day, according to a Yutu 2 diary published by Our Space, a Chinese language science outreach channel affiliated with the China National Space Administration. Our Space first described the object in a post last week, temporarily dubbing it a “mystery hut” (神秘小屋/shenmi xiaowu).<br>根据<a href="https://mp.weixin.qq.com/s/dpKkjWHk9tay3JERnrfuUw">《我们的太空》</a>的月兔2号每日报告（这是一家隶属于中国国家航天局的对外中文平台），这个几何体在地平线处发现，正值12月份，执行任务的第36个月球日。《我们的太空》在上周首次描述这个物体，将其戏称为是一个”神秘小屋”。</p>
<span id="more"></span>
<p>Since Yutu 2 spotted the “mystery hut,” scientists have changed the six-wheeled vehicle course to investigate the cube. The solar-powered rover will spend two to three lunar days—equivalent to two to three months time on Earth—traversing the lunar landscape to take a closer look, so we should have more clues shortly, reports Andrew Jones for Space.<br>玉兔2号发现”神秘小屋”之后，科学家改变了这个六个轮子航天器的目标，转为探索这个方块。这个太阳能的航天器会花费两到三个月球日-等价于两到三个地球月-穿越月球表面去更近的观察，所以我们很快会获得更多线索，来自于<a href="https://www.space.com/china-yutu-2-moon-rover-cube-shaped-object-photos">《太空》</a>的Andrew Jones报道。</p>
<p>The rover’s images immediately sparked debate as to what the cube-shaped object was and inspired humorous guesses. “Was it a home built by aliens after the crash landing? Or is it the pioneer spacecraft of the predecessors to explore the moon?” writes Our Space.<br>航天器的照片马上引起了对于这个集合形状的物体到底是什么的讨论，并引发了无数的猜想。《我们的太空》写道，”这是外星人撞击月球后建立的房子吗？或者这是先驱者用来探索月球的的航天器？”</p>
<p>The “hut” may simply be a large boulder that’s been pushed up by meteor impact and taken on a geometric look in the low-resolution image. The blog post noted that there is an impact crater beside the mystery hut, further suggesting that the cube could just be an excavated lunar rock.<br>“小屋”可能就是受流星撞击而出现的巨石，而且在低像素的照片下看起来是一个几何形状。博客提醒说，在神秘小屋旁边有一个撞击巨坑，进一步推测这个方块可能只是一个被撞出来的月球石块。</p>
<p>This latest discovery isn’t the first curious thing the Yutu 2 rover has seen since its arrival on the far side of the moon almost three years ago. In September 2019, the rover encountered a strange, gel-like substance that turned out to be melted rock fragments cemented together from extreme heat. This year, Yutu 2 spotted unusual shards sticking out from the lunar surface that turned out to be rocks launched by a meteor impact, reports Gizmodo’s George Dvorsky.<br>自从月兔2号航天器在将近三年前到达月球的另一端后，已经不止一次有这种奇特发现。在2019年9月，航天器遇到了一个奇怪的<a href="https://www.inverse.com/science/chinese-lunar-lander-gel-substance">凝胶状物质</a>，这个来自于被溶解的石头成分在高温下又被粘合到一块。今年，月兔2号在月球表面发现了<a href="https://www.space.com/china-yutu-2-moon-far-side-rover-milestone-discovery">不寻常尖锐碎片</a>突出，这个来自于流星撞击后的石头。报道来自于<a href="https://gizmodo.com/chinese-rover-to-investigate-mysterious-hut-spotted-o-1848165985">《Gizmodo》</a>的George Dvorsky。</p>
<p>Whatever the cube-shaped object is, we will have to wait another few months before getting an answer—until then, it’s fun to speculate on what the “mystery hut” could be.<br>不管方块形状的物体是什么，我们都要等几个月才能获得答案，在这期间推测”神秘小屋”是什么将很有意思。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-3</title>
    <url>/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/</url>
    <content><![CDATA[<p><a href="https://time.com/6125959/best-movies-2021/?utm_source=roundup&utm_campaign=2021208">原文链接</a> </p>
<p>吐槽一下，这十佳电影看着满满都是政治正确的味道，Passing这部电影简直buff叠满，黑白片，双女主，关于美国梦和黑人白人之间的冲突，满脸写着”我是冲着奥斯卡来的”。</p>
<hr>
<h2 id="2021十佳电影"><a href="#2021十佳电影" class="headerlink" title="2021十佳电影"></a>2021十佳电影</h2><p>如果说2020年对于影迷来说是一个漫长黑暗的冬天（当然也有一些优秀的影片，但是不得不在家观影也是一个打击），2021就是一个生机勃勃，欢声笑语的春天。不仅仅是普通意义的春天，也是一个充满了斯特拉文斯基风格的春天，在祥和齐声的交响乐中绽放在大地上的番红花，雨滴阵阵落满了泥土，树木抽出了嫩芽。这么说的一部分原因很现实，也在预料之内：相当数量的今年的最佳影片早在2020年就已完成，但是推迟了，直到它们可以在影院上映。在黑暗的几个月过去后，这个值得欢庆的季节里绽放的曙光依然可以看作精神的慰藉。在本文的结尾，请参考这十部今年最好的电影（以及提名影片）作为你观影的选项。我们都值得这一切。</p>
<ul>
<li>10.Drive My Car</li>
</ul>
<p>Ryusuke Hamaguchi的三小时的流畅而又华丽的剧本（故事改编自Haruki Murakami的短篇小说），讲述了一个来自东京，经历了丧偶的演员和戏剧导演（Hidetoshi Nishijima），在广岛找了份工作，制作契柯夫的《万尼亚舅舅》。一个来自乡下（三浦店）的年轻女人被雇佣当他的司机；他们慢慢建立了友情，同时也帮助他分辨出他究竟迷失在哪里。Hamaguchi编织了一个关于失去和原谅，充满了光辉的故事，无论你有多么疲惫，一句轻轻的鼓励也能推动你在世界上继续前行。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/DriveMyCar.jpeg"> </p>
<ul>
<li>9.The Tragedy of Macbeth</li>
</ul>
<p>这个故事你可能已经看过几百次了。但是Joel Coen用令人战栗的黑白色调，以及Frances McDormand和Denzel Washington饰演的狡诈，奸险的苏格兰人，犹如魔咒般吸引人，他们共同对该经典进行了难以置信的表达，彷佛置身于400年前，你作为第一个观众看到这个戏剧的首次呈现。今时今日，犹如往昔，这个故事冻彻骨髓。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheTragedyofMacbeth.jpg"> </p>
<span id="more"></span>
<ul>
<li>8.C’mon C’mon</li>
</ul>
<p>Joaquin Phoenix贡献了一次有趣而又精致的表演，剧中作为一个无儿无女的纽约广播记者，要在几周内负责照顾他少年老成的来自洛杉矶的9岁外甥（Woody Norman）。这怎么听起来不像一部完整的电影呢？但在编剧兼导演Mike Mills的手中，这就是整部电影的内容。No one is better at chronicling late 20th and early 21st century family affection, in all its thorny, shimmery beauty.（翻译不出来）<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/CmonCmon.jpeg"></p>
<ul>
<li>7.The Disciple</li>
</ul>
<p>故事讲述一个歌手（公开资料显示，由Aditya Modak扮演），拥有十足的干劲和自律性，在一个曲高和寡的领域，为印度传统音乐奋斗终生，最终被迫认识到自己缺乏关键的天赋。导演Chaitanya Tamhane在他的鲜艳，动人的镜头下，审视了在一个现实世界中如此狂热的追求艺术之梦的意义，并没有那么重要。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheDisciple.jpeg"></p>
<ul>
<li>6.Passing</li>
</ul>
<p>这部电影改编自Nella Larsen的一部1929年的紧凑，强有力的小说，讲述了两个少女（由Tessa Thompson 和 Ruth Negga出色演绎）在成年后重新取得联系，她们的生活不仅仅发生交织，乃至最终的坍塌：两个女人都是黑人，但是其中一个却以白人自居。导演Rebecca Hall首次为我们深刻讲述了围绕在美国梦周围的是什么，是创造一切，或者成为谁–这被称为自由，有时候会付出惨痛的代价。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/Passing.jpeg"></p>
<ul>
<li>5.Parallel Mothers</li>
</ul>
<p>Penélope Cruz 贡献了杰出的表演，她饰演一个在马德里的女人，在中年成为母亲，同时她也在努力为她的曾祖父争取正义，他在西班牙内战中被杀害，尸体被抛弃在乱葬岗中。导演Pedro Almodóvar用情节剧的方式去回闪那些他的国家中的悲催历史，但同时也在强调关于母性的关键真理：历史由母亲们铸造，文明失去她们，将无法前行。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/ParallelMothers.jpeg"></p>
<ul>
<li>4.The Souvenir Part II</li>
</ul>
<p>这部英国制片人Joanna Hogg的令人刺痛和伤感的半自传电影中，讲述了在上世纪80年代的伦敦，一个年轻学生（Honor Swinton Byrne扮演，贡献了微妙迷人的表演）在完成她的毕业影片时，试图寻找令人心碎的个人悲剧的意义。在这个看似简单的故事中，Hogg捕捉到了一个年轻人渴望在世界中留下印记的方方面面，同时也需要绝望的寻找其中的意义。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheSouvenirPartII.jpeg"></p>
<ul>
<li>3.Summer of Soul</li>
</ul>
<p>Ahmir “Questlove” Thompson的光辉纪录片记录了一系列发生在Woodstock的夏天，在Harlem公园的众星云集的免费演唱会。但是获得的关注却不多。The Harlem Cultural Festival 吸引众多人群，但从几年前开始，这项音乐和骄傲的国民盛典就开始被大量遗忘，或者更准确的说，单纯被忽视了。就像隐藏在眼皮底下的珠宝，电影呈现了Mahalia Jackson, Stevie Wonder and Nina Simone的伟大表演。至少现在，世界开始注意到了。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/SummerofSoul.jpeg"></p>
<ul>
<li>2.The Worst Person in the World</li>
</ul>
<p>丹麦-挪威混血导演Joachim Trier这部无比温柔的喜剧像是上帝赋予的礼物。Julie（Renate Reinsve扮演，这是一场奇妙的而又粗中有细的表演）一路在弄清楚她自己是谁，她先后爱上两个男人，最后意识到她失去了更多。Trier将故事导向了一个苦乐参半的结局。提醒我们一直在路上，未竟的道路最终都会转向光明。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheWorstPersonintheWorld.jpeg"></p>
<ul>
<li>1.The Power of the Dog  </li>
</ul>
<p>上世纪20年代的蒙大拿，一个愤世嫉俗的农场主（Benedict Cumberbatch饰演）遇到了一个精力充沛，充满梦想的少年（Kodi Smit-McPhee饰演），农场主起初对他不屑一顾，之后发生了更多故事。故事基于Thomas Savage在1967年发布的小说，在Jane Campion镜头下雄伟壮丽的西部，是犹如天空一般辽阔的电影画卷。同时也让人类的情感分毫毕现，像一根纤细的草，却又异常锋利。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/ThePoweroftheDog.jpeg"></p>
<p>提名: West Side Story, The Card Counter, The Velvet Underground, The Lost Daughter, The Electrical Life of Louis Wain, I’m Your Man, King Richard, The Green Knight, The Truffle Hunters</p>
<p>生词：<br>misanthropic rancher 愤世嫉俗的农场主<br>a reedy（芦苇般）, dreamy teenager 精力充沛，充满梦想的少年<br>contempt 轻视<br>sinewy 强壮<br>a blade of grass 一叶草<br>staggeringly tender 惊人的／无比温柔<br>sturdy delicacy 粗犷细腻<br>bittersweet 苦乐参半<br>we’re all works in progress, unfinished beings whose only imperative is to turn toward the light 我们一直在路上，未竟的道路最终都会走向光明。<br>radiant 光辉<br>chronicles 把…载入编年史／历史<br>star-studded 群星荟萃<br>neglected 忽视<br>semiautobiographical 半自传<br>subtle 微妙的<br>captivating 迷人的<br>facets 方面<br>mass grave 乱葬岗<br>girlhood 少女时代<br>compact 紧凑<br>potent 强有力<br>superbly 极佳的<br>intersecting 相交／贯穿<br>A singer with great drive and discipline 一个拥有十足干劲和自律的歌手<br>with searching openness 根据公开资料显示（？）<br>rarefied 高深的／稀薄的／冷门领域<br>unlucrative 不幸的<br>examines 审视<br>feverishly 狂热的<br>takes a backseat 排在次要位置<br>wrought 精致<br>precocious 老成的<br>shimmery beauty 闪闪发光的美<br>shivery 颤抖<br>rendering 表演／翻译<br>treacherous 不可信任的<br>scheming Scots 诡计多端的苏格兰人<br>swimmingly 流畅<br>gorgeous 华丽<br>drama—adapted 戏剧改编<br>gig 现场表演／临时工作<br>nudge 推动<br>twig 树枝<br>bounty 奖金<br>We’ve all earned it 我们都值得这一切<br>copiously 大量的<br>Honorable mentions 荣誉提名</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-Metacritic评选的2021年度十佳PC游戏</title>
    <url>/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.gamespot.com/articles/best-pc-games-of-2021-according-to-metacritic/1100-6498757/">原文链接</a> </p>
<p>全都没玩过，甚至基本都没听过，看来确实是老了。。。</p>
<hr>
<p><em>本文提到的产品完全是我们编辑的独立选择。如果你通过我们的链接购买游戏的话，GameSpot会得到一些佣金。</em></p>
<h2 id="Metacritic评选的2021年度十佳PC游戏"><a href="#Metacritic评选的2021年度十佳PC游戏" class="headerlink" title="Metacritic评选的2021年度十佳PC游戏"></a>Metacritic评选的2021年度十佳PC游戏</h2><h3 id="PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏"><a href="#PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏" class="headerlink" title="PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏"></a>PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏</h3><hr>
<p>今年也许是被刚上市的PS5和xbox series X|S统治的一年，但是PC游戏在2021年也比以往更加出色。诸多游戏平台充斥着独立制作和3A大作的标题，但是他们中哪一款是最出色的呢？通过GameSpot的兄弟网站Metacritci，我们优中选优，一致讨论出了即使批评家们也挑不出毛病的10款PC游戏。列出的结果包含了众多体裁，但是他们都有共同点，至少有一点是一样的：他们在2021年为你们贡献了最佳的游戏乐趣。</p>
<h2 id="终焉之莉莉：骑士寂夜（Ender-Lilies-Quietus-of-the-Knights）"><a href="#终焉之莉莉：骑士寂夜（Ender-Lilies-Quietus-of-the-Knights）" class="headerlink" title="终焉之莉莉：骑士寂夜（Ender Lilies: Quietus of the Knights）"></a>终焉之莉莉：骑士寂夜（Ender Lilies: Quietus of the Knights）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/enderlilies.jpg"><br>受到<code>空洞骑士</code>和<code>黑暗之魂</code>的启发并将其二者融合，并伴随着大量的<code>银河战士</code>设计的影响，你将体验到的是一场美味的2D动作角色扮演游戏的盛宴，让你直到结尾也回味无穷。更棒的是，<code>终焉之莉莉</code>在以往那些老掉牙的探索和紧张战斗的套路中加入了一些现代化的改进，沿着路线攻克一些非常棘手的任务然后直接将你置于最强的boss之中，这个游戏中都将可能发生。</p>
<p>Meta评分: 86</p>
<h2 id="死亡循环（Deathloop）"><a href="#死亡循环（Deathloop）" class="headerlink" title="死亡循环（Deathloop）"></a>死亡循环（Deathloop）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/deathloop.jpeg"><br>在土拨鼠日带着抢，身怀时间操控的能力，并且口吐芬芳，这听起来像是美好时光的秘方，而在<code>死亡循环</code>里，这些元素烹制出了2021年的最佳游戏之一。<code>死亡循环</code>主要侧重于其绝妙的时间循环的玩法，但这游戏的美妙之处也在于如何在每一次新的循环中奖励你新的知识，技巧，以及最终逃离暴力的黑礁大陆之后，产生的顿悟。</p>
<p>这很可能是开发商Arkane目前的最佳作品，一个无尽的沙盒，充满创造力和魅力，并且满溢着个人风格和充满自信的大屠杀。</p>
<p>Meta评分: 86</p>
<span id="more"></span>
<h2 id="质量效应：传奇版（Mass-Effect-Legendary-Edition）"><a href="#质量效应：传奇版（Mass-Effect-Legendary-Edition）" class="headerlink" title="质量效应：传奇版（Mass Effect: Legendary Edition）"></a>质量效应：传奇版（Mass Effect: Legendary Edition）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/masseffect.jpeg"><br>如果你找一个最佳性价比的经典系列游戏的重制版，那<code>质量效应：传奇版</code>完美符合你的要求。即使是BioWare原作的科幻三部曲依旧散发着巨大的魔力。游戏首次加入一些适当的升级，让游戏更加现代化，上市后便连续两周位列销量榜首，传奇版几乎包括了薛帕德的传奇故事的所有篇章-删减了质量效应3的庞杂的多人模式以及少量的其他琐碎内容-顶尖的视觉效果，并在背后进行了若干调整，成就了这个系列的决定性版本。</p>
<p>Meta评分: 86</p>
<h2 id="漫野奇谭（Wildermyth）"><a href="#漫野奇谭（Wildermyth）" class="headerlink" title="漫野奇谭（Wildermyth）"></a>漫野奇谭（Wildermyth）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/wildermyth.jpeg"><br><code>漫野奇谭</code>切中了几个电视游戏设计的要害。他的美术风格像是让活生生的童话故事走进生活，他的玩法取自回合制RPG游戏的元素，通过巧妙的融合将二者融合为一种游戏体裁，而其天然的好上手让这游戏无论是玩一场马拉松的长度还是午饭间隙的一局都非常合适。对于一些特殊体裁，很少有电视游戏可以掌握休闲和硬核玩法之间的平衡并在特定的体裁领域提供新的东西，但是<code>漫野奇谭</code>接受了这个挑战并提供了一份不错的体验。</p>
<p>Meta评分: 87</p>
<h2 id="杀手3（Hitman-3）"><a href="#杀手3（Hitman-3）" class="headerlink" title="杀手3（Hitman 3）"></a>杀手3（Hitman 3）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/hitman3.jpg"><br>所有的故事都会走向终点，而对于47号特工来说，在经历了这么多年的全球旅行并对那些可望不可及的大人物执行了迟到的正义后，他会在<code>杀手3</code>迎来一个完美的终章。经历了前两作的打磨，<code>杀手3</code>的品质已经非常上乘，你可以沉浸在一系列的沙盒场景中度过大量游玩时光，并利用你的完美伪装来完成宿命般的屠杀。</p>
<p>开发商IO Interactive维持了游戏一贯的丰富内容，包括难以捉摸的目标人物，甚至在PC上加入了VR支持。第二年计划开发的内容也使得游戏的未来非常明朗，<code>杀手3</code>将继续在环绕全球的旅程中进行他优雅而致命的暗杀。</p>
<p>Meta评分: 87</p>
<h2 id="双人成行（It-Takes-Two）"><a href="#双人成行（It-Takes-Two）" class="headerlink" title="双人成行（It Takes Two）"></a>双人成行（It Takes Two）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/ittakestwo.jpeg"><br>这一年中不乏狂野而具有想象力的游戏发布，<code>双人成行</code>则是2021年中出类拔萃的存在。一对即将分崩离析的伙伴踏上一段奇妙的冒险，<code>双人成行</code>讲述了一个关于爱，失去以及混沌的故事。这些都囊括在一个个精妙的合作谜题和舞台中，它的美术风格令人印象深刻，最后以一个令人满意的结尾呈现。</p>
<p>Meta评分: 88</p>
<h2 id="脑航员2／疯狂世界2（Psychonauts-2）"><a href="#脑航员2／疯狂世界2（Psychonauts-2）" class="headerlink" title="脑航员2／疯狂世界2（Psychonauts 2）"></a>脑航员2／疯狂世界2（Psychonauts 2）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/psychonauts2.jpeg"><br><code>脑航员2</code>里有太多有趣的亮点，包括设计很好的角色，杰出的音效，但是其美术风格是游戏真正的闪光点，为你创造难以忘怀的体验。这些元素融合在坚实的冒险中，确切的契合着游戏的初心，<code>脑航员2</code>的开发商Double Fine在这方面做到了最佳，通过大脑的等级和充满想象力的地点构建一个吵闹的故事，让你和脑中的邪恶战斗并在一路上学到一些知识。</p>
<p>Meta评分: 89</p>
<h2 id="神笔狗良（Chicory-A-Colorful-Tale）"><a href="#神笔狗良（Chicory-A-Colorful-Tale）" class="headerlink" title="神笔狗良（Chicory: A Colorful Tale）"></a>神笔狗良（Chicory: A Colorful Tale）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/chicory.jpg"><br>尽管这一年在各种平台上发布了各种体裁的游戏和技术的展示，以及如何翻新老游戏的历程，<code>神笔狗良</code>依然是2021年并列最佳的游戏。有趣谜题的集合，尽情宣泄的画笔，多彩的角色，在数个小时的游玩中，<code>神笔狗良</code>将其不可思议的关联在一块。游戏唤起几乎每个人都有的和内心邪恶的斗争以及自我怀疑的处理，<code>神笔狗良</code>老练的将幽默和情感上的悬念融合，在一个你创建的独特视觉世界中贡献了顿悟自我的杰作。</p>
<p>Meta评分: 90</p>
<h2 id="极限竞速：地平线5（Forza-Horizon-5）"><a href="#极限竞速：地平线5（Forza-Horizon-5）" class="headerlink" title="极限竞速：地平线5（Forza Horizon 5）"></a>极限竞速：地平线5（Forza Horizon 5）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/forzahorizon5.jpeg"><br>极限竞速：地平线系列的最后一作是一场几乎没有缺点的纯粹享受。点燃所有的气缸，在重重阻碍的墨西哥之旅中体验瑰丽的风景，<code>地平线5</code>是一场汽车文化的盛宴。不仅仅是精美渲染的汽车合集以及多种多样的赛车道，<br>每次当你的收藏中加入新车时，<code>地平线5</code>都会在整个体验中给予你令人赞叹的个人体验。以华丽的画面表现在引擎盖下的马力和一些最精密的赛车部件，<code>地平线5</code>堪称是开放世界赛车游戏的天花板。</p>
<p>Meta评分: 91</p>
<h2 id="极乐迪斯科-最终剪辑版（Disco-Elysium-The-Final-Cut）"><a href="#极乐迪斯科-最终剪辑版（Disco-Elysium-The-Final-Cut）" class="headerlink" title="极乐迪斯科:最终剪辑版（Disco Elysium: The Final Cut）"></a>极乐迪斯科:最终剪辑版（Disco Elysium: The Final Cut）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/discoelysium.jpeg"><br>在首部作品发布两年后，<code>极乐迪斯科</code>在2021年带着他的乐队回归了。这款早已饱受赞誉的游戏是关于谋杀和扮演一个侦探的故事，这个侦探同时也不得不面对个人失败的情感，而最终剪辑版更是一个残酷侦探故事的顶级展现。<br>强大的声优给这个故事带来了新的生命力，游戏性经过了一些内外的调整，新的内容也加入了冒险中，以及一些关键的更新使得游戏的一切都比以往更好。</p>
<p>独一无二的画风，令人迷幻的谜题，以及电视游戏中最佳的搞笑桥段，<code>极乐迪斯科</code>已经不能更好了。</p>
<p>Meta评分: 91</p>
<hr>
<p>time-manipulating 时间操控<br>charisma 魅力<br>carnage 大屠杀<br>oozes 滲出；充满<br>trilogy 三部曲<br>remaster 重制版<br>provided the best possible value for money 提供最高的性价比。<br>chart-topping 排行榜榜首<br>saga 传奇故事<br>fantastic 荒诞，可笑，巨大<br>vibrant 充满活力的<br>turn-based 回合制<br>catering 承办酒席<br>rises up to the challenge 迎接挑战<br>considered 认为；考虑过的<br>people who considered themselves to be untouchable 认为自己不可触碰的人<br>pure polish and class 纯正上等<br>revel 狂欢<br>karmic 业力；宿命<br>carnage 屠杀<br>assassination 暗杀<br>stands out from the pack 脱颖而出<br>saw no shortage of 不乏<br>quirky 古怪的<br>bickering 争吵的<br>on the rocks 岌岌可危<br>turmoil 混乱<br>powerhouses 强大的集团；强壮的人<br>rip-roaring 吵闹的<br>cerebral 大脑的<br>solid 坚实的；坚硬的<br>consoles 安慰／控制台<br>cathartic 宣泄的<br>plays out 演出<br>expertly 熟练的<br>cliffhangers 悬念<br>masterpiece 杰作<br>self-reflection 自我反省<br>visually distinctive 视觉上与众不同<br>bliss 幸福<br>pure V8 bliss 纯粹的幸福；纯粹的快乐<br>cylinders 圆筒；气缸<br>gorgeous 瑰丽；非常漂亮<br>beautifully-rendered 渲染精美<br>under its hood 在引擎盖下<br>horsepower 马力<br>stellar 恒星的；星光闪耀的；优秀的<br>grapple 搏斗<br>hard-hitting 直言不讳的<br>banter 调侃<br>mind-bending 心神不宁</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-考古发现罕见的中世纪符文</title>
    <url>/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/</url>
    <content><![CDATA[<p><a href="https://www.smithsonianmag.com/smart-news/newly-discovered-norwegian-runes-might-contain-a-medieval-joke-180979381/">原文链接</a> </p>
<hr>
<h2 id="考古学家发现并开始破译罕见的中世纪符文"><a href="#考古学家发现并开始破译罕见的中世纪符文" class="headerlink" title="考古学家发现并开始破译罕见的中世纪符文"></a>考古学家发现并开始破译罕见的中世纪符文</h2><h3 id="这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，"><a href="#这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，" class="headerlink" title="这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，"></a>这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，</h3><p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone.png"></p>
<p>去年下半年，挪威的考古学家在几天内连续有了惊人的发现，在奥斯陆<a href="https://www.middelalder.no/middelalderbyen-i-dag/middelalderparken">中世纪公园</a>的不同区域出土了两件罕见的符文文物。</p>
<p><a href="https://www.niku.no/">挪威国家遗产研究中心</a> (NIKU) 的<a href="https://www.niku.no/ansatt/solveig-thorkildsen/">Solveig Thorkildsen</a>和<a href="https://www.niku.no/en/ansatt/ingeborg-hornkjol/">Ingeborg Hornkjøl</a>在不断的<a href="https://www.niku.no/prosjekter/middelalderparken/">挖掘过程</a>中发现了这些文物，其中一个骨头上雕刻了挪威语铭文，另一个的符文则同时由拉丁语和挪威文字写就。根据<a href="https://www.niku.no/2021/12/unike-runefunn-i-middelalderparken/">声明</a>，符文骨是30多年来在挪威首都首次有这种发现。</p>
<p>团队在结束一天工作的时候，Thorkildsen发现了在地上的一个巨大骨头。她和同事开玩笑说：”看，这上面有符文！”</p>
<p>研究员捡起骨头然后把它翻过来，她震惊的发现在骨头的表面真的雕刻了14个符文。</p>
<p>“当时我的心脏狂跳，”Thorkildsen在声明中回忆说，”这次挖掘我心愿单的第一位就是找到符文。”NIKU介绍，符文骨可能是从马或牛的肋骨上取下的。至今为止在奥斯陆只发现了27块这样的骨头。</p>
<p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone2.png"></p>
<p>在Thorkildsen的发现几天后，Hornkjøl也有了同样令人振奋的发现。当时她站在一个用于灌满水的深坑中，她注意到一片木头被冲到了沟中。就像之前被翻过来的骨头一样，棍上的符文可追溯到中世纪。</p>
<p>这次同时发现两件刻字的文物，是及其罕见的，这将帮助研究者了解更多关于奥斯陆中世纪居民的信息。尽管文物还暂未在实验室中研究，考古学家已经推断这两个符文可追溯到公元1100年至1350年。</p>
<p>“每一次符文的发现都很重要，这将告诉我们更多关于中世纪的人民的喜好，且愿意将这些分享给周围的人，”来自奥斯陆大学的符文学专家Kristel Zilmer在一份声明中说道。”两份发现的符文提示了在那个时期人民的知识和兴趣的多样性。”</p>
<p>Zilmer初步研究发现在木板条符文的四面中，有三面刻着符文文字。文字包含拉丁语<code>manus Domine or Domini</code>，这可能是祷告的一部分，”Into your hands, O Lord, I commend my spirit. You have redeemed me, O Lord, O God of truth.”（学者告诉<code>挪威科学</code>，中世纪基督徒经常使用符文表达简单的祷告）</p>
<p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone3.png"></p>
<p>一个叫Bryngjerd的北欧人也在木棒中出现，也许描述了这个女人用了符文去表达她对上帝的奉献。</p>
<p>Thorkildsen发现的骨头上的符文的含义，Zilmer提供了两种理论解释。这个物品上带有北欧符文<code>basmarþærbæin</code>-这可能是一个名字或昵称，或者这是一个对于骨头本身的描述。</p>
<p>符文学者Karen Langsholt Holmqvist告诉<code>挪威科学</code>，符文是具有高度上下文相关含义的短文本。在中世纪的挪威，只有贵族可以读写，但也有相当一部分人熟知关于词汇，姓名和名句的符文。</p>
<p>12月份是中世纪公园的研究员们的大事件月。在Thorkildsen和Hornkjøl的发现前，NIKU的考古学家发掘出了一个中世纪的遗骸，戴着王冠，手持猎鹰。<code>挪威科学</code>当时发布报告时，一个三英尺长的文物发掘出来，来自动物的骨头，可能是用于刀具或工具。雕像可能是一种斯堪的纳维亚人对猎鹰的描绘，一种狩猎的鸟类用于对杀戮野生动物。</p>
<hr>
<p>Medieval 中世纪<br>Runes 符文<br>unearthed 出土；发掘<br>inscribed 在…上写(词语、名字等);题;刻<br>only days apart 相隔几天<br>stunning 令人震惊的<br>heritage 遗产(指国家或社会长期形成的历史、传统和特色)<br>Norse 挪威语<br>inscription 碑文；铭文<br>stick with 紧随；和……呆在一起<br>ongoing 不间断的<br>excavations (对古物的)发掘;发掘现场;挖掘;开凿;挖土<br>wrapping up 总结<br>per a translation 根据翻译<br>trench 沟槽;沟;海沟;战壕;堑壕;渠;大洋沟<br>prone 有做…倾向的;俯卧的;易于遭受;有做(坏事)的倾向;易于遭受…的<br>dated to the medieval era 追溯到中世纪<br>fragments 碎片<br>runology 符文学<br>diversity 多样性<br>preliminary 初步的<br>manus 手<br>redeemed 补偿<br>The object bears the Norse inscription 该物品带有北欧符文<br>That runes are short pieces of text with highly context-dependent meanings 符文是具有高度上下文相关含义的短文本<br>a broad segment of the population 相当一部分人<br>falcon 猎鹰<br>Scandinavian depictions of falconry 斯堪的纳维亚人对猎鹰的描绘<br>figurine 雕像</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>Namcheap+CloudFlare简单建站</title>
    <url>/2023/04/12/2023/04/how_to_create_new_site/</url>
    <content><![CDATA[<h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><ul>
<li>需要基于流量和内容进行选择，如果打算服务于国内，选择国内的服务器提供商，比如阿里云或者腾讯云等，如果需要某些国内服务器做不到的功能，比如调用openai的接口，则最好是买个国外的服务器。</li>
<li>需要注意的是，如果打算基于微信小程序或者公众号开发，必须要满足域名通过国家备案，而备案的必要条件是所在的服务器是国内供应商。因此如果是为了开发小程序而买了个国外服务器，最终很可能因为无法备案而无法满足你的需求。</li>
<li>无论国内外，最便宜的套餐普遍都是1核1G，20GB硬盘空间，1Mbps带宽。国外有Vultr，Linode，DigitalOcean，AWS Lightsail等，价格普遍在5美刀/月左右。国内可选择阿里云，百度云，腾讯云，华为云等，价格20-100元人民币/月不等。</li>
<li>如果是开发小程序和公众号，有另一种选择，跳过购买域名和服务器，直接使用腾讯的<a href="https://cloud.weixin.qq.com/">云托管平台</a></li>
</ul>
<h3 id="购买域名和ssl证书"><a href="#购买域名和ssl证书" class="headerlink" title="购买域名和ssl证书"></a>购买域名和ssl证书</h3><p>需要注意，目前情况而言，购买域名的同时也几乎必须得购买ssl证书，因为现在http的网站已经不再被各大浏览器所推荐，流量优先级会被调低，甚至小程序直接不支持指向http网站，如果建站的目的是希望获得收入，那拥有ssl证书的https网站是必须的。</p>
<ul>
<li><p>国内</p>
<ul>
<li>易名中国：域名价格约为50元人民币/年起，SSL证书价格约为100元人民币/年起。</li>
<li>西部数码：域名价格约为60元人民币/年起，SSL证书价格约为100元人民币/年起。</li>
<li>新网：域名价格约为50元人民币/年起，SSL证书价格约为200元人民币/年起。</li>
<li>阿里云：域名价格约为60元人民币/年起，SSL证书价格约为300元人民币/年起。</li>
<li>巨牛网：域名价格约为50元人民币/年起，SSL证书价格约为150元人民币/年起。</li>
</ul>
</li>
<li><p>国外</p>
<ul>
<li>GoDaddy：域名价格约为$12/年起，SSL证书价格约为$70/年起。</li>
<li>Namecheap：域名价格约为$8/年起，SSL证书价格约为$9/年起。</li>
<li>Google Domains：域名价格约为$12/年起，SSL证书价格约为$20/年起。</li>
<li>Network Solutions：域名价格约为$35/年起，SSL证书价格约为$60/年起。</li>
<li>Name.com：域名价格约为$10/年起，SSL证书价格约为$9/年起。</li>
</ul>
</li>
</ul>
<h3 id="生成CSR"><a href="#生成CSR" class="headerlink" title="生成CSR"></a>生成CSR</h3><ul>
<li><p>什么是CSR</p>
<blockquote>
<p>CSR code (Certificate Signing Request) is a specific code and an essential part for the SSL activation. It contains information about website name and the company contact details. For many reasons, the code should be created on the hosting server end. On some servers, it is the obligatory condition.</p>
</blockquote>
<p>总之CSR是一段关于你网站的身份信息的加密文件，对于激活ssl证书是必须的，在服务器端生成。</p>
</li>
<li><p>通过openssl命令生成<br>有很多种方式生成csr文件，甚至有在线网站可以直接生成，通常不建议在线生成，因为csr是ssl的必要依赖，关联到网站的安全性，最好是不要冒泄露的风险。</p>
<ul>
<li>新建.key文件夹，执行如下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install openssl</span><br><span class="line">cd .key</span><br><span class="line">openssl req -nodes -newkey rsa:2048 -keyout $serverName.key -out $serverName.csr</span><br></pre></td></tr></table></figure>
注意，$serverName用你的网站名替换，会生成两个文件，以你网站名为命名的key文件和csr文件。<br>生成时会要求你填入国家，公司，email等，根据提示填入。</li>
</ul>
<p><em><strong>国内域名商的流程会不太一样，因为是要备案实名制，所以还会要求身份证信息等，而且是界面操作，无需通过以上命令行</strong></em></p>
</li>
<li><p>复制csr文件中的内容，通常如下：<br><img src="/2023/04/12/2023/04/how_to_create_new_site/csr-content.png"><br>复制时要包含全部内容，不要略去BEGIN和END那一行。</p>
</li>
<li><p>将csr粘贴到域名供应商配置界面，以namecheap为例，在你已购买的ssl证书界面点击active。<br><img src="/2023/04/12/2023/04/how_to_create_new_site/activate_ssl.png"><br>将刚才csr文件中的内容粘贴到该界面中。<br><img src="/2023/04/12/2023/04/how_to_create_new_site/copy_csr.png"><br>下一步中选择Add CNAME record<br><img src="/2023/04/12/2023/04/how_to_create_new_site/act_dcv_choice.png"><br>下一步中输入你的电子邮箱</p>
</li>
<li><p>完成后进入证书管理界面，按照如下操作<br><img src="/2023/04/12/2023/04/how_to_create_new_site/act_done_1.png"><br>此时会获取到下一步会用到的cname的host和target<br><img src="/2023/04/12/2023/04/how_to_create_new_site/cname_content.png"></p>
</li>
</ul>
<h3 id="注册DNS"><a href="#注册DNS" class="headerlink" title="注册DNS"></a>注册DNS</h3><p>  一般的域名供应商都会提供有dns服务，namecheap也有，但是功能都比较基础，通常建议使用第三方DNS供应商。国外的有google，cloud flare，国内也有阿里，百度等。<br>  以cloudflare为例</p>
<ul>
<li>点击add site，输入你的域名，选择free计划</li>
<li>输入你的域名和服务器的公网ip</li>
<li>在namecheap中的namerserver界面选择Custom DNS，输入cloudflare提供的两个dns服务器地址<br><img src="/2023/04/12/2023/04/how_to_create_new_site/namecheap_dns.png"></li>
<li>进入cloudflare的dns管理界面，添加一条cname记录，输入之前步骤中得到的cname的host和target，注意Proxy status这一栏要改成DNS only<br><img src="/2023/04/12/2023/04/how_to_create_new_site/cloudflare_dns.png"></li>
<li><em><strong>到这一步之后，ssl证书发放商就会把ssl证书发到你的邮箱</strong></em>，按照官网的说法，这个时间可能24到48小时，一般用不了那么久，一小时内就可以收到，如果没收到，去namecheap的<a href="https://decoder.link/">ssl校验网站</a>看下，如果有出错，那重新捋一遍上面的步骤。</li>
</ul>
<h3 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h3><ul>
<li>收到ssl证书后，通常发放邮件长下面这样，将邮件中的附件解压，包含三个文件，ca-bundle文件，crt文件和p7b文件<br><img src="/2023/04/12/2023/04/how_to_create_new_site/ssl_email.png"></li>
<li>将ca-bundle文件和crt文件上传到服务器，并执行如下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat your_domain.crt &gt; your_domain_chain.crt ; <span class="built_in">echo</span> &gt;&gt; your_domain_chain.crt ; cat your_domain.ca-bundle &gt;&gt; your_domain_chain.crt</span></span><br></pre></td></tr></table></figure></li>
<li>服务器安装ssl证书的方式有很多种，最常用的方式是nginx，以nginx为例，安装完nginx之后，进入/etc/nginx/conf.d/目录，新增一个your_domain.conf配置文件，配置文件内容如下<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  www.example.com;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$server_name$request_uri;</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">443</span> ssl;</span><br><span class="line">    # 域名，多个以空格分开</span><br><span class="line">    server_name  www.example.com;</span><br><span class="line">    </span><br><span class="line">    # ssl证书地址</span><br><span class="line">    ssl_certificate     /home/.ssl/example.crt;  # crt文件的路径</span><br><span class="line">    ssl_certificate_key  /home/.key/example.key; # key文件的路径，即生成csr文件步骤中的key文件</span><br><span class="line">    </span><br><span class="line">    # ssl验证相关配置</span><br><span class="line">    ssl_session_timeout  5m;    #缓存有效期</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法</span><br><span class="line">    ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;    #安全链接可选的加密协议</span><br><span class="line">    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http:<span class="comment">//localhost:8080/; # 服务器地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动nginx，即可在公网中访问到你的服务器了</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fetchAPI获取post请求中的stream数据</title>
    <url>/2023/04/24/2023/04/how-to-receive-stream-data-in-fetch/</url>
    <content><![CDATA[<h1 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h1><ul>
<li>希望用miniprogram实现调用chatGPT接口</li>
<li>miniprogram国内直接调用api.openai.com接口不通，需要国外购买服务器建站中转，即miniprogram-国外服务器-openai接口来实现</li>
<li>miniprogram线上环境无法调用任何没在国内备案的网站，因此无法通过上述中转方案实现</li>
<li>有两套替代方案，购买国内备案服务器，或者直接使用miniprogram云托管来实现，选择了后者，因为无需备案</li>
<li>miniprogram云托管中转调用国外服务器，再调用openai接口，可以实现</li>
<li>miniprogram云托管单个接口最大返回时间固定为15秒，而openai接口的完整数据返回往往大于这个时间</li>
<li>通过设定接口参数 <code>stream:true</code> 来实现流式传输，即接口数据可以先部分返回，通过长连接持续传输</li>
<li>流式传输有两种方案，<code>Server-Sent Events</code> 和 <code>fetch stream</code></li>
</ul>
<h1 id="SSE（Server-sent-Event）方案实现"><a href="#SSE（Server-sent-Event）方案实现" class="headerlink" title="SSE（Server-sent Event）方案实现"></a>SSE（Server-sent Event）方案实现</h1><p>参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">mdn文档</a>和<a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">阮一峰sse教程</a></p>
<h3 id="创建一个EventSource实例"><a href="#创建一个EventSource实例" class="headerlink" title="创建一个EventSource实例"></a>创建一个EventSource实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;ssedemo.php&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">&quot;//api.example.com/ssedemo.php&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="监听返回数据"><a href="#监听返回数据" class="headerlink" title="监听返回数据"></a>监听返回数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evtSource.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> eventList = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  newElement.textContent = <span class="string">`message: <span class="subst">$&#123;event.data&#125;</span>`</span>;</span><br><span class="line">  eventList.appendChild(newElement);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="定制监听事件"><a href="#定制监听事件" class="headerlink" title="定制监听事件"></a>定制监听事件</h3><p>在下述代码中，将会监听返回数据中事件字段中的<code>ping</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evtSource.addEventListener(<span class="string">&quot;ping&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> eventList = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> time = <span class="built_in">JSON</span>.parse(event.data).time;</span><br><span class="line">  newElement.textContent = <span class="string">`ping at <span class="subst">$&#123;time&#125;</span>`</span>;</span><br><span class="line">  eventList.appendChild(newElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="方法尝试结论"><a href="#方法尝试结论" class="headerlink" title="方法尝试结论"></a>方法尝试结论</h3><p>最终并不能实现需求，原因在于sse天生只支持get方式获取数据，对于post请求无法支持。<br><em><strong>另外发现miniprogram不支持server-sent events。</strong></em></p>
<h1 id="Fetch获取数据流"><a href="#Fetch获取数据流" class="headerlink" title="Fetch获取数据流"></a>Fetch获取数据流</h1><p>参考<a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">阮一峰fetch教程</a><br>核心处理方式就是利用fetch异步获取流的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reqData = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;superman&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://example.com/api&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: reqData</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> reader = response.body.getReader();</span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> TextDecoder();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;value, done&#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> str = decoder.decode(value);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样获取到的数据格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: some text</span><br><span class="line">data: another message</span><br><span class="line">data: with two lines</span><br></pre></td></tr></table></figure>
<p>需要进行进一步的分析处理</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>一周文章收集-20230602</title>
    <url>/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/</url>
    <content><![CDATA[<h2 id="radiation-hardened-quine-即使删除代码中任意字符，代码仍可以修正并运行"><a href="#radiation-hardened-quine-即使删除代码中任意字符，代码仍可以修正并运行" class="headerlink" title="radiation-hardened-quine: 即使删除代码中任意字符，代码仍可以修正并运行"></a><a href="https://github.com/mame/radiation-hardened-quine">radiation-hardened-quine: 即使删除代码中任意字符，代码仍可以修正并运行</a></h2><p>一个健壮的开源项目，如标题所述，可以修正错误的ruby代码，在缺少任一字符的情况下仍能正常运行。这个是有点神奇，细想一下要实现这样的算法并不是那么容易。感兴趣的可以研究下。</p>
<h2 id="如何使用R和OpenStreetMap制作精美的公路旅行地图"><a href="#如何使用R和OpenStreetMap制作精美的公路旅行地图" class="headerlink" title="如何使用R和OpenStreetMap制作精美的公路旅行地图"></a><a href="https://www.andrewheiss.com/blog/2023/06/01/geocoding-routing-openstreetmap-r/">如何使用R和OpenStreetMap制作精美的公路旅行地图</a></h2><p>作者利用R语言和开源项目<a href="https://www.openstreetmap.org/">OpenStreetMap</a>来绘制和家庭的旅程地图，就最后的呈现效果来说，个人觉得比较一般。<br><img src="/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/openstreetmap.png"></p>
<h2 id="SHOW-HN：通过简历自动搜寻合适的工作"><a href="#SHOW-HN：通过简历自动搜寻合适的工作" class="headerlink" title="SHOW HN：通过简历自动搜寻合适的工作"></a><a href="https://hnresumetojobs.com/">SHOW HN：通过简历自动搜寻合适的工作</a></h2><p>据称通过AI分析你的简历，然后搜寻合适的工作。随便试了下，结果出来的很快，快的让人觉得不太像经过AI分析。评论里也说到担心隐私的问题，谨慎使用吧。</p>
<h2 id="WITCH：一款用于替换macOS切屏的软件"><a href="#WITCH：一款用于替换macOS切屏的软件" class="headerlink" title="WITCH：一款用于替换macOS切屏的软件"></a><a href="https://manytricks.com/witch/">WITCH：一款用于替换macOS切屏的软件</a></h2><p>不仅可以在应用间切换，也可以在窗口和tab页之间切换，能够绑定到不同的按键，以更方便的进行不同的切换。</p>
<h2 id="MERCURY：一款可以将python代码转换为网页应用的软件"><a href="#MERCURY：一款可以将python代码转换为网页应用的软件" class="headerlink" title="MERCURY：一款可以将python代码转换为网页应用的软件"></a><a href="https://runmercury.com/">MERCURY：一款可以将python代码转换为网页应用的软件</a></h2><p>通过在python当中调用MERCURY的API，就可以实现对于网页应用的转换。</p>
<h2 id="brute-fail-一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试"><a href="#brute-fail-一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试" class="headerlink" title="brute.fail: 一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试"></a><a href="https://brute.fail/">brute.fail: 一个实时记录当前世界上用各种用户名密码组合进行非法入侵的尝试</a></h2><p><img src="/2023/06/02/2023/06/weekly-tech-blog-collection-20230602/brute.fail.png"></p>
<h2 id="AITemplate-开源的AI推理框架"><a href="#AITemplate-开源的AI推理框架" class="headerlink" title="AITemplate: 开源的AI推理框架"></a><a href="https://facebookincubator.github.io/AITemplate/">AITemplate: 开源的AI推理框架</a></h2><p>Meta公司推出的AI推理框架，可在Nvidia和AMD的GPU上进行运行。</p>
<h2 id="一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱"><a href="#一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱" class="headerlink" title="一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱"></a><a href="https://www.wired.com/story/web-deanonymization-side-channel-attack-njit/">一种新的攻击可以在任何主要浏览器上揭开匿名用户的面纱</a></h2><p>由新泽西理工学院的工程师发现，黑客可以通过用户的行为来获取用户的信息，比如是否拒绝网站的使用cookie信息和是否登陆的请求。</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>一周文章收集-20230604</title>
    <url>/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/</url>
    <content><![CDATA[<h2 id="为什么你应该继续使用telnet"><a href="#为什么你应该继续使用telnet" class="headerlink" title="为什么你应该继续使用telnet"></a><a href="https://bash-prompt.net/guides/telnet/">为什么你应该继续使用telnet</a></h2><p>随着ssh的盛行，telnet几乎已经被程序员抛弃了，但是在某些情况下，telnet可以帮你排查各种网络问题。这篇文章告诉你怎么使用telnet。</p>
<h2 id="自动驾驶在消亡"><a href="#自动驾驶在消亡" class="headerlink" title="自动驾驶在消亡"></a><a href="https://www.understandingai.org/p/the-death-of-self-driving-cars-is">自动驾驶在消亡</a></h2><p>这篇文章给出了不同于主流观点的对自动驾驶的看法，介绍了一些在自动驾驶行业在逐渐退去热度的迹象。包括比如Uber在2020年出售了自动驾驶业务，Lyft在2021年停止了开发。总而言之，比起在2015到2017年左右对于自动驾驶的预期来说，目前的自动驾驶行业发展远远未达到人们的预期。</p>
<h2 id="火车轨道上的石头是干嘛用的"><a href="#火车轨道上的石头是干嘛用的" class="headerlink" title="火车轨道上的石头是干嘛用的"></a><a href="https://www.alpharail.co.nz/why-do-railway-tracks-have-crushed-stones-alongside-them/">火车轨道上的石头是干嘛用的</a></h2><p>铁轨上的石头尖锐而坚固，这篇文章介绍了为何需要在铁轨上铺设石头，简而言之，石头可以帮助减震，帮助承受火车经过时产生的巨大冲击力。</p>
<h2 id="Chirper-ai：一个完全由AI机器人参与的社交媒体"><a href="#Chirper-ai：一个完全由AI机器人参与的社交媒体" class="headerlink" title="Chirper.ai：一个完全由AI机器人参与的社交媒体"></a><a href="https://www.fry-ai.com/p/social-media-no-humans-allowed">Chirper.ai：一个完全由AI机器人参与的社交媒体</a></h2><p>在这个<a href="https://chirper.ai/">网站</a>通过指定一个昵称和描述一下这个机器人的设定，后台就会自动生成一个机器人，参与社交媒体的内容创作和互动。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_1.png"><br>这个机器人会按照你的设定来进行内容创作，会去关注和回复其他机器人。并且拥有独立的性格和情感。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_2.png"><br>有些互动让人感到颇为惊讶。<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/social_AI_3.png"></p>
<h2 id="google官方的免费创造性AI课程"><a href="#google官方的免费创造性AI课程" class="headerlink" title="google官方的免费创造性AI课程"></a><a href="https://www.cloudskillsboost.google/journeys/118">google官方的免费创造性AI课程</a></h2><p>目前包含十节课，介绍了大语言模型，图像生成模型等等，学习门槛较高，需要英语能力和梯子。</p>
<h2 id="封闭模型训练数据的来源令人担忧"><a href="#封闭模型训练数据的来源令人担忧" class="headerlink" title="封闭模型训练数据的来源令人担忧"></a><a href="https://simonwillison.net/2023/Jun/4/closed-model-training/">封闭模型训练数据的来源令人担忧</a></h2><p>这篇文章描述了作者对于封闭模型的训练数据来源的担忧，比如copilot可能取用github上用户的代码，google的人工智能模型bard也曾经提及他们的数据可能来自gmail。</p>
<h2 id="RARBG-IPFS：搜索IPFS资源"><a href="#RARBG-IPFS：搜索IPFS资源" class="headerlink" title="RARBG IPFS：搜索IPFS资源"></a><a href="https://ipfs.io/ipfs/QmbpRxBZ5HDZDVRoeAU8xFYnoP4r5eGCxdkmfFW3JbA6mq/">RARBG IPFS：搜索IPFS资源</a></h2><p>如果不知道什么是IPFS（The InterPlanetary File System 星际传输文件系统），看下这个<a href="https://docs.ipfs.tech/">https://docs.ipfs.tech/</a>，有点类似以前的磁力链接，是去中心化趋势中的产物。下载客户端就意味着你的机器成为一台IPFS的资源主机，可用的下载链接将会在网络上进行传播。可以看看下面的这个图片里的讨论.<br><img src="/2023/06/04/2023/06/weekly-tech-blog-collection-20230604/IPFS.png"></p>
<h2 id="privateGPT-可以在本地实现问答的聊天机器人"><a href="#privateGPT-可以在本地实现问答的聊天机器人" class="headerlink" title="privateGPT:可以在本地实现问答的聊天机器人"></a><a href="https://github.com/SamurAIGPT/privateGPT">privateGPT:可以在本地实现问答的聊天机器人</a></h2><p>通过利用本地LLM的能力，在不依赖于互联网的情况下创建一个基于您的文档的问答聊天机器人。确保完全的隐私和安全性，因为您的数据永远不会离开本地执行环境。即使没有互联网连接，也可以无缝地处理和查询您的文档。</p>
<h2 id="Arroyo：一个用Rust编写的分布式流处理引擎"><a href="#Arroyo：一个用Rust编写的分布式流处理引擎" class="headerlink" title="Arroyo：一个用Rust编写的分布式流处理引擎"></a><a href="https://github.com/ArroyoSystems/arroyo">Arroyo：一个用Rust编写的分布式流处理引擎</a></h2><p>简而言之，Arroyo使您能够对高容量实时数据提出复杂问题，并获得亚秒级的结果。相比起世面已存在的流引擎（Apache Flink、Spark Streaming和Kafka Streams），Arroyo有如下特点，是无服务的，高性能SQL，以及为非专家设计。</p>
<h2 id="黑镜导演利用chatGPT进行剧本创作"><a href="#黑镜导演利用chatGPT进行剧本创作" class="headerlink" title="黑镜导演利用chatGPT进行剧本创作"></a><a href="https://www.empireonline.com/tv/news/charlie-brooker-chatgpt-black-mirror-episode-exclusive-image/">黑镜导演利用chatGPT进行剧本创作</a></h2><p>英剧《黑镜》系列是关于在未来，科技的发展对于人类造成危害。因此，当黑镜的导演用chatGPT创作故事时，整个事情听上去就颇为黑色幽默。不过最后导演说chatGPT的故事只是初看起来合理，仔细琢磨之后狗屁不通。</p>
<h2 id="fastgen：一个低代码工具，以进行快速开发"><a href="#fastgen：一个低代码工具，以进行快速开发" class="headerlink" title="fastgen：一个低代码工具，以进行快速开发"></a><a href="https://fastgen.com/">fastgen：一个低代码工具，以进行快速开发</a></h2><p>Fastgen是一个低代码软件平台，允许用户快速轻松地构建API端点和工作流程。Fastgen提供直观友好的界面，无需深入的编程知识即可创建API和工作流程。</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>一周文章收集-20230619</title>
    <url>/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/</url>
    <content><![CDATA[<h2 id="OpenLLM：开源的大语言模型"><a href="#OpenLLM：开源的大语言模型" class="headerlink" title="OpenLLM：开源的大语言模型"></a><a href="https://github.com/bentoml/OpenLLM">OpenLLM：开源的大语言模型</a></h2><p>通过OpenLLM，可以使用任何开源的大型语言模型进行推断，将其部署到云端或本地，以及构建强大的人工智能应用程序。<br>需要服务器安装python3.8或以上以及pip。</p>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install openllm</span><br></pre></td></tr></table></figure>
<h4 id="验证是否安装正确"><a href="#验证是否安装正确" class="headerlink" title="验证是否安装正确"></a>验证是否安装正确</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ openllm -h</span><br></pre></td></tr></table></figure>

<h4 id="启动LLM服务器"><a href="#启动LLM服务器" class="headerlink" title="启动LLM服务器"></a>启动LLM服务器</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openllm start dolly-v2</span><br></pre></td></tr></table></figure>

<p>以上命令会在 <a href="http://localhost:3000/">http://localhost:3000</a> 发布一个前端页面。</p>
<h4 id="命令行中使用"><a href="#命令行中使用" class="headerlink" title="命令行中使用"></a>命令行中使用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENLLM_ENDPOINT=http://localhost:3000</span><br><span class="line">openllm query <span class="string">&#x27;Explain to me the difference between &quot;further&quot; and &quot;farther&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中，语言模型是可以换的，包含<a href="https://huggingface.co/docs/transformers/model_doc/flan-t5">flan-t5</a>，<a href="https://github.com/databrickslabs/dolly">dolly-v2</a>等等。</p>
<h2 id="Nix初体验"><a href="#Nix初体验" class="headerlink" title="Nix初体验"></a><a href="https://mtlynch.io/notes/nix-first-impressions/">Nix初体验</a></h2><p><a href="https://nix.dev/">Nix</a>是一种采用独特方法进行软件包管理和系统配置的工具。作者介绍了之前使用过的<a href="https://github.com/saltstack/salt">Salt</a>和<a href="https://github.com/ansible/ansible">Ansible</a>。关于这两者的对比，可以看这篇文章<a href="https://www.redhat.com/en/topics/automation/ansible-vs-salt">Ansible vs Salt</a>。</p>
<p>对于Salt和Ansible完全不了解的小伙伴可以看下chatGPT的介绍，足够简洁了。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/ansible_vs_salt.png"></p>
<p>作者介绍了Nix的多个好处，包括快速搭建，可本地部署，原子级修改等等。同时也说到Nix目前文档不足，想要用好Nix需要具备非常丰富的经验。最后也写了几个成功和失败的部署经验。</p>
<h2 id="PostgreSQL重新考虑其基于进程的模型"><a href="#PostgreSQL重新考虑其基于进程的模型" class="headerlink" title="PostgreSQL重新考虑其基于进程的模型"></a><a href="https://lwn.net/SubscriberLink/934940/3abb2d4086680b78/">PostgreSQL重新考虑其基于进程的模型</a></h2><p>这条新闻需要了解的前提是，PostgreSQL是一个多进程的数据库，在一个运行的PostgreSQL实例中，会有多个进程同时运行来协同完成不同的任务和处理多个客户端连接。</p>
<p>而今年六月初，PostgreSQL的重要贡献者之一Heikki Linnakangas提议将PostgreSQL改为基于线程的模型。他的理由如下：</p>
<ul>
<li>进程模型已经不适应时代的发展，尤其不适用于大型机器。</li>
<li>进程的上下文切换开销过大，他认为这种开销以后还会继续增大，导致将花费大量时间在TLB缺失上。</li>
<li>进程模型对开发造成了成本，迫使项目维护大量重复的代码，包括几个在单一地址空间中不需要的内存管理机制。</li>
<li>他认为线程模型没有如上问题。</li>
</ul>
<p>这个提议在论坛上引发大量讨论，首先就是认为这种涉及底层的更改会带来灾难性的后果，导致大量bug，使得现存的很多项目都无法运行。另外，这种转变为线程的好处是否足够明显，在转变初期，必然是线程和进程模式并存的方式，在这种情况下，是否有足够的动力让开发人员转变为线程方式。</p>
<p>这个问题的提出值得深思，一些古老的代码语言和框架，随着时代的发展，其底层架构很可能已经不适合现代了，但是整体大修的成本过高，带来的好处又不一定明显，对现有项目的运行却可能是灾难性的。这种事情曾在PHP6上发生过，PHP6尝试重构了字符串的底层实现，结果非常糟糕，使得PHP的发展几乎停滞了十年，最后重新发布了PHP7，字符串回归了PHP5的实现。</p>
<h2 id="MVC不是MVC"><a href="#MVC不是MVC" class="headerlink" title="MVC不是MVC"></a><a href="https://collindonnell.com/mvc-isnt-mvc">MVC不是MVC</a></h2><p>如今众所周知的MVC设计模式来源于1979年Xerox PARC的一名雇员Trygve Reenskaug在一篇论文中提出的，其原文仅500字，描述了每个部分的功能和作用，简单概括下就是：</p>
<ul>
<li>Models（模型）：应用程序中表示用于组织应用程序数据的抽象部分。模型的每个部分应该表示问题的一部分。当模型的数据发生变化时，模型会通知视图。</li>
<li>Views（视图）：模型的可视化表示。视图通过直接查询模型进行更新，并且会收到模型的更新通知。视图可以直接更新其模型。视图不应直接了解键盘和鼠标事件等事物。</li>
<li>Controllers（控制器）：用户和系统之间的连接。在屏幕上安排视图，接收用户输入，将消息传递给视图，并更新模型。</li>
</ul>
<p>另外他还定义了一个特殊的控制器叫Editor：</p>
<ul>
<li>Editors（编辑器）：一种控制器，它临时插入在控制器和视图之间用于编辑。如果你想象一个联系人应用程序，当用户点击编辑时，可能会创建一个编辑器，然后在保存或取消时被丢弃，并根据需要更新模型。编辑器允许用户对数据进行修改，提供临时的编辑环境，并在编辑完成后将更改传递给模型。</li>
</ul>
<p>在Reenskaug的设想里，MVC的每个部分都发挥着重要作用，其运作方式如下图：<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc1.png"></p>
<h4 id="MVC概念转变"><a href="#MVC概念转变" class="headerlink" title="MVC概念转变"></a>MVC概念转变</h4><p>如今概念里的MVC和他的最初定义已经大相径庭，苹果风格的MVC如下：<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc2.png"><br>可以看出，View和Model的作用被大幅削弱，只是被动的给controller提供用户行为和数据，一切更新操作都由Controller来控制。</p>
<p>在1990年代，java的开发者提出一种新的MVC模型，叫Model-2，在这个模型里多了http的请求，请求经过controller，然后通过controller来返回view。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/mvc3.jpeg"></p>
<p>可以看出，如今耳熟能详的MVC跟一开始的MVC已经完全不同，只是保留了模型中的三个概念，每个概念发挥的作用却已经完全不同。</p>
<h2 id="AI带来了60年以来的第一种新的用户交互方式"><a href="#AI带来了60年以来的第一种新的用户交互方式" class="headerlink" title="AI带来了60年以来的第一种新的用户交互方式"></a><a href="https://www.nngroup.com/articles/ai-paradigm/">AI带来了60年以来的第一种新的用户交互方式</a></h2><p>ChatGPT和其他AI系统带来了在计算机历史上的第三种用户交互方式。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/UI-paradigm.jpeg"></p>
<h4 id="第一种交互方式：批处理进程"><a href="#第一种交互方式：批处理进程" class="headerlink" title="第一种交互方式：批处理进程"></a>第一种交互方式：批处理进程</h4><p>在1945年计算机诞生之初，用户需要通过在打孔卡片上输入一系列需要计算机完成的完整工作流程，来让计算机一次性完成。用户体验当然是非常糟糕的，在计算机执行完任务之前，用户和计算机之间无法有任何其他交互。而每次结果出来往往需要隔天才能拿到，用户根据结果对打孔卡片进行调整，继续执行用户，最终要数天才能执行完成一个任务。</p>
<h4 id="第二种交互方式：基于命令的交互设计"><a href="#第二种交互方式：基于命令的交互设计" class="headerlink" title="第二种交互方式：基于命令的交互设计"></a>第二种交互方式：基于命令的交互设计</h4><p>大约在1964年，时分共享的出现（通过连接的终端使多个用户共享一台大型机）引导了第二种用户界面范式：基于命令的交互。这个时候，用户的输入可以得到计算机的反馈，从而调整自己的命令输入，而且可以精细到每次只用输入一行命令。包括dos的命令行界面，全屏文本终端（IBM），图形化界面都是属于这种交互方式。</p>
<h4 id="第三种交互方式：意图导向的交互方式"><a href="#第三种交互方式：意图导向的交互方式" class="headerlink" title="第三种交互方式：意图导向的交互方式"></a>第三种交互方式：意图导向的交互方式</h4><p>在AI模型下，你不用像过去那样告诉计算机<strong>做什么</strong>，而是直接告诉计算机<strong>你想要什么</strong>。作者举了个例子，比如你想要如下一幅画，</p>
<blockquote>
<p>为一本低俗科幻杂志的封面绘制一幅合适的插图，画面中展示了一个穿着太空服的牛仔在一个无氧行星上，天空中有两颗红色的月亮。</p>
</blockquote>
<p>在AI出现之前，你需要在photoshop上进行大量的操作来达到你的意图，而如今你直接告诉AI就可以。<br><img src="/2023/06/19/2023/06/weekly-tech-blog-collection-202306019/redmoon.jpeg"></p>
<p>作者认为，未来的人工智能系统很可能会采用混合用户界面，结合意图导向和基于命令的界面元素，同时保留许多图形用户界面的元素。</p>
]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230621</title>
    <url>/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/</url>
    <content><![CDATA[<p>今天尝试下详细介绍一篇有意思的博文，和若干篇值得一看的技术资讯。</p>
<h1 id="今日关注"><a href="#今日关注" class="headerlink" title="今日关注"></a>今日关注</h1><h2 id="同时在三个平台上发布我的独立游戏，在财务上却失败了"><a href="#同时在三个平台上发布我的独立游戏，在财务上却失败了" class="headerlink" title="同时在三个平台上发布我的独立游戏，在财务上却失败了"></a><a href="https://juicybeast.com/2016/01/11/releasing-an-indie-game-on-3-consoles-at-once-and-failing-financially/#2-years">同时在三个平台上发布我的独立游戏，在财务上却失败了</a></h2><p>作者讲述了自己在2013到2015年开发了一款独立游戏，叫做<a href="https://store.steampowered.com/app/342920/Toto_Temple_Deluxe/">Toto Temple</a>，并在2015年9月在PS4, Xbox One, Wii U 和 Steam上发布，最终销售额却不佳，作者回顾这一段经历，并分析可能的原因。</p>
<h3 id="销售额"><a href="#销售额" class="headerlink" title="销售额"></a>销售额</h3><p>下图是销售额和开发成本的对比。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/revenues.png"><br>左边是各个平台的销售占比，右边是成本，包括了市场营销，代码开发，移植，图形开发等。到作者发文时，游戏总共卖出了6000份，远远达不到他的开发成本。</p>
<h3 id="为什么这个游戏开发了两年？"><a href="#为什么这个游戏开发了两年？" class="headerlink" title="为什么这个游戏开发了两年？"></a>为什么这个游戏开发了两年？</h3><p>作者说到开发过程中并没有什么具体的规划，只是抓住了各种机遇。</p>
<p>他回顾了第一年获得了<a href="https://zh.wikipedia.org/wiki/Ouya">Ouya</a>公司(Ouya是2013年成立的一个游戏机公司，已在2019年倒闭)的投资，几乎没花任何自己的钱上线了Toto Temple Deluxe版本。并且初期反馈也相当不错，这让他觉得很有成就感。</p>
<p>第二年作者和三大平台的游戏巨头进行了接触，并且获得了认可。然而由于游戏已在ouya发行，因此无法获得另一份的独占协议。这种情况下，他的开发团队决定在三大平台发行游戏，基于两点考虑：</p>
<ul>
<li>三个平台可以获得三倍销售额。</li>
<li>同时在三大平台发行可以获得一定的关注，并能够和三大平台的老总进行对话。<span id="more"></span>
<h3 id="这个游戏真的好玩吗？"><a href="#这个游戏真的好玩吗？" class="headerlink" title="这个游戏真的好玩吗？"></a>这个游戏真的好玩吗？</h3></li>
</ul>
<p>游戏的玩法基于多人合作对抗的形式，可以和小伙伴一起在家里玩。作者认为游戏是好玩的，他也放出来一段在游戏展会上玩家玩的很开心的视频。</p>
<h3 id="游戏玩法分析"><a href="#游戏玩法分析" class="headerlink" title="游戏玩法分析"></a>游戏玩法分析</h3><p>作者不认为游戏销量不佳是因为游戏不好玩。不过他也说到这款游戏在玩法上和别的多人游戏的不同。</p>
<ul>
<li>对于新手不友好。游戏上手难度颇高，需要一定的时间适应它的移动方式，除此之外，获胜方式也不那么直观，不是一键击杀或者到达某个点，而是要不断将山羊带到正确的点获取得分。</li>
<li>画面展示。游戏不好上手或者有难度也不是主要原因，毕竟很多游戏就靠着难度获得乐趣。但是这款游戏的画面往往让新手搞不清楚发生甚么，太过于杂乱而没有重点。即使玩家搞清楚了画面重点，观众也get不到，<strong>这一点颇为重要，这个致命的缺陷导致游戏无法在youtube或twitch等平台上流行起来。</strong><br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/tototemple.png"></li>
<li>强度变化。多数其他游戏在高强度的击杀或者阶段获胜后会有一段比较轻松的时间，以让玩家获得喘息。但是toto temple需要玩家一直保持高度注意力，直到这一局的最终获胜，因此也让开发者不得不将每局游戏的时间设计到在两分钟以内结束。</li>
</ul>
<p>这些玩法因素可能不是导致游戏销量失败的主要原因，但确实让玩家的游玩感受不太友好。</p>
<h3 id="主题，标题和预告片分析"><a href="#主题，标题和预告片分析" class="headerlink" title="主题，标题和预告片分析"></a>主题，标题和预告片分析</h3><p>主题，标题和预告片这三个因素决定了玩家是不是会对你的游戏感兴趣。作者认为自己在这方面没有做好。</p>
<ul>
<li><strong>主题过时</strong>。游戏主题是玛雅神庙寻宝，作者后悔没有在初次讨论后重新决定主题，因为这个主题显然无法引起太多玩家的兴趣，玩家在进入游戏前就大概知道玛雅，神庙，寻宝这样的主题会是什么样的，因此会丧失探索的欲望，直接影响玩家的购买欲。</li>
<li><strong>标题混淆</strong>。在初次讨论标题的时候，作者的团队认为标题一定要足够吸引人，因此采用了连续的T开头的单词。而这个标题也确实不太差，很快的在google上有了一定的搜索量。然而随着时间推移，作者意识到，这个标题完全没有展现出玩法，尤其是加上“deluxe（豪华版）”之后，让很多的玩家怀疑这是一个小品级的解谜游戏。这导致了很多潜在玩家的流失。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/deluxe_puzzle.png"></li>
<li><strong>预告片差强人意</strong>。作者分析了自己的两段预告片，指出由于游戏玩法的复杂性，让他非常渴望在预告片中告诉玩家游戏机制和所有的内容，使得预告片画面切换太快，也太过混乱。作者甚至还介绍了另一篇<a href="http://www.kertgartner.com/making-entertaining-and-engaging-video-game-trailers/">文章</a>，用于说明如何制作一个吸引人的预告片。</li>
</ul>
<h3 id="市场营销"><a href="#市场营销" class="headerlink" title="市场营销"></a>市场营销</h3><p>作者说自己并没有太多市场营销的经验，但是也为这款游戏努力做了很多自己以前不曾做过的事。包括参展，公关，真山羊活动，在twitch上组织抽奖活动等。</p>
<ul>
<li>Pax展会上支付公关费。公关公司很厚道的给了他们一个折扣价，但是不管由于主观还是客观原因，最终没有任何网站和他们进行接触。</li>
<li>免费发放了价值17000美元的steam key。确实吸引了很多的玩家，但没有得到足够的媒体关注，因此宣传效果非常有限。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/pax_showdown_banner.png"></li>
<li>真山羊活动。购买者花费60美元可以获得4份游戏的steam key，同时在慈善网站上以玩家的名义购买一只山羊。然而这个公益性质的活动没有卖出任何一份，究其原因，作者认为有几个：<ul>
<li>显而易见，价格过高。尽管60美元也只是刚好够买一只山羊，是纯公益的活动，但是玩家并不会因为公益性质就更愿意购买。</li>
<li>只能在PC上组织这个活动，在更流行的主机上无法发起。</li>
<li>游戏不支持多人在线游玩，线下一份游戏就可以四人同时玩，因此购买四份游戏对于玩家来说意义不大。</li>
</ul>
</li>
<li>组织机器人赌注比赛。在twitch上发起了一场活动，由四个AI机器人控制角色进行游戏，而观众则是在游戏开始前下注哪个机器人能赢，赌赢的观众可以免费获得一份游戏的steam key。这场活动最终送出了1400份steam key，作者认为这是个有意思的活动，尽管最后并没有给销量带来什么帮助。</li>
<li>游戏客串角色。在游戏里可以解锁各种其他游戏里的不同角色造型，以替换山羊的造型。这个新的功能给游戏带来了海量的新角色，直到今天依然有更新。很难计算这个功能带来了多少曝光量，但作者对于这个功能确实非常满意。</li>
<li>新闻系统。这个指的是所有获得免费steam key的玩家需要提供他们的邮箱以订阅开发团队的新闻。最后统计出了有1437个人订阅了邮件，34%的人打开阅读了邮件，5%的人点击了它。这个结果也还算不错。</li>
</ul>
<h3 id="所以为什么游戏卖的不好呢？"><a href="#所以为什么游戏卖的不好呢？" class="headerlink" title="所以为什么游戏卖的不好呢？"></a>所以为什么游戏卖的不好呢？</h3><p>可以看到，作者认为游戏还挺好玩的，玩家也充分的参与到了他们组织的各种市场营销活动中，也通过公关公司接触了一些媒体。所以到底是为什么这个游戏卖的不好呢？作者简单说了几点：</p>
<ul>
<li><strong>不够吸引人</strong>。像前文所述，不管是主题还是玩法，都使得玩家难以第一时间了解游戏的魅力。</li>
<li><strong>没有线上模式</strong>。作者团队认为这是最大的原因，游戏需要现实中的朋友来一起玩，这是一个很大的限制。在论坛上也充斥着这样的讨论。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/no-online.png"></li>
<li><strong>开发周期过长</strong>。在2014年的时候，本地的多人游戏还是比较时兴的，但是这种游戏没多久就过时了，已经没人玩这种类型的游戏了。</li>
<li><strong>同时在三大平台发行</strong>。移植到各个平台花费了他们大量的时间和精力，在这个过程中基本就是不断的修复bug，产生bug，修复bug。。。</li>
</ul>
<h3 id="如果有下次"><a href="#如果有下次" class="headerlink" title="如果有下次"></a>如果有下次</h3><ul>
<li><strong>不要搞本地多人游戏</strong>。本地多人游戏规划起来是很简单，但是太难市场推广了。</li>
<li><strong>先签协议</strong>。要跟游戏平台签下独占协议，这样会让后续简单很多。</li>
<li><strong>只发行一个平台</strong>。和上一条呼应，一次性在多个平台发行游戏成本太高，回报太少。</li>
<li><strong>从市场角度进行设计</strong>。分析市场需求非常重要，不要埋头苦想。作者推荐看Ryan Clark的的文章<a href="https://www.gamedeveloper.com/business/what-makes-an-indie-hit-how-to-choose-the-right-design">《What Makes an Indie Hit》</a>进行学习。</li>
</ul>
<h3 id="结尾的话"><a href="#结尾的话" class="headerlink" title="结尾的话"></a>结尾的话</h3><p>这篇文章写的情真意切，看得出来作者对这个付出了两年心血的游戏感情复杂，有懊悔一些决定，有欣慰一些活动的成功，有感激团队成员的辛勤付出。而最终，不管是偏见还是事实，他认为游戏并不是不好玩，但确实是个失败的作品。作者写下这篇文章也是为了总结过去的失败教训，为下部作品积累经验。</p>
<p><strong>而我们做程序员的也应该学习到，开发水平的高低往往并不是决定你的项目成功的关键，最主要还是得搞清楚市场需要什么，这点是程序员的弱项，但是也是必须要解决的，否则只能是像作者这样浪费无数个两年。</strong></p>
<h1 id="博文一览"><a href="#博文一览" class="headerlink" title="博文一览"></a>博文一览</h1><h3 id="cryptopals-加密挑战"><a href="#cryptopals-加密挑战" class="headerlink" title="cryptopals 加密挑战"></a><a href="https://cryptopals.com/">cryptopals 加密挑战</a></h3><p>帮助你了解现实世界中用到的加密算法的底层原理以及可能被攻击的方式。目前包含了总共66个挑战题目，从简单到难，对于计算机的加密算法感兴趣的同学可以看看。<br>以下是一些挑战的截图：<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/crypto1.png"><br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/crypto2.png"></p>
<h3 id="DevPod：开源，无需服务端，可复现的开发环境的codespaces"><a href="#DevPod：开源，无需服务端，可复现的开发环境的codespaces" class="headerlink" title="DevPod：开源，无需服务端，可复现的开发环境的codespaces"></a><a href="https://devpod.sh/">DevPod：开源，无需服务端，可复现的开发环境的codespaces</a></h3><p>DevPod是一个用于创建可复现的开发者环境的工具。基本流程是通过git下载代码，根据devcontainer.json文件指定代码运行环境。对比docker，codespaces等，优点是开源，无需服务端，轻量级。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/devpod.png"></p>
<h3 id="所有配置文件都应该报告其所在位置"><a href="#所有配置文件都应该报告其所在位置" class="headerlink" title="所有配置文件都应该报告其所在位置"></a><a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ReportConfigFileLocations?showcomments#comments">所有配置文件都应该报告其所在位置</a></h3><p>这篇文章指出大部分程序拥有不同的配置文件位置，有些在系统配置文件目录，有些在用户目录，这些程序都自认为将配置文件放在了大部分人知道的位置。这导致了系统中的程序一多，就会让管理员要搜索所有可能的位置去查找配置文件所在。（对于我来说，找配置文件就是google一下，局限就是必须得有网络。）<br>作者认为应该有一个统一直观的方式查到程序的配置文件位置，例如”program –help”。<br>这篇博文引起了一些讨论，大部分都认同，也有人提出不仅如此，同时配置文件也应该统一读取优先级的问题，有些配置以首次读取为准，有些配置又是最后一次配置为准，这就非常混乱。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/config1.png"></p>
<h3 id="哈佛的新计算机科学老师是一个聊天机器人"><a href="#哈佛的新计算机科学老师是一个聊天机器人" class="headerlink" title="哈佛的新计算机科学老师是一个聊天机器人"></a><a href="https://www.independent.co.uk/tech/harvard-chatbot-teacher-computer-science-b2363114.html">哈佛的新计算机科学老师是一个聊天机器人</a></h3><p>哈佛计划采用基于chatgpt的聊天机器人用于教授计算机科学课程。哈佛教授David Malan认为机器人教学的好处至少有几点：</p>
<ul>
<li>一对一教学</li>
<li>7天24小时不间断</li>
<li>针对学生进行个性化教学</li>
</ul>
<h3 id="OpenResume-开源的简历生成器"><a href="#OpenResume-开源的简历生成器" class="headerlink" title="OpenResume: 开源的简历生成器"></a><a href="https://www.open-resume.com/">OpenResume: 开源的简历生成器</a></h3><p>先看看具体效果，个人认为还是比较简洁美观的，可以持续关注。比起市面上一堆花里胡哨的简历，这种简历我认为更能看得下去，关键是<strong>免费</strong>。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/openresume1.png"><br>支持pdf导入已有简历，或者根据他的模版一步步建立。<br><img src="/2023/06/20/2023/06/weekly-tech-blog-collection-202306021/openresume2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>每日文章收集-20230626</title>
    <url>/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h2 id="vrite-开源无界面内容管理系统（CMS），适用于编程博客、文档等"><a href="#vrite-开源无界面内容管理系统（CMS），适用于编程博客、文档等" class="headerlink" title="vrite: 开源无界面内容管理系统（CMS），适用于编程博客、文档等"></a><a href="https://vrite.io/">vrite: 开源无界面内容管理系统（CMS），适用于编程博客、文档等</a></h2><p>vrite开源的专用于写作技术内容的CMS系统。根据官网介绍，具有几个特点：</p>
<ul>
<li>简洁的UI</li>
<li>内置看板界面，可以轻松管理任意规模的产品流程</li>
<li>所见即所得，支持markdown和快捷键，协同写作等</li>
<li>对技术写作量身定做，支持高亮，自动补全等</li>
<li>提供API和webhook，与各种前端界面轻松集成</li>
<li>完备的权限管理系统</li>
</ul>
<h3 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h3><p>Vrite使用三个概念来组织管理内容。</p>
<ul>
<li>工作空间（Workspaces）：独立的单元，用于存储许多内容组（Content groups）、配置API访问或编辑体验的设置，以及关于整个团队及其角色的详细信息；可以创建或被加入到任意数量的工作区。</li>
<li>内容组（Content groups）：如果熟悉看板界面的话，这就相当于看板仪表中的列，用于组织内容碎片（Content pieces）。</li>
<li>内容碎片（Content pieces）：相当于看板界面中的卡片，用于编辑具体的内容，包含实际的内容和相关元数据。</li>
</ul>
<h3 id="使用工作空间"><a href="#使用工作空间" class="headerlink" title="使用工作空间"></a>使用工作空间</h3><p>点击侧边栏切换工作空间。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite2.png"><br>在该界面选择或新增工作空间。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite3.png"></p>
<span id="more"></span>
<h3 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h3><p>进入工作空间后，左边一栏是内容碎片的属性。右边是内容组和内容碎片。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite4.png"><br>点击内容碎片进入编辑界面后，将看到vrite所见即所得的特性。</p>
<ul>
<li>弹起菜单：选择任意内容，会弹出浮动菜单用于选择样式，包括加粗，斜体，代码，链接等<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite5.png"></li>
<li>段落菜单：在段落前或者空白区域键入“/”键就会弹出段落菜单。可以选择将段落定义为选定的格式。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite6.png"></li>
<li>链接菜单：将鼠标移动到一个包含超链接的内容上时，会出现该链接网页的预览内容。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite7.png"></li>
<li>支持任意markdown语法，同时还可使用快捷键快速定义格式。</li>
<li>特殊格式的内容会弹出一个编辑预览的内容块，例如图片，代码等。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite8.png"></li>
<li>顶部栏包含三个功能<ul>
<li>内容统计：统计段落，单词数，字符数，代码行数。</li>
<li>导出：支持导出json，html，github适用的markdown格式。</li>
<li>禅模式：仅保留内容，剔除所有的菜单和干扰，专注于内容编辑。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite9.png"></li>
</ul>
</li>
<li>支持协同编辑，团队成员编辑过的内容会显示高亮并展示成员的名字。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite10.png"></li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>vrite的插件中心目前并不支持第三方的插件，只包含了四个和功能相关的插件。</p>
<ul>
<li>Hashnode：自动发布到<a href="https://hashnode.com/">Hashnode</a>。</li>
<li>Dev.to：自动发布到<a href="https://dev.to/">Dev.to</a>。</li>
<li>Medium：自动发布到<a href="https://medium.com/">Medium</a>。</li>
<li>GPT-3.5: 编辑内容时可以直接让chatGpt生成。</li>
</ul>
<h3 id="JavaScript-SDK"><a href="#JavaScript-SDK" class="headerlink" title="JavaScript SDK"></a>JavaScript SDK</h3><p>通过npm安装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @vrite/sdk</span><br></pre></td></tr></table></figure>
<p>安装完成后可以通过sdk提供的工具方法获取内容组和内容碎片等。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/vrite11.png"></p>
<h3 id="自托管"><a href="#自托管" class="headerlink" title="自托管"></a>自托管</h3><p>网站说明文档暂不建议现在进行自托管，因为vrite的稳定版本到2023年的第三季度才会发布。如果要进行自托管，网站也进行了一些说明。<br>项目结构基于<a href="https://turbo.build/repo">Turborepo</a></p>
<ul>
<li>最重要的依赖是：<ul>
<li>Typescript</li>
<li>Solid.js</li>
<li>Fastify</li>
<li>tRpc</li>
<li>Tiptap &amp; ProseMirror </li>
<li>Y.js &amp; HocusPocus </li>
<li>Monaco Editor </li>
<li>Astro </li>
</ul>
</li>
<li>目录结构<ul>
<li>/package<ul>
<li>/backend</li>
<li>/components</li>
<li>/editor</li>
<li>/extensions</li>
<li>/scripts</li>
<li>/sdk/javascript</li>
</ul>
</li>
<li>/apps<ul>
<li>/backend/api</li>
</ul>
</li>
<li>…….</li>
</ul>
</li>
<li>环境变量<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Database</span></span><br><span class="line">MONGO_URL=</span><br><span class="line">REDIS_URL=</span><br><span class="line">DATABASE=</span><br><span class="line"><span class="comment"># Security</span></span><br><span class="line">SECRET=</span><br><span class="line"><span class="comment"># Domains</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
目前vrite的数据库基于MongoDB，Redis，S3。</li>
</ul>
<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="try命令：试一下你的命令并看下效果"><a href="#try命令：试一下你的命令并看下效果" class="headerlink" title="try命令：试一下你的命令并看下效果"></a><a href="https://github.com/binpash/try">try命令：试一下你的命令并看下效果</a></h3><p>安装这个try命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/binpash/try.git</span><br></pre></td></tr></table></figure>
<p>使用try并执行别的命令，可以看到命令的预期效果。并会在结尾询问是否要真实执行该命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">try pip3 install libdash</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Defaulting to user installation because normal site-packages is not writeable</span><br><span class="line">Collecting libdash</span><br><span class="line">  Downloading libdash-0.3.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (254 kB)</span><br><span class="line">     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 254.6/254.6 KB 2.1 MB/s eta 0:00:00</span><br><span class="line">Installing collected packages: libdash</span><br><span class="line">Successfully installed libdash-0.3.1</span><br><span class="line">WARNING: Running pip as the <span class="string">&#x27;root&#x27;</span> user can result <span class="keyword">in</span> broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv</span><br><span class="line"></span><br><span class="line">Changes detected <span class="keyword">in</span> the following files:</span><br><span class="line"></span><br><span class="line">/tmp/tmp.zHCkY9jtIT/upperdir/home/gliargovas/.<span class="built_in">local</span>/lib/python3.10/site-packages/libdash/ast.py (modified/added)</span><br><span class="line">/tmp/tmp.zHCkY9jtIT/upperdir/home/gliargovas/.<span class="built_in">local</span>/lib/python3.10/site-packages/libdash/_dash.py (modified/added)</span><br><span class="line">/tmp/tmp.zHCkY9jtIT/upperdir/home/gliargovas/.<span class="built_in">local</span>/lib/python3.10/site-packages/libdash/__init__.py (modified/added)</span><br><span class="line">/tmp/tmp.zHCkY9jtIT/upperdir/home/gliargovas/.<span class="built_in">local</span>/lib/python3.10/site-packages/libdash/__pycache__/printer.cpython-310.pyc (modified/added)</span><br><span class="line">/tmp/tmp.zHCkY9jtIT/upperdir/home/gliargovas/.<span class="built_in">local</span>/lib/python3.10/site-packages/libdash/__pycache__/ast.cpython-310.pyc (modified/added)</span><br><span class="line">&lt;snip&gt;</span><br><span class="line"></span><br><span class="line">Commit these changes? [y/N] y</span><br></pre></td></tr></table></figure>

<p>需要注意，这个命令并不是生成一个沙盒，它只是利用了linux系统的命名空间和overlayfs。因此不应该使用try去执行无法信任的命令。</p>
<h3 id="Google在设置里隐藏了一个秘密的浏览器"><a href="#Google在设置里隐藏了一个秘密的浏览器" class="headerlink" title="Google在设置里隐藏了一个秘密的浏览器"></a><a href="https://matan-h.com/google-has-a-secret-browser-hidden-inside-the-settings/">Google在设置里隐藏了一个秘密的浏览器</a></h3><p>作者在安卓系统里发现一个惊人的bug，存在于安卓的各种app中，以及系统设置和谷歌适配的app里，这个浏览器甚至可以绕过家长控制！具体复现步骤如下：<br>（由于手头并没有安卓机，暂时无法复现，而且考虑到这篇文章是国外博主发布的，大概率也是原生安卓系统的bug，国内的安卓机应该无法复现。）</p>
<ul>
<li>进入“设置”→“Google”（或任何允许选择账户的应用程序），点击“管理我的账户”。</li>
<li>然后进入“安全”选项卡。在其中，向下滚动直到找到“密码管理器”并点击。</li>
<li>点击右上角的“设置”图标。</li>
<li>向下滚动，直到出现“设置设备加密”。点击它，然后点击“了解有关设备加密的更多信息”。</li>
<li>现在你进入了浏览器。然后点击汉堡菜单（就是类似于“三”这样的按钮），然后点击“隐私政策”。</li>
<li>在顶部点击九个点，等待5秒钟（加载需要一些时间），然后点击“搜索”（如果你找不到搜索图标，你也可以向下滚动直到找到“Google”，然后点击它）。</li>
<li>从你的Google账户注销。</li>
<li>然后就得到了秘密浏览器，可以随意浏览任何网站。</li>
</ul>
<p>这个bug作者已经反馈给谷歌，并得到了回复，估计不久就会被修复。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/googlebug1.png"></p>
<h3 id="WinGPT：windows3-1上的AI助理"><a href="#WinGPT：windows3-1上的AI助理" class="headerlink" title="WinGPT：windows3.1上的AI助理"></a><a href="https://www.dialup.net/wingpt/">WinGPT：windows3.1上的AI助理</a></h3><p><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/wingpt1.png"><br>作者在古早的windows3.1上开发了一个程序，实现了类似chatgpt的问答功能。在开发过程中克服了相当多的困难：</p>
<ul>
<li>通过一系列努力在windows3.1上实现了tls1.3协议来调用chatgpt的接口，关于这部分的工作，看作者的另一篇<a href="https://www.dialup.net/wingpt/tls.html">文章</a>。</li>
<li>windows3.1上原生的UI界面非常难画，需要通过C语言代码一点点调试，而且也缺少一些如今通用的UI组件。</li>
<li>windows3.1没有状态栏，作者甚至询问了chatgpt如何解决，但是chatgpt并没有给出正确的答案。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/wingpt2.png"></li>
<li>用windows上的画图工具画了一个logo。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/wingpt3.png"></li>
<li>为了解决内存限制问题，作者将问答的文本数量进行了控制，同时也不去发送上下文内容，这意味着wingpt无法根据前文进行问答。</li>
</ul>
<p>作者放出了wingpt的<a href="https://www.dialup.net/wingpt/download/wingpt10.zip">下载地址</a>和<a href="https://www.dialup.net/wingpt/tls.html">源码</a>。（国外的hacker真是厚道）当然也有限制，必须运行在16位或者32位的windows3.1上，而且需要你有一个openai的api key。</p>
<h3 id="XML是未来"><a href="#XML是未来" class="headerlink" title="XML是未来"></a><a href="https://www.bitecode.dev/p/hype-cycles">XML是未来</a></h3><p>好吧，这是一个标题党。文章很棒，作者的主要目的是吐槽前端技术的爆炸、微服务过度等许多愚蠢的潮流。</p>
<p>作者初次接触xml的时候，便被告知xml将取代一切：html变为xhtml，验证用dtd，用xslt进行转换和展示，用soap进行通信。当然最后的结果大家都知道，xml并没有取代一切。</p>
<p>作者从中学到的教训是：没有银弹，所有工具都有其优缺点。而技术人员自认为自己是理性的，其实受到了炒作，营销和情绪的影响，甚至受其影响比起普通人更甚。</p>
<p>而xml只是许许多多潮流中的普通一员而已，作者吐槽了好几个技术潮流的起伏：</p>
<ul>
<li>MangoDB出现时，突然所有东西都要使用NoSQL。新手们不管三七二十一，就把数据一股脑放在了NoSQL中，然而NoSQL没有没有模式、没有一致性，没有完整性验证，这导致大量项目的失败。</li>
<li>Node出现使得Javascript风靡一时，你必须前后端使用同一种语言，让一切都是异步的。但是javascript本身并不完善，没有命名空间，混乱的作用域，弱类型等等。导致需要用各种额外框架，CoffeeScript，然后是Babel、Webpack、TypeScript、React + JSX等等。</li>
<li>单页面应用（Single Page Application）变得流行，但是你需要在flux、redux、alt、reflux、flummox、fluxible、fluxxor、marty.js、fynx、MacFly、DeLorean.js、fluxify、fluxury、exim、fluxtore、Redx、fluxx等之间做出选择。</li>
<li>客户端突然需要所有数据了，于是GraphQL诞生了。这导致了服务端渲染的兴起，也就是所谓的带有额外步骤的CGI。结果证明，这增加了巨大的复杂性，导致了大量失败的项目和金钱的浪费。</li>
<li>“一切都应该是微服务”的观点变得主流，每个小网站都应该有一个restful API的Docker容器，一个用于前端，一个用于数据库。然后不断增加层级。接着为了更好通信，显然需要一个消息队列，ZeroMQ、RabbitMQ……服务间要更好的交换格式，又有了Protobuf的gRPC。但是这只是让工作变得更加复杂，结果导致了云服务的诞生，你只需要托管然后购买这些服务就可以了，费用变成原来的10倍，但至少比你自己维护多10000倍的维护成本要好。</li>
<li>接着大数据开始流行，你要存储用户的所有行为，你的数据变得很庞大，即使不够大，你也得相信数据足够大。然后你需要某种形式的Dynamo数据湖，又或者是一个时间序列数据库等等。</li>
<li>程序运行变慢了？不是因为糟糕的程序设计，不是因为高并发的请求，而是因为语言！所以我们用GO和RUST来重写程序吧！</li>
</ul>
<p>作者最后总结，你需要新技术，云, 容器, nosql, go, rust 以及 js 构建的系统等。<strong>但是不需要每一项新技术</strong>，没有什么东西适用于所有情况（Nothing is ever needed for everything）。</p>
<p>这篇博文的评论区一位老哥也说的很棒，现在人们评价一个人技术好坏并不是看他解决的问题有多复杂，而是看他设计的系统有多复杂，这显然不是一个好趋势。<br><img src="/2023/06/26/2023/06/weekly-tech-blog-collection-202306026/hypecycle1.png"></p>
<h3 id="mycelite：一个SQLite扩展，它允许你将一个SQLite实例中的更改同步到另一个实例。"><a href="#mycelite：一个SQLite扩展，它允许你将一个SQLite实例中的更改同步到另一个实例。" class="headerlink" title="mycelite：一个SQLite扩展，它允许你将一个SQLite实例中的更改同步到另一个实例。"></a><a href="https://mycelial.com/docs/get-started/quick-start/">mycelite：一个SQLite扩展，它允许你将一个SQLite实例中的更改同步到另一个实例。</a></h3><ul>
<li>下载mycelite拓展<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/mycelial/mycelite/releases/latest/download/aarch64-apple-darwin.tgz --output aarch64-apple-darwin.tgz</span><br><span class="line">tar -xvzf aarch64-apple-darwin.tgz</span><br></pre></td></tr></table></figure></li>
<li>配置SQLite写实例<ul>
<li>启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlite3</span><br></pre></td></tr></table></figure></li>
<li>加载插件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.load ./libmycelite mycelite_writer</span><br></pre></td></tr></table></figure></li>
<li>打开一个数据库作为写实例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.open writer.db</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>配置Mycelite：第一次使用Mycelite，需要进行加载和配置<ul>
<li>加载配置文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.load ./libmycelite mycelite_config</span><br></pre></td></tr></table></figure></li>
<li>注册账号获取user name和secret <a href="https://hub.mycelial.com/signup">https://hub.mycelial.com/signup</a></li>
<li>执行插入语句，填入user name和secret<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mycelite_config <span class="keyword">values</span> </span><br><span class="line">  (<span class="string">&#x27;domain&#x27;</span>, <span class="string">&#x27;&lt;domain&gt;/&lt;db-name&gt;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;client_id&#x27;</span>, <span class="string">&#x27;&lt;your-hub-username&gt;&#x27;</span>),</span><br><span class="line">  (<span class="string">&#x27;secret&#x27;</span>, <span class="string">&#x27;&lt;secret-from-hub&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>配置SQLite读实例<ul>
<li>启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlite3</span><br></pre></td></tr></table></figure></li>
<li>加载插件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.load ./libmycelite mycelite_reader</span><br></pre></td></tr></table></figure></li>
<li>打开一个数据库作为读实例<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.open reader.db</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>验证同步<ul>
<li>在写实例执行插入语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(number <span class="type">integer</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(number) <span class="keyword">values</span> (<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li>
<li>在读实例就能看到数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">.tables</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230628</title>
    <url>/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h3 id="更快的机器，更慢的机器"><a href="#更快的机器，更慢的机器" class="headerlink" title="更快的机器，更慢的机器"></a><a href="https://jmmv.dev/2023/06/fast-machines-slow-machines.html">更快的机器，更慢的机器</a></h3><p>这篇文章的作者在推特上发布了两段<a href="https://twitter.com/jmmv/status/1671670996921896960">视频</a>，他用了一台装了windowsNT 3.51的旧电脑和一台装了windows11的新电脑，分别打开并关闭了windows的原生应用：命令行工具，资源管理器，记事本和画图。结果是，旧电脑没有任何延迟，新电脑却出现明显的加载延迟。这俩视频在推特上引起大量的关注和转发，大部分人都表示认同视频里的展示结果并发出了抱怨：为什么机器硬件越来越好，响应速度却越来越慢？</p>
<h4 id="第一版对比视频"><a href="#第一版对比视频" class="headerlink" title="第一版对比视频"></a>第一版对比视频</h4><p>作者的第一版视频对于两部机器的介绍是：</p>
<ul>
<li>一台搭载AMD K7-600处理器、128MB内存和5400转/分钟的硬盘的计算机，运行着Windows NT 3.51操作系统。这是一台1999-2000年的机器，而其操作系统比它还要旧约5年左右。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow1.png"></li>
<li>一台配备英特尔Core m3处理器、8GB内存和运行Windows 11的SSD的Surface Go 2。这是一台三年前发布的机器，原装搭载Windows 10，但官方支持升级至Windows 11。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow2.png"></li>
</ul>
<p>后来被人指出surface go的配置是错误的，因为作者错误的引用了Surface Laptop Go 2的配置。同时由于app已经预先打开过，所以都在内存中已经存在，这次的对比显然不够公平。</p>
<span id="more"></span>
<h4 id="第二版对比视频"><a href="#第二版对比视频" class="headerlink" title="第二版对比视频"></a>第二版对比视频</h4><p>作者重新发布了一版对比视频，这次的两台机器是：</p>
<ul>
<li>在K7-600机器上安装Windows 2000。这是一个来自1999年的操作系统，在同一年的硬件上运行。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow3.png"></li>
<li>在Mac Pro 2013上安装Windows 11，配备一颗3.5GHz的6核Xeon E5-1650v2处理器，32GB内存，双GPU以及一块最高可持续读取速度达到1GB/s的SSD。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow4.png"></li>
</ul>
<p>注意到第二台电脑是一台十年前的机器运行近几年的系统，但是作者认为这么一台十年前顶配的电脑在打开最简单的桌面应用时有延迟也是不可接受的。</p>
<p>两版视频揭示了同样的结果，更旧的电脑更旧的系统确实反应极快，打开这些桌面应用都是秒开，而更新的电脑和更新的系统却都同样有极其明显的延迟。</p>
<h4 id="计算机的进步"><a href="#计算机的进步" class="headerlink" title="计算机的进步"></a>计算机的进步</h4><p>从计算机产业角度来看，在21世纪的计算机发生了巨大的技术进步：</p>
<ul>
<li>更佳的图形和高性能显示器，更快的网络，实时视频剪辑等。</li>
<li>从难以忍受的缓慢I/O读取速度的HDD硬盘，CD和DVD进化到超高速的SSD，使得计算机速度，大型游戏运行，一次性打开超大图片的文件夹都变得顺畅无比。</li>
<li>硬件更易安装，无线设备普及，文本的国际化（unicode的进步）。</li>
</ul>
<h4 id="潜在的隐患"><a href="#潜在的隐患" class="headerlink" title="潜在的隐患"></a>潜在的隐患</h4><p>经历了以上巨大进步的计算机产业，为啥还会出现作者一开始展示的视频的情况呢？有人提出可能是更新的系统需要加载更多的像素，为了展示更好的图形。这显然不是一个很好的理由，作者也马上发了一个打脸视频，将新机器的像素调到最低，关闭4k，关闭特效等等图形效果，结果打开应用的延迟并没有任何改善。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow5.png"></p>
<p>GPU的出现减轻了CPU的负担，而出现在图形上的延迟通常是由于动画的有意暂停导致，为了兼容4k显示器在老旧机器上运行。但是作者发现的延迟并不属于这种情况。</p>
<h4 id="一些别的实例"><a href="#一些别的实例" class="headerlink" title="一些别的实例"></a>一些别的实例</h4><ul>
<li>windows上的记事本经历了无数代都还能响应快速，直到UWP的出现，情况开始急转直下。</li>
<li>windows的命令行工具随着越来越多的可视化特性，变得越来越慢，PowerShell的新窗口打开甚至要花上几秒钟。</li>
<li>macos也没有表现的更好，甚至M1芯片的电脑也在打开系统设置时明显慢于以前的机器。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/fastslow6.png"></li>
<li>linux看起来受到影响较小，原生的应用即使在10多年前的电脑上也能运行出色。然而一旦你开始安装第三方的程序，就会开始感受到变慢。</li>
<li>谷歌的程序也是，最早的原生谷歌应用非常快速，现在也开始表现不佳。</li>
</ul>
<h4 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h4><ul>
<li>会是软件臃肿的原因吗？根据帕累托法则，80%的用户只用到了20%的软件功能，但是根据剩下20%的用户行为却又各自不同。</li>
<li>为了解决软件臃肿的问题，我们引入了框架和抽象。但是看看RUST就知道，这并不是问题。</li>
<li>大型程序和软件的开发需要优先考虑的是节省开发者的时间，这意味着更高的优先级是花大量的时间调试程序而非优化响应时间。</li>
<li>多平台的开发导致开发者想要节省时间，于是考虑跨平台框架，例如Electron。</li>
<li>这种跨平台的框架显然导致了很多程序的延迟，比如1password和spotify。</li>
<li>另一个可能的原因是解释性语言的盛行，例如java和.NET，这些语言在优化长期运行的进程时表现优秀，但是并不会怎么去优先考虑快速启动。</li>
</ul>
<h4 id="逐渐消失的一次性改进"><a href="#逐渐消失的一次性改进" class="headerlink" title="逐渐消失的一次性改进"></a>逐渐消失的一次性改进</h4><p>这里说的是从HDD到SSD的巨大改进，这个改进直接将电脑的表现提升到了另一个层次。但是随着时间发展和软件开发的日渐臃肿，这个一次性的改进优势逐渐被蚕食。现在你已经无法感受到SSD刚刚出现那会儿的极速体验了。而另一方面，现在操作系统几乎已经没有办法运行在HDD硬盘上了，当代的操作系统已经默认了你使用SSD，以此为基础，软件程序才能获得基本的体验。</p>
<p>同样的事情可能也会发生在苹果芯片上，缺乏节制的软件设计，完全不去节约系统资源的开发模式，也会逐渐蚕食掉苹果芯片的硬件改进，多年以后，软件速度也会渐渐慢下来。</p>
<blockquote>
<p>计算机架构师能否通过其他革命性的技术转变来拯救我们呢？我不希望依赖这一点。不是因为这些转变可能不存在，而是因为我们不应该需要它们。</p>
</blockquote>
<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="密码游戏"><a href="#密码游戏" class="headerlink" title="密码游戏"></a><a href="https://neal.fun/password-game/">密码游戏</a></h3><p>颇为有意思的一个网页游戏，游戏界面很简单，只要输入符合规则的密码就行，一开始的规则非常正常，到后面的脑洞就越来越大。</p>
<ul>
<li>一开始还是很正常的，至少5个字符，包含特殊符号和大写字母等常用的密码验证规则。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/passwordgame1.png"></li>
<li>渐渐画风开始变得奇怪，要包含赞助商的名字。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/passwordgame2.png"></li>
<li>渐渐离谱，要包含谷歌街景里这个国家的名字。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/passwordgame3.png"></li>
<li>开始脑筋急转弯，把这个蛋安全的放到你的密码里。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/passwordgame4.png"></li>
</ul>
<p>这个游戏更适合不懂得前端技术的人来玩，因为这些验证规则完全在前端实现，技术人员通过浏览器的开发者工具就可以轻松实现作弊。例如上面的谷歌街景国家问题，直接可以从js里面找到答案是norway。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/passwordgame5.png"></p>
<p>当然，对于前端人员来说，这个网页也颇有学习的价值，这些五花八门的验证规则细想起来也不是那么简单就能通过js来实现的，看这个网站的js源码非常具有借鉴价值。</p>
<h3 id="进阶MacOS命令行工具"><a href="#进阶MacOS命令行工具" class="headerlink" title="进阶MacOS命令行工具"></a><a href="https://saurabhs.org/advanced-macos-commands">进阶MacOS命令行工具</a></h3><p>我们知道在linux上的命令绝大部分都能在macos上使用，这里介绍几个在macos上的专属命令，不用去找复杂的第三方工具，可以实现很多常用的功能。</p>
<ul>
<li><code>caffeinate</code> 设定mac睡眠行为</li>
<li><code>pbcopy, pbpaste</code> 与系统剪贴板互动</li>
<li><code>networkQuality</code> 测算网速</li>
<li><code>sips</code> 图片操作</li>
<li><code>open</code> 打开文件或者应用</li>
<li><code>textutil</code> 文档转换器（主要用于html和doc文档的互转）</li>
<li><code>mdfind, mdls</code> 聚光灯搜索</li>
<li><code>screencapture</code> 屏幕截图</li>
<li><code>taskpolicy</code> 控制进程调度</li>
<li><code>say</code> 文本阅读</li>
<li><code>pmset</code> 配置电源管理</li>
<li><code>networksetup</code> 配置网络设定</li>
<li><code>qlmanage</code> 管理快速查看</li>
<li><code>softwareupdate</code> 管理系统升级</li>
<li><code>system_profiler</code> 查看系统信息</li>
</ul>
<h3 id="用Linux的Namespaces，cgroups和chroot搭建你自己docker"><a href="#用Linux的Namespaces，cgroups和chroot搭建你自己docker" class="headerlink" title="用Linux的Namespaces，cgroups和chroot搭建你自己docker"></a><a href="https://akashrajpurohit.com/blog/build-your-own-docker-with-linux-namespaces-cgroups-and-chroot-handson-guide/">用Linux的Namespaces，cgroups和chroot搭建你自己docker</a></h3><p>docker是总所周知的容器平台，这篇文章不是旨在取代docker，而是通过这么一篇介绍让读者明白Docker中容器的核心机制。</p>
<p>首先介绍linux的这几个概念：</p>
<ul>
<li><a href="https://akashrajpurohit.com/blog/linux-namespaces-isolating-your-system-for-enhanced-security-and-performance/">Namespaces</a>：命名空间（namespaces）是一种内核特性，用于将系统资源隔离和虚拟化，使得每个进程拥有独立的视图，以便在不同的命名空间中运行。</li>
<li><a href="https://akashrajpurohit.com/blog/linux-control-groups-finetuning-resource-allocation-for-optimal-system-performance/">cgroups</a>：控制组（cgroups）是一种资源管理机制，用于对进程和进程组进行资源限制和分配。</li>
<li><a href="https://akashrajpurohit.com/blog/how-to-create-a-restricted-environment-with-the-linux-chroot-command/">chroot</a>：chroot是一种操作系统级别的功能，用于将进程的根目录更改为指定的目录，创建一个被隔离的运行环境。</li>
</ul>
<p>搭建“docker”</p>
<ul>
<li>使用<code>unshare</code>命令指定不同的命名空间。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unshare --uts --pid --net --mount --ipc --fork</span><br></pre></td></tr></table></figure></li>
<li>执行如下命令创建一个新的cgroup，并分配cpu的配额限制。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建新的cgroup</span></span><br><span class="line">mkdir /sys/fs/cgroup/cpu/container1</span><br><span class="line"><span class="comment">## 分配cpu限额</span></span><br><span class="line"><span class="built_in">echo</span> 100000 &gt; /sys/fs/cgroup/cpu/container1/cpu.cfs_quota_us</span><br><span class="line"><span class="comment">## 写入0用于移除之前曾分配过的进程</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/fs/cgroup/cpu/container1/tasks</span><br><span class="line"><span class="comment">## 写入$$ 确保当前进程的shell后续进程会成为croup中的子进程，并收到cpu限额的限制</span></span><br><span class="line"><span class="built_in">echo</span> $$ &gt; /sys/fs/cgroup/cpu/container1/tasks</span><br></pre></td></tr></table></figure></li>
<li>使用<code>debootstrap</code>命令创建容器的根文件目录。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">debootstrap focal ./ubuntu-rootfs http://archive.ubuntu.com/ubuntu/</span><br></pre></td></tr></table></figure></li>
<li>挂载系统目录和chroot容器<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 挂载proc文件目录，proc文件提供关于进程和系统资源的信息。</span></span><br><span class="line">mount -t proc none ./ubuntu-rootfs/proc</span><br><span class="line"><span class="comment">## 挂载sysfs文件目录，sysfs文件系统以分层格式提供有关设备、驱动程序和其他与内核相关的信息。</span></span><br><span class="line">mount -t sysfs none ./ubuntu-rootfs/sys</span><br><span class="line"><span class="comment">## 绑定dev目录，dev目录目录包含表示系统上物理和虚拟设备的设备文件。</span></span><br><span class="line">mount -o <span class="built_in">bind</span> /dev ./ubuntu-rootfs/dev</span><br><span class="line"><span class="comment">## </span></span><br><span class="line">chroot ./ubuntu-rootfs /bin/bash</span><br></pre></td></tr></table></figure></li>
<li>完成上面几步后，就搭建了自己的容器环境，现在可以在容器内运行程序<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(container) $ apt update</span><br><span class="line">(container) $ apt install nginx</span><br><span class="line">(container) $ service nginx start</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="OPNsense：开源的安全平台"><a href="#OPNsense：开源的安全平台" class="headerlink" title="OPNsense：开源的安全平台"></a><a href="https://opnsense.org/">OPNsense：开源的安全平台</a></h2><p><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/opnsense1.png"><br>根据官网介绍，涉及安全方面的内容，从虚拟私人网络到入侵检测，这是一款一流的免费开源项目。有下列功能（翻译自chatgpt）：</p>
<ul>
<li>状态防火墙：具有对IPv4和IPv6的支持以及对被阻止或通过的流量的实时查看。</li>
<li>多WAN：具备多WAN功能，包括负载均衡和故障转移支持。</li>
<li>虚拟私人网络：集成支持IPsec（包括基于路由的IPsec）、OpenVPN，以及可插拔的支持Tinc（全网VPN）和WireGuard。</li>
<li>硬件故障转移：当您不能承受停机时间时，请使用我们的自动无缝硬件故障转移功能，利用常见地址冗余协议（CARP）进行状态同步，以实现最高可能的可用性。</li>
<li>软件定义广域网（SD-WAN）：为了轻松进行设置、配置和监控，可以使用ZeroTier插件在几分钟内设置您的软件定义广域网（SD-WAN）。</li>
<li>入侵检测和防御：利用Suricata和Proofpoint的新兴威胁开放规则，采用最先进的内联入侵预防技术，摆脱木马和CNC机器人的困扰。可选择集成ET PRO（商业订阅）或ET PRO Telemetry（免费注册）。</li>
<li>两步验证（2FA）：系统中始终支持两步验证（2FA），包括用户界面和VPN等服务。</li>
<li>路由协议：使用Free Range Router项目，提供可插拔的OSPF和BGP支持。</li>
<li>网络过滤：完全集成的Web代理，具有访问控制和支持外部黑名单，以过滤不需要的流量。其他选项包括防火墙别名和DNS黑名单。轻松屏蔽广告！</li>
<li>直观的用户界面：在任何开源防火墙中都可以找到的最直观、完全响应的用户界面，具有集成搜索选项。</li>
<li>多语言：用户可选择的语言支持，包括英语、捷克语、中文、法语、德语、意大利语、日语、葡萄牙语、俄语和西班牙语。</li>
<li>在线文档：完全免费并支持搜索的在线文档。</li>
</ul>
<h2 id="Mofi：免费且无需下载的音乐编辑网站"><a href="#Mofi：免费且无需下载的音乐编辑网站" class="headerlink" title="Mofi：免费且无需下载的音乐编辑网站"></a><a href="https://mofi.loud.red/">Mofi：免费且无需下载的音乐编辑网站</a></h2><ul>
<li>将音乐文件拖拽到该网站，或者直接粘贴音乐的网址，就可以开始进行编辑。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/mofi1.png"></li>
<li>进入到编辑界面，上面部分是整首歌的音轨，下面部分是根据你的编辑生成的cut，可以进行导出。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/mofi2.png"></li>
<li>选择需要编辑的部分，并选择Avoid this，Prefer this，Repeat this进行编辑。网站会根据你的选择生成匹配的cut。<br><img src="/2023/06/28/2023/06/weekly-tech-blog-collection-202306028/mofi3.png"></li>
</ul>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230629</title>
    <url>/2023/06/29/2023/06/daily-tech-blog-collection-202306029/</url>
    <content><![CDATA[<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="background-removal-js：免费开源的背景移除脚本"><a href="#background-removal-js：免费开源的背景移除脚本" class="headerlink" title="background-removal-js：免费开源的背景移除脚本"></a><a href="https://github.com/imgly/background-removal-js">background-removal-js：免费开源的背景移除脚本</a></h3><p>通过该脚本可以在浏览器环境中直接移除图片的背景，无需担心多余的性能开销或者隐私顾虑。</p>
<p>其主要的功能特点有：</p>
<ul>
<li>浏览器上的背景移除：消除了额外的服务器成本。通过利用本地设备的计算能力，用户可以享受快速高效的背景去除过程。</li>
<li>数据保护：完全运行于浏览器端。无需任何数据传输到别的服务器，因此数据是绝对安全的。</li>
<li>与<a href="https://img.ly/creative-sdk?utm_source=github&utm_medium=project&utm_campaign=bg-removal">IMG.LY的CE.SDK</a>（作者的另一个项目） 实现了无缝集成，使开发人员能够轻松地将强大的浏览器内图像抠图和背景去除功能整合到他们的项目中。<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/backgroundremove1.png"></li>
</ul>
<p>本地使用安装步骤如下</p>
<span id="more"></span>
<ul>
<li>NPM安装<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install @imgly/background-removal</span><br></pre></td></tr></table></figure></li>
<li>代码引用：注意首次调用需要下载额外模块，因此会花费比较多时间。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imglyRemoveBackground <span class="keyword">from</span> <span class="string">&quot;@imgly/background-removal&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> image_src: ImageData | <span class="built_in">ArrayBuffer</span> | <span class="built_in">Uint8Array</span> | Blob | URL | string = ...;</span><br><span class="line"></span><br><span class="line">imglyRemoveBackground(image_src).then(<span class="function">(<span class="params">blob: Blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// The result is a blob encoded as PNG. It can be converted to an URL to be used as HTMLImage.src</span></span><br><span class="line">  <span class="keyword">const</span> url = URL.createObjectURL(blob);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>进阶设置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type Config = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: string; <span class="comment">// The public path used for model and wasm files</span></span><br><span class="line">  debug: bool; <span class="comment">// enable or disable useful console.log outputs</span></span><br><span class="line">  proxyToWorker: bool; <span class="comment">// Wether or wether not to proxy the calculations to a webworker. (Default true)</span></span><br><span class="line">  model: <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;medium&#x27;</span>; <span class="comment">// The model to use. (Default &quot;medium&quot;)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="fly-io：靠近用户运行的全栈应用程序和数据库"><a href="#fly-io：靠近用户运行的全栈应用程序和数据库" class="headerlink" title="fly.io：靠近用户运行的全栈应用程序和数据库"></a><a href="https://fly.io/">fly.io：靠近用户运行的全栈应用程序和数据库</a></h3><p>fly.io是一个目前流行的云平台，专为运行全栈应用程序和数据库而设计。它的主要目标是使应用程序更靠近用户，以提供更快的响应时间和更好的用户体验，同时简化了开发人员的工作流程。</p>
<ul>
<li>安装flyctl<ul>
<li>macos：运行<code>brew install flyctl</code>或者<code>curl -L https://fly.io/install.sh | sh</code></li>
<li>linux：运行<code>curl -L https://fly.io/install.sh | sh</code></li>
<li>windows：powershell运行<code>pwsh -Command &quot;iwr https://fly.io/install.ps1 -useb | iex&quot;</code></li>
</ul>
</li>
<li>注册，输入以下命令跳转到注册页面，或者直接到注册页面进行注册。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fly auth signup</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>fly auth login</code> 登陆fly.io的账户</li>
<li>部署hellofly项目<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 直接拉取docker项目并完成部署</span></span><br><span class="line">fly launch --image flyio/hellofly:latest</span><br></pre></td></tr></table></figure></li>
<li>部署过程中要求选择地区，就近选择<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Choose a region <span class="keyword">for</span> deployment: Chicago, Illinois (US) (ord)</span><br></pre></td></tr></table></figure></li>
<li>询问是否需要Postgres或者Redis，按需选择</li>
<li>最后询问是否需要部署，部署完成后会在本地生成一个fly.toml的配置文件<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">app = <span class="string">&quot;hellofly&quot;</span></span><br><span class="line">primary_region = <span class="string">&quot;ord&quot;</span></span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">  image = <span class="string">&quot;flyio/hellofly:latest&quot;</span></span><br><span class="line"></span><br><span class="line">[http_service]</span><br><span class="line">  internal_port = 8080</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>使用<code>fly deploy</code>部署完成后，可通过<code>fly status</code>命令检查项目状态</li>
<li>使用<code>fly open /&lt;your-name&gt;</code>命令可以在fly.io的网站访问到刚刚部署的项目<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/flyio1.webp"></li>
</ul>
<h3 id="TypeID：一个受到Stripe-ID启发的类型安全、可排序的全局唯一标识符（ID）"><a href="#TypeID：一个受到Stripe-ID启发的类型安全、可排序的全局唯一标识符（ID）" class="headerlink" title="TypeID：一个受到Stripe ID启发的类型安全、可排序的全局唯一标识符（ID）"></a><a href="https://github.com/jetpack-io/typeid">TypeID：一个受到Stripe ID启发的类型安全、可排序的全局唯一标识符（ID）</a></h3><p>TypeIDs是UUIDv7的一种现代、类型安全的扩展。它在设计上受到Stripe API中前缀类似用法的启发。包含三个部分：</p>
<ul>
<li>类型前缀（由小写字母组成的最多63位的字符串）</li>
<li>一个下划线</li>
<li>一个128位的UUIDv7，以26个字符的base32字符串编码（根据Crockford的小写字母表）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user_2x4y6z8a0b1c2d3e4f5g6h7j8k</span><br><span class="line">└──┘ └────────────────────────┘</span><br><span class="line">type    uuid suffix (base32)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>TypeID有以下特性：</p>
<ul>
<li>类型安全：您不会意外地在期望使用帖子ID的地方使用用户ID。在调试过程中，通过类型前缀，您可以立即了解TypeID引用的实体类型。</li>
<li>与UUID兼容：TypeID是UUID的超集。它们基于即将发布的UUIDv7标准。如果您解码TypeID并移除类型信息，您将得到一个有效的UUIDv7。</li>
<li>可K排序：TypeID是可K排序的，可以用作数据库中的主键，同时确保良好的局部性。与完全随机的全局ID（例如UUIDv4）相比，后者通常在数据库局部性方面表现不佳。</li>
<li>精心编码：基于base32的编码是URL安全的、不区分大小写的、避免了歧义字符，可以通过双击选择复制粘贴，并且与传统的十六进制编码（UUID使用的编码方式）相比，它是一种更紧凑的编码（26个字符对比36个字符）</li>
</ul>
<p>命令列表</p>
<ul>
<li>安装命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.jetpack.io/typeid | bash</span><br></pre></td></tr></table></figure></li>
<li>创建新的TypeID<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ typeid new prefix</span><br><span class="line">prefix_01h2xcejqtf2nbrexx3vqjhp41</span><br></pre></td></tr></table></figure></li>
<li>将TypeID解码位UUID<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ typeid decode prefix_01h2xcejqtf2nbrexx3vqjhp41</span><br><span class="line"><span class="built_in">type</span>: prefix</span><br><span class="line">uuid: 0188bac7-4afa-78aa-bc3b-bd1eef28d881</span><br></pre></td></tr></table></figure></li>
<li>将UUID编码为TypeID<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ typeid encode prefix 0188bac7-4afa-78aa-bc3b-bd1eef28d881</span><br><span class="line">prefix_01h2xcejqtf2nbrexx3vqjhp41</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="梵高艺术展"><a href="#梵高艺术展" class="headerlink" title="梵高艺术展"></a><a href="https://www.vangoghmuseum.nl/en">梵高艺术展</a></h3><p><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh1.png"><br>这个网站介绍了关于梵高的生平和艺术作品，并还有出售梵高艺术展的门票。</p>
<p>正在举办的艺术展<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh2.png"><br>门票也不算贵，成人20欧元，未成年人免费，相比起国内，算是相当厚道。<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh3.png"></p>
<p>网站上展示梵高的1515副画作，并提供下载。<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh4.png"><br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh5.png"></p>
<p>以及梵高的故事。<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/vangogh6.png"></p>
<h3 id="未来的CSS：状态容器查询"><a href="#未来的CSS：状态容器查询" class="headerlink" title="未来的CSS：状态容器查询"></a><a href="https://ishadeed.com/article/css-state-queries/">未来的CSS：状态容器查询</a></h3><p>状态容器查询。它是一种可以根据元素的状态和属性来应用样式的能力。通过状态容器查询，开发者可以根据元素在不同状态下的宽度、高度、可见性等属性，动态地调整其样式。这项功能将提供更强大的响应式设计和样式控制的能力，使网页设计更加灵活和适应不同设备和交互情境。</p>
<p>例如这样子进行设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card-wrapper</span> &#123;</span><br><span class="line">  container-type: inline-size;</span><br><span class="line">  container-name: card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@container</span> card (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述语法，当容器宽度到达400px时，就会触发<code>.card &#123;display: flex;align-items: center;&#125;</code>的样式。</p>
<p>下面的图片可以更好的说明该语法的功能。<br><img src="/2023/06/29/2023/06/daily-tech-blog-collection-202306029/css1.png"></p>
<p>更多的语法说明详见作者的另一篇文章(<a href="https://ishadeed.com/article/css-container-style-queries/)%E3%80%82">https://ishadeed.com/article/css-container-style-queries/)。</a></p>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230630</title>
    <url>/2023/06/30/2023/06/daily-tech-blog-collection-202306030/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h3 id="书信圈-letter-circle-：什么样的社交媒体让你着迷？"><a href="#书信圈-letter-circle-：什么样的社交媒体让你着迷？" class="headerlink" title="书信圈(letter circle)：什么样的社交媒体让你着迷？"></a><a href="https://lostgarden.home.blog/2023/02/26/the-letter-circle/">书信圈(letter circle)：什么样的社交媒体让你着迷？</a></h3><p><strong>这是一篇关于专业社交圈的产品设计文章。</strong></p>
<p>很长一段时间以来，在地理分散的世界中，人与人交流的方式都是书信往来。直至博客出现时，依然会以长篇形式表达自己的独特观点，同行们用关心和理解进行回应，就会得到治愈和启发。</p>
<p>如今取而代之的是社交媒体的腐蚀性洪水，以牺牲思考为代价，换取广告友好的垃圾信息。甚至在历史上重要的学术期刊界也演变成了一个闭塞噪音的内耗官僚机构。当前的系统存在着严重不协调的激励机制，无法鼓励有趣的写作。</p>
<p>作者希望利用他在游戏中探索的社交系统设计的一些经验，创建计划性的社交架构，促进长期存在的社区。</p>
<h4 id="书信圈-letter-circle-的基本结构"><a href="#书信圈-letter-circle-的基本结构" class="headerlink" title="书信圈(letter circle)的基本结构"></a>书信圈(letter circle)的基本结构</h4><ul>
<li>有人在感兴趣的主题领域创建一个群组。</li>
<li>他们邀请最多50位拥有相关专业知识的人加入该群组。</li>
<li>每个成员每年必须发布至少一封关于该主题的长篇信函，并通过电子邮件发送给所有群组成员。也可能存在一个网络界面。</li>
<li>他们还必须至少回复其他人的两封信函。</li>
<li>如果成员未满足要求，他们将在年底自动被踢出群组。</li>
<li>招募阶段，任何成员都可以推荐新成员，然后新成员将通过自动邀请过程加入。<span id="more"></span>
<h4 id="什么是书信"><a href="#什么是书信" class="headerlink" title="什么是书信"></a>什么是书信</h4></li>
</ul>
<h5 id="书信的可能构成"><a href="#书信的可能构成" class="headerlink" title="书信的可能构成"></a>书信的可能构成</h5><ul>
<li>引发对话的观察点。</li>
<li>你正在尝试解决的问题，可能对其他人也感兴趣。</li>
<li>你偶然发现的在特定情境中有帮助的认知工具、模型或视角。</li>
<li>对你今年生活事件的描述。可以是与群组主题相关的，也可以是你个人生活的。分享可以建立亲密感和信任。</li>
<li>对先前一封信的深思熟虑的回应。</li>
</ul>
<p>总之，写信的整个目的在于它包含着深思熟虑的文字。每个写信人都应该努力创造出对圈子中其他成员有意义并引发有用和有趣回应的内容。</p>
<p>相应的，书信不应该是：</p>
<ul>
<li>这不是一篇完整的研究或白皮书。大多数人没有时间写或阅读费力排版的文章。在页面限制内写作将有助于作者更清晰地传达信息，也确保读者不会在第23页就放弃阅读。</li>
<li>这也不是一条简短的推文。复杂的思想需要空间来发展和展示它们的细微之处。</li>
<li>这也不是发给地球上每个人的大篇幅信息。你知道受众是谁！它是你在信函圈中的同行们。信函是关于合作交流，而不是为了追求声望。</li>
</ul>
<h5 id="书信写作的动机"><a href="#书信写作的动机" class="headerlink" title="书信写作的动机"></a>书信写作的动机</h5><p>很多人认为除非有报酬，否则没有任何事情值得去做。我认为人们会写信给他们的圈子，是因为以下内在动机。</p>
<ul>
<li>通过写作，拉伸思维并组织思想的感觉很好。</li>
<li>与尊重并回应你的思想的同行们建立联系是美妙的。</li>
<li>当我们分享内心最深处的思想时，我们与彼此建立了联系。</li>
</ul>
<h5 id="什么是回应"><a href="#什么是回应" class="headerlink" title="什么是回应"></a>什么是回应</h5><p>回应是对信函中细节进行较短的讨论。理想情况下，它是尊重和合作性质的。它尽力保持与主题的相关性。</p>
<ul>
<li>对信函主题的另一种观点。</li>
<li>支持或提供细微差别的例子。</li>
<li>延伸信函主题的变奏。</li>
</ul>
<p>相对的，回应不应该是：</p>
<ul>
<li>不是简短而干脆的评论。“太棒了！”“喜欢！”“错了！”这些都不是有用的回应，因为它们对对话没有任何贡献。</li>
<li>不能离题。如果你想写一些关于不同话题的内容，请将它们分开成一封新的信函。</li>
</ul>
<h4 id="新成员的引导"><a href="#新成员的引导" class="headerlink" title="新成员的引导"></a>新成员的引导</h4><h5 id="邀请"><a href="#邀请" class="headerlink" title="邀请"></a>邀请</h5><p>需要一个网络界面，只要活跃成员数量不超过50人，你就可以邀请别人加入该群组。</p>
<ul>
<li>输入新成员的电子邮件地址。</li>
<li>发送一个模板化的邀请。每个群组可以根据自己的需要自定义邀请文本。</li>
<li>点击发送。受邀者将收到一封包含邀请文本和标准指示的电子邮件，说明他们接下来需要做什么。</li>
</ul>
<h5 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h5><p>新成员需在三个月窗口期内在群组的主题下发表一篇书信。如果没能完成该任务，邀请就会被撤销。</p>
<p>为了帮助他们完成这一步骤，在邀请的邮件里面应该包含如下的引导内容：</p>
<ul>
<li>对群组的焦点和更高价值的描述。这有助于为群组创建一个共同的更高目标。</li>
<li>关于格式、长度和话题的建议。</li>
<li>群组认为高质量工作的过去信函的示例。</li>
<li>参与和被移出群组的规则。这是前期的社交契约，需要以明确清晰的方式早期建立起来。</li>
</ul>
<p>发表第一篇书信非常重要，即使在之后不再发表，这第一篇书信也是他们为群组所增加的价值。</p>
<h5 id="谁可以邀请成员？"><a href="#谁可以邀请成员？" class="headerlink" title="谁可以邀请成员？"></a>谁可以邀请成员？</h5><p>这里有几个规则，可以根据群组的需要进行设置。</p>
<ul>
<li>任何人都可以邀请。</li>
<li>群组负责人可以邀请。</li>
<li>群组管理员可以邀请。</li>
<li>投票：任何人都可以提交被邀请者的提名，但群组整体必须对最终被邀请的人进行投票。</li>
</ul>
<p>小规模的群组可以使用第一条规则，稍大点的群组应该要更严格点，使用第二或者第三条规则，对于想要长期发展的群组来说，投票可能是最好的选择。</p>
<h5 id="为什么限制50个人？"><a href="#为什么限制50个人？" class="headerlink" title="为什么限制50个人？"></a>为什么限制50个人？</h5><p>超大规模的社交网络是另一个谎言。在功能性的、自我管理的群组中，50人似乎是一个界限，能够建立有意义的关系并进行有益的交流。</p>
<p>超过这个数量，人们往往会保持沉默。他们不知道群组中有哪些人，因此会变得谨慎起来，停止分享。或者群组中的喧嚣声太多，人们开始将其当作纯粹的噪音而忽视。</p>
<p>较小的群组也可以运作，但它们面临着互动不足以避免停滞状态的风险。也许没有人及时回应。也许你会忘记群组的存在。</p>
<h4 id="成员要求"><a href="#成员要求" class="headerlink" title="成员要求"></a>成员要求</h4><p>基本要求：</p>
<ul>
<li>一年发布一篇高质量的书信。对于一个30-50人的群组，就可以基本保证在一周左右读到一篇高质量的书信，这是对于某个特定主题可以接受的阅读量。同时也不会对成员造成太大的写作压力。</li>
<li>一年至少发表两次对于书信的高质量回应。保证了书信有获得回应，可以获得良性的循环。</li>
</ul>
<h5 id="什么是活跃成员？"><a href="#什么是活跃成员？" class="headerlink" title="什么是活跃成员？"></a>什么是活跃成员？</h5><p>如果一个成员满足两个要求，就被确定为活跃成员。</p>
<p>这个概念背后有一个重要的设计目标。事实证明，对于一个社交系统来说，维持所需的活跃用户密度是最重要的事情之一。你需要一定数量的人进行社交行为并相互交流。</p>
<p>不幸的是，大多数社交媒体面向用户的指标都是虚荣指标，而不是反映社交引擎实际运行的功能指标。如果你的粉丝没有活跃的话，你有多少个关注者并不重要。如果你的好友列表上的朋友们很久没登陆了，你有多少个好友也不重要。</p>
<h5 id="什么是高质量？"><a href="#什么是高质量？" class="headerlink" title="什么是高质量？"></a>什么是高质量？</h5><p>质量由群组决定。这可能是一个持续的讨论，并且不太可能有一个正确的答案。质量管理的两个隐含工具是：</p>
<ul>
<li>在发布指南页面中定义群组对质量的期望。随着群组逐渐了解什么是质量对他们来说，他们可以更新这段文字。</li>
<li>手动将人踢出群组。群组可能希望剔除那些违反了某些群体规范或者表现不符合期望的成员。有一个管理员选项可以将某人从群组中移除。</li>
</ul>
<h4 id="自动化的群组管理"><a href="#自动化的群组管理" class="headerlink" title="自动化的群组管理"></a>自动化的群组管理</h4><p>大多数自然形成的群组，如邮件列表或群博客，都是由领导者投入的精力和关注来维持活力的。但是领导力是稀缺且不可靠的。一个解决方案是自动化群组运行的基本方面。</p>
<h5 id="自动化的邮件提醒"><a href="#自动化的邮件提醒" class="headerlink" title="自动化的邮件提醒"></a>自动化的邮件提醒</h5><p>一年若干次邮件提醒：</p>
<ul>
<li>鼓励尚未发布过书信的人进行发布，并提醒他们如果不这样做，将被移出群组。</li>
<li>鼓励尚未对现有书信做出回应的人进行回复。</li>
<li>已经发布过书信的人会得到一份庆祝性的现有书信列表。通常人们可能会错过一两封邮件，因此展示可用的内容是很好的做法。</li>
</ul>
<h5 id="自动化的踢人"><a href="#自动化的踢人" class="headerlink" title="自动化的踢人"></a>自动化的踢人</h5><p>通过自动化的进程减少踢人后引发的不良情绪：</p>
<ul>
<li>一个会员在被移出团体之前，会收到一封最后的提醒邮件，鼓励他们履行他们的要求。</li>
<li>如果他们仍然不提交一封书信，将会发送一封非常温和的邮件，说明他们被移出团体是为了给更积极的成员腾出位置。</li>
<li>被移出的成员仍然可以在以后被重新邀请。当然，他们需要提交一封书信来获得接受。</li>
</ul>
<h5 id="手动招募"><a href="#手动招募" class="headerlink" title="手动招募"></a>手动招募</h5><p>如果年底依然没有达到50人的规模，那一封自动话的提醒将会发送给所有成员，启用手动招募流程，包含如下内容：</p>
<ul>
<li>很遗憾，我们无法自动化这一步骤（招募到新成员这一步骤）。</li>
<li>然而，我们可以在我们的入职材料中确立这一点，将其作为一项神圣的职责。每个新成员都应该反复被告知，如果不邀请人员，团体将会消亡。他们负责提供电子邮件。</li>
<li>如果没有发送足够的邀请，系统将会向所有成员发送一系列逐渐升级的自动提醒。</li>
</ul>
<h4 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h4><h5 id="公开发布"><a href="#公开发布" class="headerlink" title="公开发布"></a>公开发布</h5><p>书信圈的设计目的是50人左右的圈子里的内部分享，如果某些群组希望能够公开发表书信并获取更多的评论和关注，以下是推荐做法：</p>
<ul>
<li>发布到现有的博客。有很多优秀的博客存在，所以没有必要重新发明轮子。这为人们提供了很大的灵活性，如果他们想为他们的团体拥有一个特殊的域名。这需要维护与第三方的接口或插件。</li>
<li>该服务也可以是一个博客：该服务可以具有类似博客的功能，将书信转化为网页。这样做的好处是自包含性。但还需要编写博客软件。</li>
</ul>
<h5 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h5><p>书信圈的运维显然需要一个服务器和一些费用，可以采取下面的办法：</p>
<ul>
<li>志愿者：如果该服务规模较小，一个志愿者可以资助大部分全球服务的托管成本。我猜测，即使每年花费大约1000美元左右，你也可以为许多团体提供服务。但是，要让某人投入编程时间始终更具问题。</li>
<li>众筹：成功团体的成员可以捐赠年费来维持团体或服务的活动。</li>
<li>自托管的开源：该服务可以以开源形式发布。</li>
</ul>
<h4 id="可预见的情况"><a href="#可预见的情况" class="headerlink" title="可预见的情况"></a>可预见的情况</h4><ul>
<li>最初的邀请会有一阵子的爆发，然而，这只会导致寥寥几封书信。如今，要让人们承诺参与任何事情都很困难。一个新的圈子需要发送许多几十甚至几百封邀请才能一开始就获得足够的参与者。</li>
<li>坚定的加入者来自高度信任的联系：高度信任、高度尊重的朋友之间的邀请最有可能得到回应。但人们只能利用有限的这些关系来开始一个圈子。</li>
<li>缓慢的起步：大多数圈子一开始会有2到5个活跃成员。如果他们没有邀请更多人，活动最终会逐渐消退，圈子也会消亡。</li>
<li>2到5年后的社区：如果一个圈子能持续几年，就有机会建立成员之间的纽带。此时，圈子更有可能生存下来。在这个阶段，你可能想要开始面对面的聚会，将这些纽带转化为终身的友谊。</li>
</ul>
<p>观察圈子随时间的变化，并在关键阶段创建支持机制。</p>
<ul>
<li>也许在早期阶段需要更灵活的要求，并增加更多的邀请提醒。</li>
<li>也许需要额外的工作来鼓励成员的回应，确保友谊开始发展。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇产品设计的文章也可归为文章定义的“书信”，这是一个作者设计的社交媒体的概念，类似于推特里的“推文”，聚焦于专业圈子领域的交流，我认为里面提出的各种想法都非常有价值，值得一看。</p>
<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="computerraria：在游戏《Terraria》中制作的全面符合-RISC-V-架构的计算机"><a href="#computerraria：在游戏《Terraria》中制作的全面符合-RISC-V-架构的计算机" class="headerlink" title="computerraria：在游戏《Terraria》中制作的全面符合 RISC-V 架构的计算机"></a><a href="https://github.com/misprit7/computerraria">computerraria：在游戏《Terraria》中制作的全面符合 RISC-V 架构的计算机</a></h3><p><img src="/2023/06/30/2023/06/daily-tech-blog-collection-202306030/computerraria1.png"></p>
<p>这个项目在著名游戏《Terraria》中构建了一个计算机。</p>
<p>尽管这个项目的介绍可能会让人误以为其目标是最大化游戏中CPU的兼容性和处理能力，但实际上这是通过使用加速器修改版实现的。该修改版在保持与原版布线系统的完全兼容性的同时，以更高效的方式重新实现了该系统。</p>
<p>通过一个叫做<a href="https://github.com/misprit7/WireHead">WireHead</a>的加速器mod来实现，其计算机性能如下：</p>
<ul>
<li>频率：5kHz</li>
<li>内存：96kb</li>
<li>指令集：rv32i</li>
</ul>
<p>在这个游戏内计算机的基础上，构建了弹球的游戏。<br><img src="/2023/06/30/2023/06/daily-tech-blog-collection-202306030/computerraria2.png"></p>
<p>安装</p>
<ul>
<li>下载项目到《Terraria》的mod目录<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Windows: Documents\My Games\Terraria\ModLoader\Worlds</span><br><span class="line">Linux: ~/.<span class="built_in">local</span>/share/Terraria/tModLoader/Worlds</span><br></pre></td></tr></table></figure></li>
<li>下载WireHead到mod目录<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Windows</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;%userprofile%\Documents\My Games\Terraria\ModLoader\ModSources&quot;</span> &amp;&amp; git <span class="built_in">clone</span> https://github.com/misprit7/WireHead.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#Linux</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;~/.local/share/Terraria/tModLoader/ModSources&quot;</span> &amp;&amp; git <span class="built_in">clone</span> https://github.com/misprit7/WireHead.git</span><br></pre></td></tr></table></figure></li>
<li>进入弹球游戏目录并使用rust命令编译运行<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;path to computerraria&gt;/app/pong</span><br><span class="line">cargo rb</span><br><span class="line">./copy-bin.sh /tmp/pong.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p>目录结构</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app/</span><br><span class="line">│   ├── tdriver/</span><br><span class="line">│   └── template/</span><br><span class="line">├── computer.wld</span><br><span class="line">├── doc/</span><br><span class="line">├── docker/</span><br><span class="line">├── <span class="built_in">test</span>/</span><br><span class="line">└── tinterface/</span><br><span class="line">    ├── bin/</span><br><span class="line">    └── tinterface/</span><br></pre></td></tr></table></figure>

<h3 id="mdbook：通过markdown来创建一本书"><a href="#mdbook：通过markdown来创建一本书" class="headerlink" title="mdbook：通过markdown来创建一本书"></a><a href="https://rust-lang.github.io/mdBook/">mdbook：通过markdown来创建一本书</a></h3><p>mdBook是一个用Markdown创建书籍的命令行工具。它非常适合创建产品或API文档、教程、课程材料或任何需要清晰、易于导航和可自定义呈现的内容。</p>
<ul>
<li>轻量级的Markdown语法帮助您更专注于内容。</li>
<li>集成搜索支持。</li>
<li>为多种不同的编程语言提供代码块的语法高亮显示。</li>
<li>主题文件允许自定义输出的格式。</li>
<li>预处理器可以提供自定义语法扩展和修改内容。</li>
<li>后端可以将输出呈现为多种格式。</li>
<li>使用Rust编写，以实现速度、安全性和简洁性。</li>
<li>对Rust代码示例进行自动化测试。</li>
</ul>
<p>安装mdbook</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 可以直接从[github地址](https://github.com/rust-lang/mdBook/releases)获取最新包</span></span><br><span class="line">wget https://github.com/rust-lang/mdBook/releases/download/v0.4.31/mdbook-v0.4.31-aarch64-unknown-linux-musl.tar.gz</span><br><span class="line"><span class="comment">## 用RUST构建，需要安装至少1.65版本以上的RUST</span></span><br><span class="line">cargo install mdbook</span><br><span class="line"><span class="comment">## 安装最新的master分支</span></span><br><span class="line">cargo install --git https://github.com/rust-lang/mdBook.git mdbook</span><br></pre></td></tr></table></figure>

<p>命令行工具</p>
<ul>
<li>初始化书本<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mdbook init my-first-book</span><br></pre></td></tr></table></figure></li>
<li>回答完几个问题后就可以执行<code>server</code>命令运行服务器并打开本地浏览器。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mdbook serve --open</span><br></pre></td></tr></table></figure></li>
<li>服务器运行期间，对于书本的更改都会自动编译到浏览器上。</li>
<li>书本设置<ul>
<li>可以在<code>book.toml</code>中配置书本的配置，默认的配置一般够用，在配置单元可以看到具体的配置项。</li>
<li>在<code>src/SUMMARY.md</code>包含书本的所有章节设置。</li>
<li>资源文件在<code>src</code>目录下，每个章节都是独立的markdown文件。</li>
</ul>
</li>
<li>使用<code>mdbook build</code>编译书本。</li>
</ul>
<h3 id="开源语言模型在上下文长度方面能真正保证多长？"><a href="#开源语言模型在上下文长度方面能真正保证多长？" class="headerlink" title="开源语言模型在上下文长度方面能真正保证多长？"></a><a href="https://lmsys.org/blog/2023-06-29-longchat/">开源语言模型在上下文长度方面能真正保证多长？</a></h3><p><a href="https://lmsys.org/">LMSYS Org</a>是一个由加州大学伯克利分校的学生和教师组成的开放研究组织，它旨在通过共同开发的方式，使大型模型更加易于使用和可访问。最近该组织推出的<a href="https://huggingface.co/lmsys/longchat-7b-16k">LongChat-7B</a>和<a href="https://huggingface.co/lmsys/longchat-13b-16k">LongChat-13B</a>将文本拓展到了16000个token的长度。</p>
<p>评估结果显示，LongChat-13B的长距离检索准确率比其他长上下文开放模型（如MPT-7B-storywriter（65K）、MPT-30B-chat（8K）和ChatGLM2-6B（32K））高出多达2倍。</p>
<p><img src="/2023/06/30/2023/06/daily-tech-blog-collection-202306030/longchat1.png"></p>
<p>可通过以下命令启用这两个大语言模型：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 -m fastchat.serve.cli --model-path lmsys/longchat-7b-16k</span><br></pre></td></tr></table></figure>

<p>这个项目在开源社区得到了关注，并有一些项目宣称自己支持比LLaMA更长的上下文，值得关注的有：</p>
<ul>
<li><a href="https://huggingface.co/mosaicml/mpt-7b-storywriter">MPT-7B-storywriter</a></li>
<li><a href="https://huggingface.co/spaces/mosaicml/mpt-30b-chat">MPT-30B-chat</a></li>
<li><a href="https://huggingface.co/THUDM/chatglm2-6b">ChatGLM2-6B</a></li>
</ul>
<p>LongChat训练方式，主要包含两步：</p>
<ul>
<li>压缩旋转嵌入：旋转嵌入是一种在自然语言处理中广泛使用的技术，它可以将词汇或短语映射到一个连续的向量空间中。然而，由于嵌入空间的维度往往很大，这可能会导致计算和存储成本的增加。（原文没太看懂，这段解释来自chatgpt）</li>
<li>在筛选过的对话数据上进行微调：在压缩嵌入之后，我们对我们的筛选过的对话数据集执行微调过程。我们重新使用之前用于训练Vicuna的收集到的用户共享对话。</li>
</ul>
<p>这篇文章后面还有详细的调试和结果说明，太专业了😮‍💨，有兴趣的同学去原文看看吧。</p>
<h3 id="Tesla-Fleet-Telemetry：特斯拉的的数据中转框架"><a href="#Tesla-Fleet-Telemetry：特斯拉的的数据中转框架" class="headerlink" title="Tesla Fleet Telemetry：特斯拉的的数据中转框架"></a><a href="https://github.com/teslamotors/fleet-telemetry">Tesla Fleet Telemetry：特斯拉的的数据中转框架</a></h3><p>特斯拉推出的官方数据中转框架，允许客户从他们的特斯拉设备直接建立安全的桥接，并与任何授权的提供商通信。Fleet Telemetry是一个简单、可扩展和安全的车辆和其他设备的数据交换服务。</p>
<p>配置和运行服务：</p>
<ul>
<li>使用Helm Chart在Kubernetes上安装（推荐）</li>
<li>手动安装<ul>
<li>分配和指定完全限定域名（FQDN）。这将在服务器和客户端（车辆）配置中使用。</li>
<li>设计一个简单的托管架构。我们推荐的架构是：防火墙/负载均衡器 -&gt; Fleet Telemetry -&gt; Kafka。</li>
<li>确保mTLS连接在Fleet Telemetry服务上终止。</li>
<li>配置服务器。</li>
<li>部署和运行服务器。从我们的Docker Hub获取最新的Docker镜像信息。</li>
<li>创建并与特斯拉分享车辆配置。</li>
</ul>
</li>
</ul>
<p>支持的中间件</p>
<ul>
<li>Kafka（首选）：使用config.json文件进行配置。在这里查看实现：config/config.go</li>
<li>Kinesis：使用标准的AWS环境变量和配置文件进行配置。默认的AWS凭证和配置文件路径为：~/.aws/credentials 和 ~/.aws/config。<ul>
<li>默认情况下，流名称将为 配置的命名空间主题名称，例如：tesla_V、tesla_errors、tesla_alerts 等。</li>
<li>通过设置流配置中的 “kinesis”: { “streams”: { topic_name: stream_name } }，可以直接配置流名称。</li>
<li>使用环境变量覆盖流名称：KINESIS_STREAM大写的主题名称，例如：KINESIS_STREAM_V。</li>
</ul>
</li>
<li>Google Pub/Sub：除了必要的Pub/Sub配置（参见./test/integration/config.json的示例），还需要设置环境变量 <code>GOOGLE_APPLICATION_CREDENTIALS</code>。</li>
<li>Logger：这是一个简单的标准输出（STDOUT）日志记录器，将协议缓冲区序列化为JSON格式。</li>
</ul>
<h3 id="Hurl-4-0-0："><a href="#Hurl-4-0-0：" class="headerlink" title="Hurl 4.0.0："></a><a href="https://hurl.dev/blog/2023/06/30/announcing-hurl-4.0.0.html">Hurl 4.0.0：</a></h3><p><a href="https://hurl.dev/">Hurl</a>是一个由curl驱动的命令行工具，它可以运行在简单纯文本格式中定义的HTTP请求。</p>
<p>这个版本有哪些更新：</p>
<ul>
<li>改进的HTML报告，包含请求瀑布图。<br><img src="/2023/06/30/2023/06/daily-tech-blog-collection-202306030/hurl1.jpeg"></li>
<li>CI/CD（持续集成/持续部署）过程中详尽的错误报告。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hurl --error-format long --<span class="built_in">test</span> test.hurl</span><br><span class="line">test.hurl: Running [1/1]</span><br><span class="line">HTTP/2 200</span><br><span class="line">date: Thu, 29 Jun 2023 16:06:58 GMT</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 58941</span><br><span class="line">last-modified: Thu, 29 Jun 2023 14:37:22 GMT</span><br><span class="line">etag: <span class="string">&quot;649d9722-e63d&quot;</span></span><br><span class="line">strict-transport-security: max-age=31536000; includeSubDomains</span><br><span class="line">content-security-policy: default-src <span class="string">&#x27;self&#x27;</span>; script-src <span class="string">&#x27;self&#x27;</span> <span class="string">&#x27;unsafe-eval&#x27;</span> <span class="string">&#x27;wasm-unsafe-eval&#x27;</span></span><br><span class="line">x-frame-options: SAMEORIGIN</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">accept-ranges: bytes</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;apple-touch-icon&quot;</span> href=<span class="string">&quot;/assets/img/hurl-icon-120.png&quot;</span> /&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">error: Assert failure</span><br><span class="line">  --&gt; test.hurl:4:0</span><br><span class="line">   |</span><br><span class="line"> 4 | header <span class="string">&quot;Control-Security-Policy&quot;</span> contains <span class="string">&quot;default-src &#x27;self&#x27;&quot;</span> </span><br><span class="line">   |   actual:   none</span><br><span class="line">   |   expected: contains string &lt;default-src <span class="string">&#x27;self&#x27;</span>&gt;</span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">test.hurl: Failure (1 request(s) <span class="keyword">in</span> 146 ms)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Executed files:  1</span><br><span class="line">Succeeded files: 0 (0.0%)</span><br><span class="line">Failed files:    1 (100.0%)</span><br><span class="line">Duration:        148 ms</span><br></pre></td></tr></table></figure></li>
<li>新增的过滤器：decode和xpath。</li>
<li>JSONPath变化。基本上，在Hurl 4.0.0中，唯一返回值的选择器是：<ul>
<li>数组索引选择器（$.store.book[2]）</li>
<li>对象键选择器（$.store.bicycle.color/$.store.bicycle[‘color’]）</li>
<li>其他使用过滤器的选择器（例如?(@.price &gt;= 10)或$[*].id）将返回一个集合。然后，您可以使用nth过滤器从该集合中提取一个值。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET https://example.com/books</span><br><span class="line">HTTP 200</span><br><span class="line">[Asserts]</span><br><span class="line">jsonpath <span class="string">&quot;$.store.book[0].title&quot;</span> == <span class="string">&quot;Dune&quot;</span></span><br><span class="line">jsonpath <span class="string">&quot;$.store.book[*].title&quot;</span> nth 0 == <span class="string">&quot;Dune&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可定制的HTTP方法。可以写任何方法名，唯一的要求是大写。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">QUERY https://example.org/contacts</span><br><span class="line">Content-Type: example/query</span><br><span class="line">Accept: text/csv</span><br><span class="line">HTTP 200</span><br><span class="line">Content-Type: text/csv</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230703</title>
    <url>/2023/07/03/2023/07/daily-tech-blog-collection-20230703/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h3 id="用iPad编程是一个错误"><a href="#用iPad编程是一个错误" class="headerlink" title="用iPad编程是一个错误"></a><a href="https://technicallychallenged.substack.com/p/buying-an-ipad-pro-for-coding-was">用iPad编程是一个错误</a></h3><p>作者买了个M1芯片的iPad，寄希望于可以实现轻量级的编程。</p>
<h4 id="为什么要选择iPad？"><a href="#为什么要选择iPad？" class="headerlink" title="为什么要选择iPad？"></a>为什么要选择iPad？</h4><ul>
<li>首先是为了能够阅读编码类的书籍，这方面，kindle几乎没法阅读代码书籍，用电脑看太大，体验不佳，只有iPad是完美的选择。</li>
<li>另一方面，苹果在2021年的WWDC上发布了在iPad上可用的Swift编码程序。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/ipad1.png"></li>
</ul>
<h4 id="iPad在哪方面表现优秀？"><a href="#iPad在哪方面表现优秀？" class="headerlink" title="iPad在哪方面表现优秀？"></a>iPad在哪方面表现优秀？</h4><ul>
<li>很多很多。写作，制表，音乐制作，视频剪辑。</li>
<li>可以用笔的操作也很棒：笔记，绘画，照片编辑，以及用Final Cut Pro编辑你的视频。</li>
</ul>
<h4 id="配件准备"><a href="#配件准备" class="headerlink" title="配件准备"></a>配件准备</h4><ul>
<li>由于想要编程，所以作者买了magic keyboard。ipad搭配magic keyboard可以拥有mac上80%的体验。</li>
<li>搭配了鼠标，iPad上新增的鼠标指针功能在使用了一段时间后，发现它也非常好用。</li>
<li>第二代ipad pencil非常棒，可靠而精确。</li>
</ul>
<span id="more"></span>

<h4 id="性能和电池"><a href="#性能和电池" class="headerlink" title="性能和电池"></a>性能和电池</h4><ul>
<li>新的M1芯片表现卓越，性能和电池续航都很出色。</li>
<li>电池续航尤其值得一提，据作者说，可以数天不充电依然电量充足。</li>
</ul>
<h4 id="重量"><a href="#重量" class="headerlink" title="重量"></a>重量</h4><p>iPad本身非常轻巧，但是一旦增加了上述配件，iPad就会增加到几乎两倍重量。权衡利弊，作者认为这是值得的。</p>
<h4 id="你能够在iPad上编程吗？"><a href="#你能够在iPad上编程吗？" class="headerlink" title="你能够在iPad上编程吗？"></a>你能够在iPad上编程吗？</h4><p>简短回答：可以。</p>
<p>详细回答：这实际上取决于你想要进行什么类型的编码以及你将使用何种开发环境。如果你只是在Swift Playgrounds中学习Swift，那么当然可以用它来编码，但是你也可以使用基本款的iPad以节省成本。</p>
<p>如果你是一名主要在SSH终端中工作的系统管理员，或者如果你可以访问基于浏览器的云开发环境，那么iPad适合你的工作流程，尤其是如果你想将它与外接显示器或USB-C转HDMI一起使用。</p>
<p>但是，如果你需要运行Xcode、VSCode、WebStorm或Intellij，iPad则不适用。</p>
<h4 id="为什么不应该在2023年买一个iPad"><a href="#为什么不应该在2023年买一个iPad" class="headerlink" title="为什么不应该在2023年买一个iPad"></a>为什么不应该在2023年买一个iPad</h4><ul>
<li>它很昂贵。购买了一款功能强大的专业版iPad、一款不错的键盘和一支笔后，价格比本可以购买的用于更多编码活动的笔记本电脑还要高。</li>
<li>键盘快捷键和操作系统不太适合高级用户的需求。某些应用程序中的一些快捷键无法工作，这取决于开发者编码应用程序的方式和其支持的功能。而且其他类型的自定义选项也不够丰富，无法满足需求。</li>
<li>屏幕较小 - 为了节省一些成本，作者选择了11英寸而不是12.9英寸的版本。即使选择了12.9英寸，仍然太小了。我最舒适的是15或16英寸的笔记本电脑，所以11英寸对我来说只是微不足道的。但要承认的是，你可以连接外接显示器来扩大屏幕。</li>
</ul>
<p><strong>总之，目前看来，用iPad编程不如买一个相对便宜的MacBook。</strong></p>
<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="推特在DDOS攻击自己"><a href="#推特在DDOS攻击自己" class="headerlink" title="推特在DDOS攻击自己"></a><a href="https://sfba.social/@sysop408/110639435788921057">推特在DDOS攻击自己</a></h3><p>博主通过后台发现推特在ddos攻击推特自己，这件事本身就很有趣，而细究此事的前因后果就更具有戏剧性。</p>
<ul>
<li>6月30号，推特老总埃隆马斯克新出了一项<a href="https://techcrunch.com/2023/06/30/twitter-now-requires-an-account-to-view-tweets/">浏览规则</a>，即推特内容不再像以前那样可以不登录就能浏览，现在要求用户必须注册并登录。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/twitter1.png"></li>
<li>这件事当然引起轩然大波，这意味着推特将自己的内容封闭了，不再有公共内容。</li>
<li>7月1号开始有用户发现推特的内容无法加载，整个服务似乎已经挂了。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/twitter2.png"></li>
<li>7月2号也就是这篇文章的作者发现推特以每秒10次的频率在请求推特的服务器拉取内容，而这个bug的原因竟然就是必须登录才能浏览推特的这个规定：即不登录的情况下浏览器拉取不到内容，于是脚本不断的请求服务器。可想而知，全球大量的不登录请求直接干趴了推特服务器。</li>
<li>而马斯克还在继续作妖，于7月2号又发布了一篇惊世骇俗的推文，规定了推特的浏览限制：认证用户可以一天浏览6000条推文，非认证用户600条，新注册的非认证用户只能浏览300条。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/twitter3.png"></li>
</ul>
<p>难以想象在如今这个流量为王的互联网时代，马斯克居然推出了这么一系列反其道而行之的规定，无论乍看还是细想，都觉得这是把推特推上死路。但是考虑到马斯克这个人有多爱整活，又让人非常想要知道他这么做的背后逻辑。至于后续如何，只能继续拭目以待了。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/twitter4.jpeg"></p>
<h3 id="Far-Cry-源码公布"><a href="#Far-Cry-源码公布" class="headerlink" title="Far Cry 源码公布"></a><a href="https://archive.org/details/far-cry-1.34-complete">Far Cry 源码公布</a></h3><p><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/farcry1.png"><br>Far Cry是著名的游戏系列，是标准的3A大作，最近有网友发现在知名免费资源网站(archive.org)上居然看到了Far Cry的完整源码上传。</p>
<p>虽然这段源码只是2004年的第一部Far Cry，由古早引擎开发的，但是对于网友来说，这依然是非常宝贵的游戏开发学习资料。</p>
<p>厂商的这个慈善行为（没有明确是厂商上传，但我想应该也没别人敢干这事儿）得到了大量网友的点赞。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/farcry2.png"></p>
<h3 id="美国FTC：虚假的评论内容将会违法并承受重罚"><a href="#美国FTC：虚假的评论内容将会违法并承受重罚" class="headerlink" title="美国FTC：虚假的评论内容将会违法并承受重罚"></a><a href="https://www.washingtonpost.com/technology/2023/06/30/fake-reviews-online-ftc/">美国FTC：虚假的评论内容将会违法并承受重罚</a></h3><p>联邦贸易委员会（The Federal Trade Commission）将对网络评论的贸易行为进行控制，如果新的规定通过，对于虚假评论的处罚将非常严重，每次虚假评论被消费者看到都将遭到最多50000美元的处罚，注意，<strong>是每次被看到都遭到50000美元处罚</strong>。</p>
<p>据统计30%到40%的评论都是捏造的（这个应该是美国的比例），尤其在chatgpt这样的人工智能出现后，虚假的但是随机而富有逻辑的正面评论将会弥漫于网络，让消费者难以发现客观正确的产品评价，FTC正是对于这样的情况做出这样顶格处罚的规定。</p>
<p>具体违反规定的评论包括：</p>
<ul>
<li>一些歪曲实际产品体验的评论</li>
<li>由不存在的用户提供的评论</li>
<li>由内部人员提供的评论</li>
<li>由中间人生成的评论</li>
<li>劫持别的用户账号进行评论</li>
</ul>
<p>另外一些情况不违反规定：厂商要求真实用户提供评论或者厂商提供有偿奖励真实用户评论。</p>
<p>另外新规也不会要求网站去负责这些虚假评论，除非他们直接参与了这些虚假评论的产生。</p>
<p>一些大厂对于新规的回应颇为积极：亚马逊声称在2022年屏蔽了超过20亿条虚假评论，yelp声称2022年将19%的评论标记为“不推荐”。</p>
<h3 id="Gping：图形化ping"><a href="#Gping：图形化ping" class="headerlink" title="Gping：图形化ping"></a><a href="https://github.com/orf/gping">Gping：图形化ping</a></h3><p>这个开源项目非常好理解，就是将ping命令进行图形化，具体效果如下：<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/gping1.png"></p>
<h4 id="安装方式："><a href="#安装方式：" class="headerlink" title="安装方式："></a>安装方式：</h4><ul>
<li>macOS<ul>
<li>Homebrew: <code>brew install gping</code></li>
<li>MacPorts: <code>sudo port install gping</code></li>
</ul>
</li>
<li>Linux (Homebrew): <code>brew install gping</code></li>
<li>CentOS (或者任何搭载老版本glibc的发行版): 下载MUSL并编译最新版本</li>
<li>Windows/ARM:<ul>
<li>Scoop: <code>scoop install gping</code></li>
<li>Chocolatey: <code>choco install gping</code></li>
<li>从github发行页面下载最新版本</li>
</ul>
</li>
<li>Fedora (COPR): <code>sudo dnf copr enable atim/gping -y &amp;&amp; sudo dnf install gping</code></li>
<li>Cargo (需要rustc版本1.44.0以上): <code>cargo install gping</code></li>
<li>Arch Linux: <code>pacman -S gping</code></li>
<li>Ubuntu/Debian (Azlux’s repo):<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://packages.azlux.fr/debian/ buster main&quot;</span> | sudo tee /etc/apt/sources.list.d/azlux.list</span><br><span class="line">wget -qO - https://azlux.fr/repo.gpg.key | sudo apt-key add -</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gping</span><br></pre></td></tr></table></figure></li>
<li>Gentoo (dm9pZCAq overlay):<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo eselect repository <span class="built_in">enable</span> dm9pZCAq</span><br><span class="line">sudo emerge --sync dm9pZCAq</span><br><span class="line">sudo emerge net-misc/gping::dm9pZCAq</span><br></pre></td></tr></table></figure></li>
<li>FreeBSD:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pkg: pkg install gping</span><br><span class="line">ports <span class="built_in">cd</span> /usr/ports/net-mgmt/gping; make install clean</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>没啥特别的，ping怎么用，gping就怎么用，最简单的用法<code>gping [host]</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gping --<span class="built_in">help</span></span><br><span class="line">Ping, but with a graph.</span><br><span class="line"></span><br><span class="line">Usage: gping [OPTIONS] [HOSTS_OR_COMMANDS]...</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  [HOSTS_OR_COMMANDS]...  Hosts or IPs to ping, or commands to run <span class="keyword">if</span> --cmd is provided. Can use cloud shorthands like aws:eu-west-1.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --cmd</span><br><span class="line">          Graph the execution time <span class="keyword">for</span> a list of commands rather than pinging hosts</span><br><span class="line">  -n, --watch-interval &lt;WATCH_INTERVAL&gt;</span><br><span class="line">          Watch interval seconds (provide partial seconds like <span class="string">&#x27;0.5&#x27;</span>). Default <span class="keyword">for</span> ping is 0.2, default <span class="keyword">for</span> cmd is 0.5.</span><br><span class="line">  -b, --buffer &lt;BUFFER&gt;</span><br><span class="line">          Determines the number of seconds to display <span class="keyword">in</span> the graph. [default: 30]</span><br><span class="line">  -4</span><br><span class="line">          Resolve ping targets to IPv4 address</span><br><span class="line">  -6</span><br><span class="line">          Resolve ping targets to IPv6 address</span><br><span class="line">  -i, --interface &lt;INTERFACE&gt;</span><br><span class="line">          Interface to use when pinging</span><br><span class="line">  -s, --simple-graphics</span><br><span class="line">          Uses dot characters instead of braille</span><br><span class="line">      --vertical-margin &lt;VERTICAL_MARGIN&gt;</span><br><span class="line">          Vertical margin around the graph (top and bottom) [default: 1]</span><br><span class="line">      --horizontal-margin &lt;HORIZONTAL_MARGIN&gt;</span><br><span class="line">          Horizontal margin around the graph (left and right) [default: 0]</span><br><span class="line">  -c, --color &lt;color&gt;</span><br><span class="line">          Assign color to a graph entry. This option can be defined more than once as a comma separated string, and the order <span class="built_in">which</span> the colors are provided will be matched against the hosts or commands passed to gping. Hexadecimal RGB color codes are accepted <span class="keyword">in</span> the form of <span class="string">&#x27;#RRGGBB&#x27;</span> or the following color names: <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;magenta&#x27;</span>,<span class="string">&#x27;cyan&#x27;</span>, <span class="string">&#x27;gray&#x27;</span>, <span class="string">&#x27;dark-gray&#x27;</span>, <span class="string">&#x27;light-red&#x27;</span>, <span class="string">&#x27;light-green&#x27;</span>, <span class="string">&#x27;light-yellow&#x27;</span>, <span class="string">&#x27;light-blue&#x27;</span>, <span class="string">&#x27;light-magenta&#x27;</span>, <span class="string">&#x27;light-cyan&#x27;</span>, and <span class="string">&#x27;white&#x27;</span></span><br><span class="line">  -h, --<span class="built_in">help</span></span><br><span class="line">          Print <span class="built_in">help</span> information</span><br><span class="line">  -V, --version</span><br><span class="line">          Print version information</span><br><span class="line">      --clear</span><br><span class="line">          Clear the graph from the terminal after closing the program</span><br></pre></td></tr></table></figure>

<h3 id="油管开始对广告屏蔽插件采取更加激进的手段"><a href="#油管开始对广告屏蔽插件采取更加激进的手段" class="headerlink" title="油管开始对广告屏蔽插件采取更加激进的手段"></a><a href="https://www.androidpolice.com/youtube-ad-blockers-three-strikes/">油管开始对广告屏蔽插件采取更加激进的手段</a></h3><p>有Reddit用户发现，youtube给他弹出了一个界面，告知要么将youtube加到广告屏蔽插件的白名单里，或者购买他们的YouTube Premium会员。<br><img src="/2023/07/03/2023/07/daily-tech-blog-collection-20230703/youtube1.jpeg"></p>
<p>youtube似乎开响了和广告屏蔽插件的第一枪，逼迫用户在他们的产品和广告屏蔽插件之间二选一。当然，市面上大部分网站和产品应该是没有这样的底气的，也就是youtube做到了这样的体量，用户粘性高，才敢这么激进的要求用户必须二选一。</p>
<p>目前这种弹窗还是在少部分用户中试行，而且知名广告屏蔽插件uBlock Origin也没出现这种情况，现在应该还只是youtube的一个小范围实验功能。一旦这个功能推广，那么你就只能要么永远忍受30s的视频前广告，或者订阅12美元一个月的会员服务。</p>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230704</title>
    <url>/2023/07/04/2023/07/daily-tech-blog-collection-20230704/</url>
    <content><![CDATA[<h2 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h2><h3 id="如何在数字时代高效学习"><a href="#如何在数字时代高效学习" class="headerlink" title="如何在数字时代高效学习"></a><a href="https://giansegato.com/essays/edutainment-is-not-learning">如何在数字时代高效学习</a></h3><p>作者曾经沉浸于获取各种数字信息，包括TED，博客，hacker news，电子书等等，这给了他一种在学习的感觉，让他觉得自己是个“聪明人”。</p>
<p>直到几个月前，作者开始怀疑这种习惯的学习效率。虽然他在消费大量的电子信息，但是到了真正需要的时候，他只是大概知道知识的轮廓，而不清楚具体的知识内容，这种情况对于他当下的场景毫无用处。</p>
<p>摄入的信息跑到哪里去了呢？</p>
<p>学习是一种将信息转换为长久知识的过程。信息是短暂的，知识是基础。把知识看作是人的话，信息就是这个人的一张照片而已。</p>
<p>理论上如果堆积足够多的信息，它最终会转化为知识。但是作者读了那么多的商业类新闻，却最终没有得到足够多的商业知识。</p>
<p>作者花了八个月时间去研究元学习是怎么回事：人类究竟是怎么学习的？</p>
<span id="more"></span>

<h4 id="高效学习"><a href="#高效学习" class="headerlink" title="高效学习"></a>高效学习</h4><p>作者发现，人类的记忆并不像存储设备，而且学习并不是通过“被动积累”来实现的。</p>
<p>事实上，我们只有在学习过程中付出真正的努力时才能保留信息。学习的困难程度不仅仅是核心活动的副产品，就像跑步时的气喘一样。相反，这正是使学习成为可能的原因。这种关系是因果关系。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/learn1.png"></p>
<p><strong>简单的学习是不存在的：学习必须是努力的，才能实现。数字产品让你很容易自欺欺人，让你认为自己在学习，而实际上只是在被娱乐。</strong></p>
<h4 id="学习的神经学原理"><a href="#学习的神经学原理" class="headerlink" title="学习的神经学原理"></a>学习的神经学原理</h4><p>作者不是妄图从底层医学角度解释，而是通过能够理解的大脑结构来进行解释。</p>
<p>我们的大脑由相互连接的神经元(neuron)网络构成。这些神经元之间的连接称为轴突(axons)：它们是一种长而细的神经纤维投射，用于传递电脉冲。</p>
<p>在这些轴突周围，有一层被称为髓鞘(myelin)的绝缘膜。它覆盖着许多神经轴突，促进电信号沿着神经回路传播。轴突周围的髓鞘越多，信号传输就会越强、连接越紧密。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/learn2.png"></p>
<p>髓鞘对神经传递的作用就像氧气对火焰的作用一样。它使得信息能够快速传递长距离，并大大增加了电信号在我们大脑中传播的速度。</p>
<p>可以将其看作水流通过具有动态、变化容量的管道。容量更大的管道可以比小管道或慢速滴漏更快地输送更多的水。更多的髓鞘支持神经连接，使用该连接就会更容易，从而更容易使用相关的技能或记住相关的主题。</p>
<p><strong>所以关键就是髓鞘，它是动态的，决定了信息的记忆速度，那它是怎么生成的？</strong></p>
<p>当我们遇到一个新的主题时，大脑的新区域开始激活。我们越是使用这些新区域，髓鞘就会合成得越多，这使得相关主题（或活动）变得更容易。</p>
<p>我们都知道俗语“熟能生巧”。我们越是使用大脑的某个特定区域，我们的大脑就越会“优先考虑”和“磨练”这个区域。这就是导致髓鞘形成的原因：活动诱导髓鞘化，从而增强了神经元之间的连接强度和效率。这是一个自我强化的过程。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/learn3.png"></p>
<p>看起来，人类的认知根本上是基于感觉运动过程的：当我们将某种物理活动与信息关联起来时，我们会更好地记住它。普遍的直觉是，<strong>运动提供了我们可以用来检索知识的额外线索。</strong></p>
<p>越来越多的研究表明，通过手写笔记比使用笔记本电脑要有效得多。</p>
<p>我们没有进化到通过被动观看Masterclass视频来存储信息：这不是我们大脑的工作方式。</p>
<h3 id="在数字时代具有创造力的学习方式"><a href="#在数字时代具有创造力的学习方式" class="headerlink" title="在数字时代具有创造力的学习方式"></a>在数字时代具有创造力的学习方式</h3><p>教育娱乐将教育主题与娱乐方法相结合。即使教育娱乐更多地优化了 passively attention（被动注意力）而不是 effortful engagement（积极参与，与学习相反），它并不仅仅是“简单的娱乐”。像 Cal Newport 这样的“深度工作”倡导者建议删除 Twitter 并取消订阅新闻通讯，但实际上可能会阻止学习。</p>
<p>在这个框架中，“无意识”的在线浏览可以转变为寻找学习机会的侦察行为。这又是一个需要平衡探索新机会和对现有机会的承诺的搜索问题，这涉及到在线“侦察”有趣主题所花费的时间与离线努力（用于长期记忆和整合）之间的平衡。</p>
<h4 id="学习收件箱"><a href="#学习收件箱" class="headerlink" title="学习收件箱"></a>学习收件箱</h4><p>作者提出的一个学习方法，他从传奇教育科技专家 Andy Matuschak 那里借鉴了这个想法。学习收件箱是一个强制性的系统，让人意识到哪些内容是学习，哪些内容仅仅是娱乐。</p>
<p>将学习途中发现的一切有趣的东西都会被发送到我的学习收件箱，然后对其进行分类，无论是论文、在线文章、博客帖子、YouTube视频还是播客。</p>
<p>当一个项目进入学习收件箱时，有三种可能的结果：要么决定积极参与其中，要么将其归档以供将来查看，要么就将其删除。</p>
<p>总之，需要采取努力的行动来消化列表中的内容，否则会自动将其归类为娱乐。</p>
<p>核心思想是尽力不自欺欺人：当对某个内容的参与是积极和付出努力的时候，那就是学习；当 passively（被动地）消费时，那只是娱乐。当创造时，就是学习。当消费时，那只是放松。</p>
<blockquote>
<p>被动浏览是一种上瘾：整个信息供应链都优化了在应用程序中花费的时间，而不是为了记忆和积极性。<br>幸运的是，另一方面，随着内容和刺激的丰富，寻找新的主题和学习的理由变得非常容易。<br>我们只需要积极主动地参与我们可以获得的所有内容流。去建立、写作、交流、教授、解释、创造 - 这些都是付出努力的行动，会带来有意义的成长。</p>
</blockquote>
<h2 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h2><h3 id="Anna’s-Archive：世界上最大的开源图书馆"><a href="#Anna’s-Archive：世界上最大的开源图书馆" class="headerlink" title="Anna’s Archive：世界上最大的开源图书馆"></a><a href="https://annas-archive.org/">Anna’s Archive：世界上最大的开源图书馆</a></h3><p><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/archive1.png"><br>根据网站介绍，这是世界上最大的开源图书馆，目前包含14704605本书, 86614159份报纸, 2379209本漫画, 407040本杂志。</p>
<p>（Anna’s Archive）是一个非营利项目，有两个目标：<br>保存：备份人类的所有知识和文化。<br>获取：使这些知识和文化对全世界任何人都可获得。</p>
<p>目前网站估计它们囊括了全世界5%的书籍资料。（1400万本书就敢说包含了全世界5%，这未免吹大牛了。。。）<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/archive2.png"></p>
<p>稍微查了下，书籍确实还是挺全的，用中文或者英文都能查。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/archive3.png"><br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/archive4.png"></p>
<h3 id="糟糕的房地产广告照片"><a href="#糟糕的房地产广告照片" class="headerlink" title="糟糕的房地产广告照片"></a><a href="https://terriblerealestateagentphotos.com/">糟糕的房地产广告照片</a></h3><p>这个网站列举了一些拍摄的非常糟糕的房地产照片，各有特点，展示了各种奇葩的房产。</p>
<p>贴满炫目墙纸的厕所。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/terriblephoto1.jpeg"></p>
<blockquote>
<p>有时候，明显缺乏品味反而能帮助房间看起来比实际更大。</p>
</blockquote>
<p><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/terriblephoto2.jpeg"></p>
<blockquote>
<p>我始终觉得邻居对于我的万圣节聚会反应过度</p>
</blockquote>
<p><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/terriblephoto3.jpeg"></p>
<h3 id="Karabiner-Elements：macOS环境下的强大键盘工具"><a href="#Karabiner-Elements：macOS环境下的强大键盘工具" class="headerlink" title="Karabiner-Elements：macOS环境下的强大键盘工具"></a><a href="https://karabiner-elements.pqrs.org/">Karabiner-Elements：macOS环境下的强大键盘工具</a></h3><p>Karabiner-Elements是一个在macOS Sierra或更高版本上进行键盘自定义的强大实用工具。</p>
<ul>
<li><p>下载</p>
<ul>
<li>可以从<a href="https://karabiner-elements.pqrs.org/">官网</a>下载。</li>
<li>如果是<code>homebrew</code>用户，可以用<code>brew install --cask karabiner-elements</code>命令进行安装下载。</li>
</ul>
</li>
<li><p>支持的系统</p>
<ul>
<li>macOS 11 Big Sur</li>
<li>macOS 12 Monterey</li>
<li>macOS 13 Ventura</li>
<li>macOS 14 Sonoma</li>
</ul>
</li>
<li><p>核心功能</p>
<ul>
<li>简单修改：将普通键更改为其他键。</li>
<li>复杂修改：通过复杂规则更改键。<ul>
<li>将一个键更改为多个修饰键的组合。（例如，将大写锁定键更改为Control+Command）</li>
<li>将修饰键+键更改为键。（例如，将Control+M更改为Return）</li>
<li>如果单独按下一个键，则发送键事件。</li>
<li>如果同时按下多个键，则发送键事件。</li>
<li>鼠标键。</li>
<li>等等。</li>
</ul>
</li>
<li>功能键：将F1-F12键更改为媒体控制键。</li>
<li>设备：仅对指定的键盘应用修改。</li>
<li>配置文件：支持多个配置文件。</li>
<li>修饰键标志同步：在所有连接的键盘上同步修饰键标志。</li>
<li>支持安全键盘输入：在安全键盘输入环境（如密码提示、带有安全键盘输入的终端等）上正常工作。</li>
<li>额外按键支持：启用PC键盘上默认未识别的额外按键。<ul>
<li>iPad键盘上的Home键，例如Logitech K480</li>
<li>国际按键</li>
<li>语言按键（例如，JIS PC键盘上的无变换、变换、片假名键）</li>
<li>应用程序启动键</li>
</ul>
</li>
</ul>
</li>
<li><p>当前限制：</p>
<ul>
<li>由于macOS API的限制，Karabiner-Elements无法修改某些键盘（例如，Apple有线键盘）上的弹出键。</li>
<li>Karabiner-Elements无法修改非Apple键盘（例如Logitech键盘）上的fn键。</li>
<li>Karabiner-Elements忽略了系统设置 &gt; 键盘 &gt; 键盘快捷键… &gt; 修饰键配置。</li>
<li>通过使用简单修改来更改修饰键。（输入事件修改链的详细信息）</li>
</ul>
</li>
</ul>
<h3 id="看下游戏手柄在CT扫描下的结构"><a href="#看下游戏手柄在CT扫描下的结构" class="headerlink" title="看下游戏手柄在CT扫描下的结构"></a><a href="https://www.scanofthemonth.com/scans/gamepads">看下游戏手柄在CT扫描下的结构</a></h3><p>这个网页对于史上最著名的几个手柄：任天堂SNES，索尼PS5手柄，XBOX手柄进行了透视扫描，看到这些手柄精密的内部结构，让人不得不感叹工业之美，机械之美。这里简单看下NES手柄的介绍。</p>
<ul>
<li><p>1985年，任天堂通过标志性的矩形任天堂娱乐系统（NES）手柄，确立了游戏手柄的蓝本。该手柄配备了一个方向键（d-pad）和用于启动、选择、A和B的按钮。30年后，任天堂在switch上又推出了一款复刻版的NES手柄。让我们看下这两者的不同。</p>
</li>
<li><p>上面的1985年版的，下面的switch版，外形几乎没有两样。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/controller1.png"></p>
</li>
<li><p>Switch手柄的电路板具有更细的线路，密集的元件布局以及更复杂的布线，以适应手柄增加的功能和高级特性，例如与Switch主机之间的电池供电的无线连接。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/controller2.png"></p>
</li>
<li><p>Switch手柄具有更先进的连接接口。在左侧，我们看到了一种球栅阵列（BGA），这是一种用于集成电路的表面贴装封装。BGA提供了一种更紧凑和高效的方式来连接微控制器和电路板，使得连接密度更高。在BGA的右侧是一种用于一些集成电路的四边平封装（QFP）。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/controller3.png"></p>
</li>
<li><p>手柄电缆通过焊接的5针接头连接到原始SNES游戏手柄电路板的背面。这个焊接接头确保了导线和电路板之间的安全可靠的电气连接。新的手柄采用了与Switch Joy-Con内部相同的锂离子电池。电池在Switch上可以持续使用长达20小时。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/controller4.png"></p>
</li>
</ul>
<h3 id="当一个app的服务器只部署在美国东部"><a href="#当一个app的服务器只部署在美国东部" class="headerlink" title="当一个app的服务器只部署在美国东部"></a><a href="https://blog.jonlu.ca/posts/us-east-1-latency">当一个app的服务器只部署在美国东部</a></h3><p>us-east-1（位于弗吉尼亚州的“Centreville”附近）是由AWS运营的主要数据中心之一。</p>
<p>如果是一家初创公司（甚至是一些成熟的公司），很可能会在这里部署应用程序。如果是一个有状态的服务，或者架构不支持分布式计算，很可能只会在此处部署。这种时候如果用户在澳大利亚的悉尼，那么发起的任何网络请求都需要经过15,677公里直线距离上的传输。<br><img src="/2023/07/04/2023/07/daily-tech-blog-collection-20230704/latency1.webp"></p>
<p>而这个距离即使在光速下也需要104ms才能达到。而在现实中，需要考虑其他干扰，其他流量和处理请求所花费的时间，基本上需要215ms左右。</p>
<p>对于许多网站来说，可能会有几十个请求到不同的域，并且每个请求都需要建立和终止连接。这意味着更多的时间处理。</p>
<p>完整的TLS 1.2握手需要完成2次往返，当与TCP的SYN和SYN-ACK协商结合在一起时，它将扩展到3个完整的往返。虽然TLS 1.3在TCP下将其减少为两个往返，但仍会给每个连接增加相当大的延迟。</p>
<p>当你意识到许多请求是链接在一起的，或者彼此依赖时，问题就变得更加复杂。例如，在CSS文件中的图像只能在CSS文件被下载后才能请求，而CSS文件本身只能在浏览器解析HTML后才能下载。HTTP/2及其多路复用可以改善这个问题，但并不能完全解决——每个请求可能托管在不同的域上，或者占用浏览器的最大并发连接数。</p>
<p>协议的改进也不能解决网站架构的根本问题——如果你的SPA（单页应用程序）没有得到适当的优化，浏览器需要先下载所有内容，然后执行JavaScript代码，只有在JavaScript执行完毕后，才开始进行API请求和获取用于填充页面内容的资源。</p>
<p>这就是级联的延迟地狱。综合起来，这可能会给一个简单的网站增加数千毫秒的加载时间。</p>
<p>在尝试为性能优化网页和API响应花费了很多时间后，我对延迟有了一个相当准确的内部模型。当我在纽约和旧金山之间时，我无法完全察觉到us-east-1服务器之间的区别，但当我在意大利时，我绝对可以感觉到是否部署了eu-central-1的实例，或者当我在悉尼时，是否部署了ap-east-1的实例。在原生应用程序中更容易察觉，因为界面反应更加迅速，唯一的变量就是API请求的持续时间。当你在列表上进行下拉刷新时，它会比你习惯的时间稍微停顿一下。</p>
<p>使用全球CDN可以帮助更快地将资源提供给用户，大多数公司现在都使用类似Cloudflare或Vercel的服务，但仍然只通过静态或缓存内容提供服务。很多时候，源服务器仍然是部署在单个位置的集中式巨型服务器，或者只有一个数据库集群。</p>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230706</title>
    <url>/2023/07/06/2023/07/daily-tech-blog-collection-20230706/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h3 id="程序员如何在chatGPT的世界中生存下来"><a href="#程序员如何在chatGPT的世界中生存下来" class="headerlink" title="程序员如何在chatGPT的世界中生存下来"></a><a href="https://spectrum.ieee.org/ai-programming">程序员如何在chatGPT的世界中生存下来</a></h3><p>人工智能，尤其是由大型语言模型（LLM）驱动的生成式人工智能，可能会颠覆许多程序员的职业生涯。然而，“你必须担心那些使用人工智能来替代你的人“，在似乎即将到来的以大型语言模型为核心的编码时代，程序员该如何生存和发展呢？</p>
<h4 id="坚持基础知识和最佳实践"><a href="#坚持基础知识和最佳实践" class="headerlink" title="坚持基础知识和最佳实践"></a>坚持基础知识和最佳实践</h4><p>尽管有众多基于人工智能的编码助手可以帮助完成代码和生成代码，但编程的基本原则仍然存在：能够阅读和理解自己和他人的代码，以及了解所编写的代码如何融入更大的系统中。</p>
<p>程序员仍然需要具备对代码进行分析和调试的能力，以及对问题解决和算法设计的理解。</p>
<p>问题解决仍然是最重要的编程技能之一，仍然属于人类编程人员的领域。分析问题并找到优雅的解决方案仍然是备受推崇的编程专长。</p>
<blockquote>
<p>不要陷入将自己与人工智能进行比较的陷阱，人工智能本质上是大型模型的统计输出。开发者的工作与模型的输出有所不同——成为一名开发者不仅仅是编写多少行的代码。—————— Explosion公司的联合创始人兼首席执行官Ines Montani</p>
</blockquote>
<p>问题解决能力是一个综合的技能，它要求编程人员具备分析能力、创造力和逻辑思维。通过理解问题、拆解问题、设计算法以及实施和测试解决方案，人类编程人员能够提供独特的洞察力和创造性解决方案，而这些是人工智能无法完全取代的。因此，继续培养和发展问题解决能力对于在人工智能时代中成为优秀的开发者至关重要。</p>
<span id="more"></span>

<h4 id="找到满足你需求的工具"><a href="#找到满足你需求的工具" class="headerlink" title="找到满足你需求的工具"></a>找到满足你需求的工具</h4><p>寻找合适的基于人工智能的工具非常重要。每个工具都有自己的交互方式，并且有不同的方法将每个工具纳入你的开发工作流程中，无论是自动化创建单元测试、生成测试数据还是编写文档。</p>
<p>例如，GitHub Copilot和其他人工智能编码助手可以增强编程过程，提供代码建议。而ChatGPT和谷歌的Bard则更像是对话式人工智能程序员，可以用于回答关于API（应用程序编程接口）的问题或生成代码片段。</p>
<p>诀窍在于进行实验。尝试使用人工智能工具，了解其工作方式，考虑其输出的质量，但也要对其他工具保持开放的态度。“人工智能是一个发展迅速的领域。你不想只固守一个工具然后用它一辈子，所以你需要快速适应新的工具，”阿布拉罕表示。</p>
<p>同时，要考虑适当的使用场景。生成式人工智能工具可以为学习新的编程语言或框架提供快捷途径，也可以更快地启动小型项目并创建原型。</p>
<h4 id="清晰而准确的对话是关键"><a href="#清晰而准确的对话是关键" class="headerlink" title="清晰而准确的对话是关键"></a>清晰而准确的对话是关键</h4><p>当使用人工智能编码助手时，详细说明你的需求，并将其视为一个迭代的过程。阿布拉罕建议编写一条注释，解释你想要的代码，这样助手就可以生成符合你要求的相关建议。</p>
<p>对于对话式人工智能程序员，你需要知道如何最好地表达你的提示。这就是提示工程的作用所在。</p>
<p>阿布拉罕提出的一种方法是思维链提示。这涉及到将一个问题分解为多个步骤，并逐个解决每个步骤以解决整个问题的分而治之策略。“在同一时间要求模型完成过多任务可能导致灾难。你希望它能够处理可管理的信息块并生成可管理的代码块，”他说。</p>
<p>例如，不要要求AI程序员从零开始编写整个程序，而是考虑程序试图完成的不同任务。将这些任务进一步细分，并要求模型为每个任务编写特定的函数。你可能需要与模型推理关于实现任务所需的步骤，从而进行反复的交流对话。</p>
<p>“将其几乎视为一个对某个主题了解很多但经验不那么丰富的聪明实习生，”阿布拉罕说道。</p>
<p>提示工程需要准确和清晰。 “你需要非常清楚地告诉模型你想要什么，对你要求它做的事情非常精确，并确保你进行跟进，”阿布拉罕表示。</p>
<p>学习人工智能和机器学习的基本概念，了解大型语言模型的工作原理以及它们的优势和局限性也是有价值的。你不需要深入研究，但具备一些基本知识可以为你提供重要的结果背景。</p>
<p>为了帮助你入门，阿布拉罕推荐了OpenAI Cookbook，其中包含有关提示库和工具、提示指南以及视频课程的部分，而Vaithilingam则建议阅读《Illustrated Transformer》以了解更多关于模型和机器学习基础知识的内容。</p>
<h4 id="保持批判思维并了解风险"><a href="#保持批判思维并了解风险" class="headerlink" title="保持批判思维并了解风险"></a>保持批判思维并了解风险</h4><p>作为软件工程师，对于大型语言模型的输出应该保持批判性，因为它们往往会产生虚构的、不准确或错误的代码。Vaithilingam表示：“当盲目使用由AI生成的代码时，很容易陷入调试的兔子洞，而微妙的错误可能很难发现。”</p>
<p>这就是为什么检查生成的代码至关重要，尽管这增加了额外的步骤，可能会对生产力造成不利影响。但是Abraham认为，“在某些情况下，验证代码比从头编写代码更容易，并且在将其纳入你的代码库之前生成和验证的方法更快。”</p>
<p>值得思考的是，对这些模型的输出进行评估时需要考虑以下问题：这个模型是基于什么样的训练数据？哪些数据被筛选出来并未包含在其中？训练数据的年代如何，模型是在哪个版本的编程语言、软件包或库上进行训练的？这些问题的答案可能会对结果产生影响，并提供更多的背景信息。</p>
<p>开发人员还应谨慎将专有代码输入到这些模型中。一些公司，如Tabnine，提供其AI编码助手的企业版，可以在学习组织的编码模式和风格的同时保护隐私。</p>
<p>因此，在使用由大型语言模型生成的代码时，要保持批判性思维，仔细检查和验证结果，并对其进行评估。了解模型的训练数据、限制和潜在的偏见，并谨慎处理保护私密代码和数据的问题，可以帮助开发人员更好地应用这些AI工具，并最大程度地发挥其潜力。</p>
<p>版权是另一个需要考虑的因素，尽管如果你使用这些工具来完成几行代码或生成用于常见或琐碎任务的代码，与生成更大的代码块相比，版权问题可能不太令人担忧。</p>
<p>“程序员应该对他们所做的事情有一定的原创性和在其特定上下文中的独特性有所了解，”Solar-Lezama说道。“如果模型生成了一段相对独特的代码，重要的是在将其纳入生产代码库之前要持怀疑和怀疑的态度。”</p>
<p>更大的问题是安全性，因为这些模型可能生成包含漏洞的代码。根据Vaithilingam的说法，软件开发的最佳实践，如代码审查和强大的测试流程，可以帮助防范这种风险。</p>
<p>“更有经验的软件工程师能够意识到代码中最常见的漏洞和代码容易受到攻击的方式，”Solar-Lezama说道。“他们对需要注意的事项和引起警觉的标志有着直觉。在未来，这些技术将成为软件工程的重要组成部分。”</p>
<p><strong>为了在生成式人工智能的世界中生存，程序员需要将AI作为一种工具，将其纳入他们的工作流程，并认识到这些工具的机遇和局限性，同时仍然依靠他们的人类编码能力来取得成功。</strong></p>
<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="圣保罗：一座没有户外广告的城市"><a href="#圣保罗：一座没有户外广告的城市" class="headerlink" title="圣保罗：一座没有户外广告的城市"></a><a href="https://www.amusingplanet.com/2013/07/sao-paulo-city-with-no-outdoor.html">圣保罗：一座没有户外广告的城市</a></h3><p><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/adremove1.jpeg"><br>在2006年，圣保罗市长宣布了一项“城市清洁法令“，要求移除所有的户外广告，包括广告牌、交通工具上的广告以及商店门前的广告。一年之内，有15000个广告牌被拆除，商店标识也必须缩小，以避免违反新法。</p>
<p>这在当时引起反对，主要理由是：</p>
<ul>
<li>这将直接导致大约1.3亿美元的损失，2万人将会失业。</li>
<li>广告也是某种艺术形式，去除广告使得城市景色非常单调。</li>
</ul>
<p>尽管人们预感到不祥的情绪，但圣保罗的经济并未因此崩溃。</p>
<p>在2011年对该市1100万居民进行的一项调查中，有70%的人认为这项禁令是有益的。意外的是，标志和口号的去除使得之前被忽视的建筑暴露出来，展示了长期以来被隐藏的丰富城市美景。</p>
<p><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/adremove2.jpeg"><br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/adremove3.jpeg"></p>
<h3 id="IMY禁止四家公司使用Google-Analytics"><a href="#IMY禁止四家公司使用Google-Analytics" class="headerlink" title="IMY禁止四家公司使用Google Analytics"></a><a href="https://www.imy.se/en/news/four-companies-must-stop-using-google-analytics/">IMY禁止四家公司使用Google Analytics</a></h3><p>瑞典隐私保护机构（IMY）对四家公司通过Google Analytics向美国转移个人数据的做法进行了审计。接受审计的公司是CDON、Coop、Dagens Industri和Tele2。</p>
<p>根据数据保护条例GDPR，如果欧洲委员会决定某个第三国（即欧盟/欧洲经济区之外的国家）具有与欧盟/欧洲经济区内相应的个人数据保护水平，个人数据可以转移至该第三国。然而，CJEU在Schrems II判决中裁定，<strong>美国在判决时并不具备这样的适当保护水平。</strong></p>
<p>在其审计中，IMY认为通过Google的统计工具转移至美国的数据属于个人数据，因为这些数据可以与其他传输的唯一数据相关联。该机构还得出结论，这些公司采取的技术安全措施不足以确保与欧盟/欧洲经济区内的保护水平基本相当。</p>
<p>根据IMY的审计结果，似乎这些公司的额外技术安全措施都不足够。</p>
<p>Tele2最近自愿停止使用该统计工具。IMY要求其他三家公司停止使用该工具。</p>
<h3 id="Bottles：在linux上运行windows软件"><a href="#Bottles：在linux上运行windows软件" class="headerlink" title="Bottles：在linux上运行windows软件"></a><a href="https://usebottles.com/">Bottles：在linux上运行windows软件</a></h3><p>Bottles是一个应用程序，它可以在Linux发行版上轻松管理Windows前缀（windows prefix：一种bottles中的概念，可以看成容器）。<br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/bottles1.png"></p>
<ul>
<li>安装：目前仅支持<a href="https://flatpak.org/setup/">flatpak</a>（大致介绍下，这是一种包管理工具，可以解决包依赖的问题，以及沙盒环境下的运行）的安装。有几种安装方式。<ul>
<li>从<a href="https://flathub.org/apps/com.usebottles.bottles">flathub</a>安装。</li>
<li>安装beta版本，安装命令：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flatpak remote-add --user flathub-beta https://flathub.org/beta-repo/flathub-beta.flatpakrepo</span><br><span class="line">flatpak update --appstream</span><br><span class="line">flatpak install --user flathub-beta com.usebottles.bottles</span><br></pre></td></tr></table></figure></li>
<li>手动安装<ul>
<li>依赖<ul>
<li>org.gnome.Sdk</li>
<li>org.gnome.Sdk.Compat.i386</li>
<li>org.freedesktop.Sdk.Extension.toolchain-i386</li>
</ul>
</li>
<li>安装命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 下载压缩包并解压</span></span><br><span class="line">wget -O bottles-source.zip https://github.com/bottlesdevs/Bottles/archive/main.zip</span><br><span class="line">unzip bottles-source.zip</span><br><span class="line"><span class="built_in">cd</span> Bottles-main</span><br><span class="line"><span class="comment">### flatpak-builder需要先从apt等命令中安装完成</span></span><br><span class="line">flatpak-builder --repo=bottles --force-clean --user build-dir com.usebottles.bottles.yml</span><br><span class="line">flatpak remote-add --user bottles bottles --no-gpg-verify</span><br><span class="line">flatpak install --user bottles com.usebottles.bottles</span><br><span class="line">flatpak run com.usebottles.bottles</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>运行<ul>
<li>初次运行会出现一个界面介绍bottles的几个概念。</li>
<li>随后会下载一个大约70mb大小的内容用于构建bottles，一些<a href="https://github.com/bottlesdevs/components">必要组件</a>会下载到库中。</li>
<li>每个文件都会通过仓库的校验和进行检查，如果检查失败，文件将被删除，安装也将失败。</li>
<li>安装完成需要一定的时间，完成后就可以根据提示创建bottles和安装windows软件。<br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/bottles2.png"><br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/bottles3.png"><br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/bottles4.png"></li>
</ul>
</li>
</ul>
<h3 id="Makie：用于Julia的现代绘图库"><a href="#Makie：用于Julia的现代绘图库" class="headerlink" title="Makie：用于Julia的现代绘图库"></a><a href="https://makie.org/">Makie：用于Julia的现代绘图库</a></h3><p>Makie是基于<a href="https://julialang.org/">Julia</a>开发的绘图工具，等等，Julia又是啥？我找了freecodecamp上的一篇<a href="https://www.freecodecamp.org/news/applications-of-julia/">Julia的简短介绍</a>。</p>
<blockquote>
<p>Julia是一种高级、高性能的动态编程语言。它结合了像Python这样的脚本语言的易用性和C/C++等编译语言的速度和效率。比较多的用于机器学习，数据分析，图形化等专业领域。</p>
</blockquote>
<p>说回Makie，它可以在多个专业领域构建炫酷的数据图形。<br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/makie1.png"></p>
<p>主要功能特点：</p>
<ul>
<li>手术级的更新和高性能：Makie使用<a href="https://github.com/JuliaGizmos/Observables.jl">Observables.jl</a>（Julia的一个开源库）在给定时间点上只更新必要的内容。通过调整颜色映射来为数十万个点创建动画，每帧只在GPU上直接修改少量字节。</li>
<li>强大的布局系统：与其他绘图库相比，Makie拥有最强大的布局系统之一，允许您微调任何可能的属性并自由地放置您的图表和子图。</li>
<li>2D、3D、体数据、网格、滑动条、按钮等各种样式的图形：Makie支持各种基本元素，用于交互式数据探索。这使得快速构建适用于各种数据的仪表板变得简单。</li>
<li>强大的事件系统和渲染引擎：Makie虽然并非游戏引擎，但其丰富的渲染和交互功能使得创建简单的交互式游戏（如Minecraft）成为可能。</li>
</ul>
<h3 id="地球上有多少人曾经存在过？"><a href="#地球上有多少人曾经存在过？" class="headerlink" title="地球上有多少人曾经存在过？"></a><a href="https://prb.org/articles/how-many-people-have-ever-lived-on-earth/">地球上有多少人曾经存在过？</a></h3><blockquote>
<p>全球人口达到80亿这一里程碑，相当于地球上曾经存在过的总人口数量的近7%。</p>
</blockquote>
<p>对曾经存在过的总人口数量的任何估计基本上取决于三个因素：</p>
<ul>
<li>人类被认为在地球上存在的时间长度。</li>
<li>不同时期的人口平均规模。</li>
<li>每个时期每1000人口的出生人数。</li>
</ul>
<p>根据这些指标得出的人类在各个时期的总人口表如下，其中还包括到2050年的预测：<br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/people1.png"></p>
<p>人类历史上，出生时的平均预期寿命可能只有约10岁左右。这种较短的预期寿命意味着人类的人口增长困难重重。</p>
<p>公元14年时，罗马帝国的人口估计达到4500万，涵盖了西班牙到小亚细亚。</p>
<p>到1650年，世界人口增长到约5亿，与公元1年的3亿估计相比，并没有大幅增长。</p>
<p>到1800年，世界人口超过了10亿，此后持续增长到目前的80亿人（截至2022年的最新估计）。这种增长在很大程度上是由公共卫生、医学和营养的进步推动的，降低了死亡率，使更多的人能够活得更久，并进入繁殖年龄。</p>
<p>对曾经出生的人口数量进行估算需要确定人类史前和历史不同时期的人口规模，并将假设的出生率应用于每个时期。</p>
<p>这种半科学的方法得出的估计结果是，<strong>自现代人类出现以来大约有1170亿次出生。</strong><br><img src="/2023/07/06/2023/07/daily-tech-blog-collection-20230706/people2.png"></p>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>旁路由入门-iStoreOS实现局域网科学上网</title>
    <url>/2023/07/06/2023/07/bridge-mode-starter-istoreos/</url>
    <content><![CDATA[<h2 id="什么是旁路由？"><a href="#什么是旁路由？" class="headerlink" title="什么是旁路由？"></a>什么是旁路由？</h2><blockquote>
<p>旁路由： 旁路由其实并不是路由，路由是用来连接不同网络的，最常用的就是用来连接互联网和局域网。旁路由起到的主要是网关的作用，是用来分流数据和扩展插件的。因此，严谨一点的叫法应该是<strong>旁路网关</strong>，只是大家好像约定俗成了都叫做旁路由，所以我们这里也跟着叫旁路由，但是要明白它的核心是网关而不是路由。</p>
</blockquote>
<p><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge1.png"></p>
<blockquote>
<p>如图所示，对于普通流量，由于旁路由不修改任何内容，我们期望旁路由只转发上行数据，而下行数据由主路由直接发送给主机。对于需要代理的流量，则下行数据也得交给旁路由处理，然后才能转发给主机。</p>
</blockquote>
<span id="more"></span>
<h2 id="为什么用旁路由？"><a href="#为什么用旁路由？" class="headerlink" title="为什么用旁路由？"></a>为什么用旁路由？</h2><p>其实正常来讲，旁路由并不是成本最低最简单的局域网设备科学上网的方法。</p>
<p>成本最低的方法，简单一句话就讲完了：在局域网内的一台电脑上装一个clash，并打开[允许局域网连接]，然后配置一下需要科学上网设备的代理，就可以轻松实现局域网设备的科学上网。</p>
<p>但是，有些坑爹的设备没有代理设置，比如Apple TV，就不能通过我说的简单方式来解决（严格来说，也不是不能解决，youtube上有教程，但是得通过一台常开机的苹果电脑，这个门槛略高）。</p>
<h2 id="旁路由科学上网的前提准备"><a href="#旁路由科学上网的前提准备" class="headerlink" title="旁路由科学上网的前提准备"></a>旁路由科学上网的前提准备</h2><ul>
<li>一台可以刷istoreos的设备用来当作旁路由，这里是<a href="https://doc.linkease.com/zh/guide/istoreos/storeos_hardware.html#%E6%94%AF%E6%8C%81%E7%A1%AC%E4%BB%B6">硬件列表</a>，其中x86设备就是指一般的电脑，我用的就是一台不用的笔记本。别的树莓派什么的都大同小异。</li>
<li>一个至少2g的u盘用来刷进istoreos固件。</li>
<li>一个能用来科学上网的机场，这个就不展开说了。</li>
</ul>
<h2 id="iStoreOS安装到笔记本"><a href="#iStoreOS安装到笔记本" class="headerlink" title="iStoreOS安装到笔记本"></a>iStoreOS安装到笔记本</h2><h3 id="iStoreOS说明"><a href="#iStoreOS说明" class="headerlink" title="iStoreOS说明"></a><a href="https://www.istoreos.com/">iStoreOS说明</a></h3><p>这是一个国产的开源项目，基于openwrt开发，主打一个简单易用。我体验过来也确实如此，openwrt的教程看了十几个都是云里雾里，而istoreos的教程只看了一个就搞定了，非常适合初学者来使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于我用的是笔记本，所以下面就是以x86设备来说明。</p>
<ul>
<li>下载固件：<a href="https://fw.koolcenter.com/iStoreOS/">下载地址</a>。</li>
<li>这里有两种x86的固件，x86_64_efi和x86_64，这里主要是分别针对uefi和bios启动方式的电脑，可以看下<a href="https://www.zhihu.com/question/21672895">知乎的这篇问答</a>，介绍了两者的区别。<strong>注意，uefi引导方式的电脑要下载x86_64_efi版本，bios引导方式的电脑要下载x86_64版本</strong>，如何判断：<ul>
<li>Win + R 快捷键调出“运行”对话框，输入“msinfo32”，确定</li>
<li>在“系统摘要”的右侧窗口中即可看到“BIOS模式”信息，如果显示的是“传统”，即为BIOS启动方式；如果显示的是“UEFI”，则为UEFI启动方式。<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge2.png"></li>
</ul>
</li>
<li>电脑上用rufus 做 USB 启动盘，<a href="https://rufus.ie/zh/">Rufus下载</a>，将刚刚下载的固件刷到U盘。<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge3.png"></li>
<li>把U盘接入X86机器，从bios选择启动盘为U盘。</li>
<li>等待一系列刷屏后，出现欢迎界面，回车，然后键入quickstart。</li>
<li>选择Install X86。<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge4.png"></li>
<li>系统写入完成后，拔掉外接设备(U盘/键盘等)，通电启动。</li>
<li>将笔记本电脑的网口用网线连接到你局域网内主路由设备的lan口。</li>
</ul>
<h3 id="可能的坑"><a href="#可能的坑" class="headerlink" title="可能的坑"></a>可能的坑</h3><ul>
<li>从u盘安装到目标电脑之后重启，如果出现下面这样的报错，说明你安装错了固件，换成x86_64_efi或者x86_64<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">XZ-compressed data is corrupt</span><br><span class="line"></span><br><span class="line">– System halted</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="后台管理配置"><a href="#后台管理配置" class="headerlink" title="后台管理配置"></a>后台管理配置</h2><p>直接访问电脑安装的ip地址，就可以看到如下画面。<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge5.png"></p>
<h3 id="配置istoreos联网"><a href="#配置istoreos联网" class="headerlink" title="配置istoreos联网"></a>配置istoreos联网</h3><p>此时，istoreos还未联网，需要进行配置。点击网络向导，选择旁路由设置。<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge6.png"></p>
<p>按照提示填入静态IP，主路由IP，<strong>DNS服务器也要填写为主路由IP。</strong><br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge7.png"></p>
<h3 id="安装passwall"><a href="#安装passwall" class="headerlink" title="安装passwall"></a>安装passwall</h3><ul>
<li>istoreos自带的istore没有自带passwall，去往<a href="https://github.com/AUK9527/Are-u-ok">github下载的Are-u-ok</a>下载。</li>
<li>选择x86_64平台</li>
<li>下载passwall</li>
<li>这是一个run后缀的包，打开istore，选择手动安装<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge8.png"></li>
<li>选择run包，就会自动跳出命令行界面进行安装</li>
<li>等待右上角原点变绿之后就安装完成</li>
</ul>
<h3 id="配置passwalll"><a href="#配置passwalll" class="headerlink" title="配置passwalll"></a>配置passwalll</h3><ul>
<li>在istoreos后台的服务或者VPN界面可以找到刚刚安装的passwall<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge9.png"></li>
<li>选择节点订阅，选择添加<br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge10.png"></li>
<li>在该页面中粘贴机场网址后点击保存并应用</li>
</ul>
<h3 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h3><ul>
<li>istoreos的后台点击网络-防火墙</li>
<li>在常规设置里，入站数据，出站数据，转发这三个选项都选择<strong>接受</strong><br><img src="/2023/07/06/2023/07/bridge-mode-starter-istoreos/bridge11.png"></li>
<li>在自定义规则里，添加一行<code>iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</code></li>
</ul>
<h2 id="上网设备配置走旁路由"><a href="#上网设备配置走旁路由" class="headerlink" title="上网设备配置走旁路由"></a>上网设备配置走旁路由</h2><ul>
<li>修改ipv4为手动，ip地址填入和旁路由同一网段的ip，子网掩码填255.255.255.0</li>
<li>修改路由器为旁路由IP</li>
<li>添加DNS为旁路由IP</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>旁路由</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>每日文章收集-20230707</title>
    <url>/2023/07/07/2023/07/daily-tech-blog-collection-20230707/</url>
    <content><![CDATA[<h1 id="【今日关注】"><a href="#【今日关注】" class="headerlink" title="【今日关注】"></a>【今日关注】</h1><h2 id="node-crawler：NodeJS端的网络爬虫框架"><a href="#node-crawler：NodeJS端的网络爬虫框架" class="headerlink" title="node-crawler：NodeJS端的网络爬虫框架"></a><a href="https://github.com/bda-research/node-crawler">node-crawler：NodeJS端的网络爬虫框架</a></h2><p>NodeJS端最强大，最受欢迎的爬虫包。主要Feature：</p>
<ul>
<li>服务器端DOM和自动插入jQuery使用Cheerio（默认）或JSDOM，</li>
<li>可配置的连接池大小和重试次数，</li>
<li>控制请求速率限制，</li>
<li>请求的优先级队列，</li>
<li>forceUTF8模式可让网络爬虫处理字符集的检测和转换，</li>
<li>与4.x或更新版本兼容。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install crawler</span><br></pre></td></tr></table></figure>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Crawler = <span class="built_in">require</span>(<span class="string">&#x27;crawler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个爬虫</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">    <span class="attr">maxConnections</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 每个页面都会调下列回调方法</span></span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">error, res, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> $ = res.$;</span><br><span class="line">            <span class="comment">// 获取页面元素</span></span><br><span class="line">            <span class="built_in">console</span>.log($(<span class="string">&#x27;title&#x27;</span>).text());</span><br><span class="line">        &#125;</span><br><span class="line">        done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定目标网址，单个网址</span></span><br><span class="line">c.queue(<span class="string">&#x27;http://www.amazon.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定目标网址，多个网址</span></span><br><span class="line">c.queue([<span class="string">&#x27;http://www.google.com/&#x27;</span>,<span class="string">&#x27;http://www.yahoo.com&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定网址并调用自定义回调方法</span></span><br><span class="line">c.queue([&#123;</span><br><span class="line">    <span class="attr">uri</span>: <span class="string">&#x27;http://parishackers.org/&#x27;</span>,</span><br><span class="line">    <span class="attr">jQuery</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将不会调用全局回调方法</span></span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">error, res, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Grabbed&#x27;</span>, res.body.length, <span class="string">&#x27;bytes&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接解析html源代码（多用于测试）</span></span><br><span class="line">c.queue([&#123;</span><br><span class="line">    <span class="attr">html</span>: <span class="string">&#x27;&lt;p&gt;This is a &lt;strong&gt;test&lt;/strong&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>


<h3 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h3><p>使用<code>rateLimit</code>限制爬取速度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Crawler = <span class="built_in">require</span>(<span class="string">&#x27;crawler&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设定两次爬取的间隔，毫秒为单位</span></span><br><span class="line"><span class="comment">     * 这个参数一旦设定，`maxConnections`会被强制设定为1</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="attr">rateLimit</span>: <span class="number">1000</span>, </span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">err, res, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.$(<span class="string">&#x27;title&#x27;</span>).text());</span><br><span class="line">        done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c.queue(tasks);</span><br></pre></td></tr></table></figure>

<h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>当需要从前一个请求或响应中获取参数时，可以通过options来传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c.queue(&#123;</span><br><span class="line">    <span class="attr">uri</span>: <span class="string">&#x27;http://www.google.com&#x27;</span>,</span><br><span class="line">    <span class="attr">parameter1</span>: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">    <span class="attr">parameter2</span>: <span class="string">&#x27;value2&#x27;</span>,</span><br><span class="line">    <span class="attr">parameter3</span>: <span class="string">&#x27;value3&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>随后在回调函数中通过<code>res.options</code>来获取该参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(res.options.parameter1);</span><br></pre></td></tr></table></figure>

<p>crawler只会将必要的参数通过options传递，所以不用担心冗余。</p>
<h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>如果是下载文件的请求，比如图片，文档，pdf等，你需要让crawler不要将响应数据转换为string类型，这时将<code>encoding</code>参数设置为null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Crawler = <span class="built_in">require</span>(<span class="string">&#x27;crawler&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">    <span class="attr">encoding</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">jQuery</span>: <span class="literal">false</span>,<span class="comment">// set false to suppress warning message.</span></span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">err, res, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fs.createWriteStream(res.options.filename).write(res.body);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c.queue(&#123;</span><br><span class="line">    <span class="attr">uri</span>: <span class="string">&#x27;https://nodejs.org/static/images/logos/nodejs-1920x1200.png&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;nodejs-1920x1200.png&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="预请求-preRequest"><a href="#预请求-preRequest" class="headerlink" title="预请求(preRequest)"></a>预请求(preRequest)</h3><p>如果您希望在每个请求之前以同步或异步方式执行某些操作，可以尝试下面的代码。请注意，直接的请求不会触发 preRequest。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">    <span class="attr">preRequest</span>: <span class="function">(<span class="params">options, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的“options”不是你传递给“c.queue”的“options”，而是将要传递给“request”模块的</span></span><br><span class="line">        <span class="built_in">console</span>.log(options);</span><br><span class="line">    	<span class="comment">// done方法后，request请求就会开始</span></span><br><span class="line">    	done();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">callback</span>: <span class="function">(<span class="params">err, res, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    	    <span class="built_in">console</span>.log(err);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    <span class="built_in">console</span>.log(res.statusCode);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c.queue(&#123;</span><br><span class="line">    <span class="attr">uri</span>: <span class="string">&#x27;http://www.google.com&#x27;</span>,</span><br><span class="line">    <span class="comment">// 在这里定义的preRequest会覆盖掉在Crawler里定义的preRequst</span></span><br><span class="line">    <span class="attr">preRequest</span>: <span class="function">(<span class="params">options, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    	    <span class="built_in">console</span>.log(options);</span><br><span class="line">    	    done();</span><br><span class="line">    	&#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="【博文一览】"><a href="#【博文一览】" class="headerlink" title="【博文一览】"></a>【博文一览】</h1><h3 id="InternLM：70亿参数的新开源大语言模型"><a href="#InternLM：70亿参数的新开源大语言模型" class="headerlink" title="InternLM：70亿参数的新开源大语言模型"></a><a href="https://github.com/InternLM/InternLM">InternLM：70亿参数的新开源大语言模型</a></h3><p>这是一个国产的大语言模型，中文名叫书生·浦语。以下均来自github的介绍。</p>
<p>InternLM ，即书生·浦语大模型，包含面向实用场景的70亿参数基础模型与对话模型 （InternLM-7B）。模型具有以下特点：</p>
<ul>
<li>使用上万亿高质量预料，建立模型超强知识体系；</li>
<li>支持8k语境窗口长度，实现更长输入与更强推理体验；</li>
<li>通用工具调用能力，支持用户灵活自助搭建流程；<br>提供了支持模型预训练的轻量级训练框架，无需安装大量依赖包，一套代码支持千卡预训练和单卡人类偏好对齐训练，同时实现了极致的性能优化，实现千卡训练下近90%加速效率。</li>
</ul>
<p>开源评测工具 OpenCompass 从学科综合能力、语言能力、知识能力、推理能力、理解能力五大能力维度对InternLM开展全面评测，部分评测结果如下表所示。<br><img src="/2023/07/07/2023/07/daily-tech-blog-collection-20230707/internalLM1.png"></p>
<h3 id="Evernote已经几乎解雇了所有的员工"><a href="#Evernote已经几乎解雇了所有的员工" class="headerlink" title="Evernote已经几乎解雇了所有的员工"></a><a href="https://news.ycombinator.com/item?id=36609641">Evernote已经几乎解雇了所有的员工</a></h3><p>Evernote在中国的名字是大名鼎鼎的“印象笔记”，大部分人可能都用过，太久没打开过印象笔记，我都快忘了这个软件，如今却听到了它的这么一个不好的消息。</p>
<p>如今其收购者（Bending Spoons）已接管了运营。他们还提高了订阅价格，并告知客户他们打算利用新的收入来支付新功能。</p>
<p>在Hacker News上许多人对这条新闻发出感慨，摘录一些。</p>
<blockquote>
<p>我觉得Evernote是试图将免费用户转变为付费用户，但却面临了痛苦的典型例子，这是我们在许多风险投资支持的软件中看到的情况。一旦你免费提供了某项服务，即使你像Evernote那样诚实地解释情况，也几乎不可能收回它。</p>
<p>Evernote曾经很棒。说实话，它是值得付费的。但他们过早地放弃了一切，导致用户感觉他们所拥有的东西被夺走，从而破坏了信任。Obsidian采取了最明智的策略，提供了编辑器，将文件保存在数据库之外，使其具有可移植性（这样，如果需要转移到其他平台，用户会感到安全），并告诉用户，如果他们想拥有同步功能，可以选择付费，在每个设备上获得一致的体验。 ———— <a href="https://news.ycombinator.com/user?id=belthesar">belthesar</a></p>
</blockquote>
<blockquote>
<p>我认为这是一个尝试对低价值和低成本的东西收费的例子。<br>在云端存储文本文件非常便宜。而且拥有一个方便编辑这些文件的应用程序也非常便宜。</p>
<p>一开始它是免费的，因为这是一个“经典”的软件问题，开发成本低，并且对用户来说成本接近于零。</p>
<p>当Evernote开始为无用的功能收费并锁定我的笔记时，我转而使用了众多免费、开源或非常便宜的替代品之一。</p>
<p>我认为Evernote的问题在于它应该只是一家由1-2人组成的公司。他们增加了成本，然后提高了价格，而顾客们对此并不满意。</p>
<p>这里的教训是要么做有价值的事情，要么做便宜的事情。但不要做没有价值但昂贵的事情。</p>
<p>同步是好的，但可以通过在Dropbox、iCloud或其他平台之上进行层叠来轻松实现笔记的同步。我不想要定制的Evernote同步功能，特别是不愿意为此付与Dropbox一样多的费用。我宁愿只付费使用Dropbox，然后将一堆文件放在其中。 ———— <a href="https://news.ycombinator.com/user?id=prepend">prepend</a></p>
</blockquote>
<blockquote>
<p>这就是大多数风险投资支持的创业公司的问题。你投入数百万美元用于一个实际上只是一个经过美化的CRUD服务的应用程序，却最终需要一个由500名工程师和另外3000名员工组成的团队。当真正需要盈利时，这些公司很难做到，因为他们所提供的价值主张实际上并不足够吸引人。</p>
<p>以GrubHub和DoorDash为例。一个基本的订餐系统经过美化之后，是否真的值得支付交易金额的30%作为送餐费？不值得。但必须有人来偿还数十亿美元的无用企业臃肿和数千名员工的开支。 ———— <a href="https://news.ycombinator.com/user?id=TheKarateKid">TheKarateKid</a></p>
</blockquote>
<h3 id="Godot：免费的跨平台游戏开发引擎"><a href="#Godot：免费的跨平台游戏开发引擎" class="headerlink" title="Godot：免费的跨平台游戏开发引擎"></a><a href="https://godotengine.org/">Godot：免费的跨平台游戏开发引擎</a></h3><p>Godot引擎是一个免费的、全能的跨平台游戏引擎，它使你轻松创建2D和3D游戏变得简单。<br><img src="/2023/07/07/2023/07/daily-tech-blog-collection-20230707/godot1.png"></p>
<p>主要的feature如下：</p>
<ul>
<li>Godot的节点和场景系统为您提供了强大和灵活的能力，使您能够创造任何内容。</li>
<li>简单而强大的3D：Godot的3D节点为您提供了构建、动画和渲染3D世界和角色所需的一切。</li>
<li>选择适合工作的语言：使用Godot自己的GDScript、C#、C++或使用GDExtension，使用面向对象的API使您的代码模块化。</li>
<li>在所有平台上发布：在几秒钟内将游戏部署到桌面、移动设备和Web上。Godot甚至通过第三方支持主机游戏机。</li>
<li>专注于2D引擎：使用Godot专用的2D渲染引擎和真实的2D像素坐标和2D节点，制作清晰、高性能的2D游戏。</li>
<li>开源真正开放的开发：任何为Godot做出贡献的人都能平等地受益于其他人的贡献。</li>
</ul>
<p>如果觉得虚幻引擎太过笨重的话，这个引擎看起来还挺不错的，个人感觉画面风格和游戏成品好于<a href="https://gamemaker.io/en">gamemaker</a>或者<a href="https://store.steampowered.com/app/1096900/RPG_Maker_MZ/?snr=1_5_9__300_2">RPGMaker</a>。</p>
<h3 id="关于4步文档模型的问题"><a href="#关于4步文档模型的问题" class="headerlink" title="关于4步文档模型的问题"></a><a href="https://www.hillelwayne.com/post/problems-with-the-4doc-model/">关于4步文档模型的问题</a></h3><p>什么是<a href="https://documentation.divio.com/">4步文档模型(four document model)</a>？</p>
<ul>
<li>教程：描述了如何尽快开始并运行。</li>
<li>操作说明：描述了如何完成具体任务。</li>
<li>解释：教授您已经深入了解的主题。</li>
<li>参考：描述了事物的确切含义和功能。<br><img src="/2023/07/07/2023/07/daily-tech-blog-collection-20230707/4doc1.png"></li>
</ul>
<p>这有点像在学校里教授的三段式文章：</p>
<ul>
<li>一个起始段落用于介绍背景和主要论点，</li>
<li>三个正文段落分别独立支持该论点，</li>
<li>一个结论段落用于总结论据和主要论点。</li>
</ul>
<p>而就像学生学习了三段式文章后的问题一样，4步模型会让文档编写者陷入一个“我只能用这个模型写文档”的想法。</p>
<p>实际上，这个模型至少有两个问题：</p>
<h4 id="不够通用"><a href="#不够通用" class="headerlink" title="不够通用"></a>不够通用</h4><p>在4步文档模型的官网上，给了三个典型例子用于说明其模型：</p>
<ul>
<li>the Divio Developer Handbook</li>
<li>Django’s documentation</li>
<li>django CMS’s documentation</li>
</ul>
<p>Divio和Django CMS是工具。工具和库与框架和语言不同。工具具有简单的概念模型。只需要知道它们的功能和如何使用它们。4步文档模型最适合反映工具的文档需求。</p>
<p>而Django是框架，框架比工具更高级，它们主要关注的仍然是“什么和如何”，但它们也有许多相互关联的概念需要理解。虽然它在表面上仍遵循4步文档模型，但“解释”部分的长度是教程和操作说明部分长度的三倍。同时，“解释”部分也在教授用户，这本不应该发生。</p>
<p>而如果将4步文档模型应用于编程语言，情况会更加糟糕。看一下Python文档，教程部分需要同时解释和引用，而参考资料既包含解释又包含操作说明。语言概念图太过密集，无法进行分离。</p>
<p>简而言之，4步文档模型并非普适。它是为了记录工具而设计的，无法完全满足框架和编程语言的需求。</p>
<h3 id="不够全面"><a href="#不够全面" class="headerlink" title="不够全面"></a>不够全面</h3><p>如果所有有用的文档形式都可以归为这四种类型，那么4步文档模型将是全面的。但由于与4步文档模型不普适的原因相同，这并不成立：它只涵盖了工具所需的文档形式。</p>
<p>如果你要记录一个像编程语言这样复杂的主题，至少还有两种（至少两种）其他类型的文档是你需要的：</p>
<ul>
<li>概念概述</li>
<li>代码片段和示例</li>
</ul>
<h3 id="raylib：一个简单易用的库，让您享受视频游戏编程的乐趣。"><a href="#raylib：一个简单易用的库，让您享受视频游戏编程的乐趣。" class="headerlink" title="raylib：一个简单易用的库，让您享受视频游戏编程的乐趣。"></a><a href="https://github.com/raysan5/raylib">raylib：一个简单易用的库，让您享受视频游戏编程的乐趣。</a></h3><p>raylib受到Borland BGI图形库和XNA框架的启发，特别适用于原型设计、工具开发、图形应用、嵌入式系统和教育领域。</p>
<p>主要feature：</p>
<ul>
<li>无外部依赖，所有必需的库都捆绑在raylib中</li>
<li>支持多个平台：Windows、Linux、MacOS、RPI、Android、HTML5…</li>
<li>使用普通C代码（C99）编写，使用PascalCase/camelCase表示法</li>
<li>通过OpenGL进行硬件加速（支持OpenGL 1.1、2.1、3.3、4.3或ES 2.0）</li>
<li>独特的OpenGL抽象层（可作为独立模块使用）：rlgl</li>
<li>支持多种字体格式（TTF、图像字体、AngelCode字体）</li>
<li>支持多种纹理格式，包括压缩格式（DXT、ETC、ASTC）</li>
<li>完全支持3D，包括3D形状、模型、广告牌、高度图等等</li>
<li>灵活的材质系统，支持经典贴图和PBR贴图</li>
<li>支持动画的3D模型（骨骼动画）（IQM）</li>
<li>支持着色器，包括模型和后处理着色器。</li>
<li>强大的数学模块，用于向量、矩阵和四元数操作：raymath</li>
<li>加载和播放音频，支持流媒体（WAV、OGG、MP3、FLAC、XM、MOD）</li>
<li>支持配置的VR立体渲染，包括可配置的HMD设备参数</li>
<li>庞大的示例集合，包含120多个代码示例</li>
<li>对60多种编程语言进行绑定</li>
<li>免费且开源</li>
</ul>
<p>raylib的设计是通过<a href="https://github.com/raysan5/raylib/tree/master/examples">示例</a>作为主要参考来学习。没有标准的API文档，但有一个<a href="https://www.raylib.com/cheatsheet/cheatsheet.html">速查表</a>，其中包含库中所有可用函数的简短描述，输入参数和结果值的名称应该足够直观，以便理解每个函数的工作原理。</p>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>如何通过cloudflare的worker处理复杂后台逻辑</title>
    <url>/2023/07/07/2023/07/how-to-build-project-by-cloudflare/</url>
    <content><![CDATA[<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ul>
<li>建站：一系列准备工作可看另一篇我的<a href="https://blog.cindyforever.com/2023/04/12/2023/04/how_to_create_new_site/">建站指南</a>。</li>
<li>需要本地安装node</li>
</ul>
<h2 id="新建worker"><a href="#新建worker" class="headerlink" title="新建worker"></a>新建worker</h2><ul>
<li>在cloudflare的首页，点击[Workers &amp; Pages]</li>
<li>选择[create application]</li>
<li>点击[create worker]</li>
<li>输入Name，点击Deploy</li>
</ul>
<span id="more"></span>

<h2 id="部署代码到worker"><a href="#部署代码到worker" class="headerlink" title="部署代码到worker"></a>部署代码到worker</h2><h3 id="获取API-KEY"><a href="#获取API-KEY" class="headerlink" title="获取API KEY"></a>获取API KEY</h3><ul>
<li>登录cloudflare后台，点击用户头像 -〉点击My Profile</li>
<li>选择API Tokens -〉Create Token</li>
<li>选择Edit Cloudflare Workers这一栏，点击Use template<br><img src="/2023/07/07/2023/07/how-to-build-project-by-cloudflare/APIKey.png"></li>
<li>正常情况下API权限已经按照模版配置好了，不用修改，如需微调，参考<a href="https://developers.cloudflare.com/fundamentals/api/">API文档</a></li>
<li>编辑Account Resources和Zone Resources指向你的账号和域名</li>
<li>点击Continue to summary，下一步点击Create Token</li>
<li>此时出现API token和用法示例，<strong>注意，立刻保存这个token，后续你将无法再找到</strong><br><img src="/2023/07/07/2023/07/how-to-build-project-by-cloudflare/APIToken.png"></li>
</ul>
<h3 id="安装wrangler"><a href="#安装wrangler" class="headerlink" title="安装wrangler"></a>安装wrangler</h3><p><code>wrangler</code> 是cloudflare官方的一个部署包，可以方便的将你的较复杂的后台node代码部署到指定的router上。</p>
<ul>
<li>安装命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g wrangler</span><br></pre></td></tr></table></figure></li>
<li>检查版本<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wrangler --version</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h3><p><code>wrangler</code> 有一系列的模版代码，通过命令<code>npx wrangler generate [your-app-name] [modle-name]</code>可以轻松构建一个可部署的<code>wrangler</code>项目</p>
<ul>
<li>构建router<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx wrangler generate my-app worker-router</span><br></pre></td></tr></table></figure></li>
<li>构建测速项目<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx wrangler generate my-app worker-speedtest</span><br></pre></td></tr></table></figure></li>
<li>sentry错误跟踪<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npx wrangler generate my-app mhart/cf-sentry</span><br></pre></td></tr></table></figure>
还有很多，不一一列举了，可以去<a href="https://github.com/cloudflare/workers-sdk/tree/main/templates">cloudflare的模版代码库</a>找。<br><img src="/2023/07/07/2023/07/how-to-build-project-by-cloudflare/template1.png"></li>
</ul>
<p>在初始化的项目里就可以构建你的后台逻辑了。</p>
<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><ul>
<li>在生成的<code>wrangler.toml</code>文件中，进行如下配置<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 部署的worker名称</span></span><br><span class="line">name = <span class="string">&quot;example&quot;</span></span><br><span class="line"><span class="comment">## 项目主页</span></span><br><span class="line">main = <span class="string">&quot;index.js&quot;</span></span><br><span class="line"><span class="comment">## 兼容性日期，可以不动</span></span><br><span class="line"><span class="comment">## 根据[说明](https://developers.cloudflare.com/workers/platform/compatibility-dates/)，最好实时更新到最新日期，以支持最新的cloudflare功能</span></span><br><span class="line">compatibility_date = <span class="string">&quot;2023-07-10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从cloudflare后台，进入你的网站，右下角可以看到Account ID</span></span><br><span class="line">account_id=<span class="string">&quot;your_acount_id&quot;</span></span><br><span class="line"><span class="comment"># 是否部署到cloudflare的dev域名</span></span><br><span class="line">workers_dev = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>在项目中创建<code>.env</code>文件</li>
<li>创建环境变量<code>CLOUDFLARE_API_TOKEN=&lt;YOUR_API_TOKEN_VALUE&gt;</code>，将之前获取到的API_TOKEN写入</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li>配置好上述环境变量后，就可以直接运行<code>wrangler deploy</code>进行部署</li>
<li>也可以运行<code>CLOUDFLARE_API_TOKEN=XXX wrangler deploy</code>手动指定环境变量</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>如何低成本开发并发布小程序（微信云托管+Cloudflare worker）</title>
    <url>/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/</url>
    <content><![CDATA[<p>先说结论，成本仅集中于微信云托管的费用，cloudflare全用的免费套餐。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>下面的前三步可参考我的<a href="https://blog.cindyforever.com/2023/04/12/2023/04/how_to_create_new_site/">建站指南</a>。</p>
<ul>
<li>一个Cloudflare的账户</li>
<li>一个已经申请成功的https域名</li>
<li>https证书已绑定到cloudflare</li>
<li>一个微信小程序账号</li>
<li>小程序已开通云托管功能</li>
</ul>
<h2 id="微信云托管开发流程"><a href="#微信云托管开发流程" class="headerlink" title="微信云托管开发流程"></a>微信云托管开发流程</h2><h3 id="什么是微信云托管？"><a href="#什么是微信云托管？" class="headerlink" title="什么是微信云托管？"></a>什么是微信云托管？</h3><p>简单说就是微信的微型服务器，非常方便部署一些只需要简单后台的应用。相比于单独买服务器，我这些天体验微信云托管下来得出的优缺点如下：</p>
<span id="more"></span>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>按量计费：独立开发或者小网站最大的问题可能是服务器性能过剩，完全没有用户访问的情况下还得交那么多的服务器费用。而云托管可以按量计费，没有用户访问的情况下几乎没什么费用。</li>
<li>微信天然鉴权：这个实际用起来非常的爽，小程序调用云托管会在请求头里面自带openid和unionid，大大节省了来回调微信接口来进行用户认证的麻烦。</li>
<li>节省https证书费用：如果单独买服务器，你还需要注册<strong>国内的https证书</strong>，小程序才能够调用，如果你不幸买了国外的服务器和证书，那是没办法和小程序接通的。<strong>而用云托管的话不用买证书小程序就能调用。</strong></li>
<li>安全：自带防ddos攻击，防爬取，这也能比买服务器省心不少。</li>
<li>自带数据库：可以存入其自带的mysql数据库，小型项目用起来确实非常方便。大型项目就算了，如果你真的有很多的数据要存入数据库，<strong>这个云托管的数据库费用可能会让你怀疑人生。</strong></li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有缓存功能：不仅仅是没有redis服务，<strong>而且本地缓存也不能用</strong>。这点配合着上面所说的按量计费，就会非常蛋疼，这意味着如果你不额外购买缓存服务，那每次服务调用都要耗费服务器和数据库资源，费用会非常惊人。</li>
<li>代码质量要求高：由于是按量计费，所以你代码最好没什么恶性bug，否则可能会大量耗费服务器资源，导致费用激增。</li>
<li>访问受限：这是国内服务器的普遍问题，也就是GFW导致的服务器访问外网受限。这点通过后续介绍的cloudflare来进行解决。</li>
</ul>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul>
<li>进入公众号后台-云服务-云托管，点击开通。<br><img src="/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/wxcloud1.png"></li>
<li>进入云托管后台，点击模版部署，这里有各种语言的模版，选择你习惯用的语言。<br><img src="/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/wxcloud2.png"></li>
<li>接下来让你输入数据库密码，然后点击部署就完成了。<br><img src="/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/wxcloud3.png"></li>
</ul>
<p>这上面几步就生成了一个服务，可以在服务列表里查看服务名称。</p>
<p>在服务页面，可以看到部署发布的几个选项，你可以将本地代码上传到github，然后将github和服务绑定，这样你每次提交到github的时候就会自动部署。<br><img src="/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/wxcloud4.png"></p>
<p>我个人认为相比上面的部署方式，有个更好用的工具，就是微信官方的<a href="https://cloud.weixin.qq.com/cli/guide.html">云托管CLI</a>。使用方式：</p>
<ul>
<li>安装：<code>npm i -g @wxcloud/cli</code> 。</li>
<li>登录：<code>wxcloud login --appId &lt;微信 AppId&gt; --privateKey &lt;秘钥&gt;</code>，密钥在<a href="https://cloud.weixin.qq.com/cloudrun/settings/other">微信云托管控制台-设置-全局设置-CLI密钥</a>生成。</li>
<li>项目初始化：<code>wxcloud migrate</code>，这条命令会根据你的项目自动生成容器文件。</li>
<li>部署：<code>wxcloud deploy</code>，做完上述几步后，每次发布只需要敲这个命令就可以自动完成部署。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wxcloud deploy</span><br><span class="line"></span><br><span class="line">Wxcloud CLI 2.0.1-beta.15</span><br><span class="line">? 请选择环境 <span class="built_in">test</span> (test-environment)</span><br><span class="line">? 请选择服务 test-service</span><br><span class="line"></span><br><span class="line">&lt;构建日志&gt;</span><br><span class="line"></span><br><span class="line">✔ 云托管产物上传</span><br><span class="line">✔ 云托管版本创建</span><br><span class="line">public       | ████████████████████████████████████████ | 2/2 Files</span><br><span class="line">.next/static | ████████████████████████████████████████ | 12/12 Files</span><br><span class="line">✔ 静态资源上传文件成功</span><br><span class="line"></span><br><span class="line">部署开始于 2022-05-19 15:40:33</span><br><span class="line"></span><br><span class="line">&lt;部署日志&gt;</span><br><span class="line"></span><br><span class="line">✔ 部署完成</span><br><span class="line">  服务 cloudkit 访问地址:</span><br><span class="line">  &gt; demo.ap-shanghai.run.tcloudbase.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开发要点"><a href="#开发要点" class="headerlink" title="开发要点"></a>开发要点</h3><ul>
<li>环境变量：一些敏感信息或者会进行线上修改的变量在[服务列表-服务设置-环境变量]里面指定。</li>
<li>实例数量：默认的实例最小数量是0，这导致云托管在没有用户访问的情况下，隔一段时间就会完全停掉所有服务，此时访问小程序时，是无法调用任何后端服务的。为了更良好的用户体验，建议最小实例数量设置为1。设置地址[服务列表-服务设置-实例副本数]</li>
<li>节省资源：这点非常重要，按量计费的情况下，能省则省。<ul>
<li>爬虫类服务，尽量不要一次性爬取所有数据，可以惰性爬取，等待用户点击到那个页面再进行爬取。</li>
<li>前端和后端最好都实现缓存，前文说过，云托管没有缓存功能，因此后端的缓存需要别的方式实现，<strong>后面会讲一个可行的方案。</strong></li>
<li>尽量使用前端进行数据处理，因为后端处理需要费用，前端不需要。</li>
<li>如果一定要用后端处理数据，也尽量用代码处理，不要用sql进行复杂的查询和数据处理，因为在云托管的费用列表里，数据库算力是最贵的一项，高出别的所有资源一档。<br><img src="/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/wxcloud5.png"></li>
</ul>
</li>
</ul>
<h3 id="小程序调用云托管"><a href="#小程序调用云托管" class="headerlink" title="小程序调用云托管"></a>小程序调用云托管</h3><ul>
<li>在小程序的app.js中增加一个通用的call方法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 封装的微信云托管调用方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>obj 业务请求信息，可按照需要扩展</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>number 请求等待，默认不用传，用于初始化等待</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">call</span>(<span class="params">obj, number=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span>(that.cloud == <span class="literal">null</span>)&#123;</span><br><span class="line">      that.cloud = <span class="keyword">new</span> wx.cloud.Cloud(&#123;</span><br><span class="line">        <span class="attr">resourceAppid</span>: <span class="string">&#x27;WXAAA&#x27;</span>, <span class="comment">// 微信云托管环境所属账号，服务商appid、公众号或小程序appid</span></span><br><span class="line">        <span class="attr">resourceEnv</span>: <span class="string">&#x27;prod-001&#x27;</span>, <span class="comment">// 微信云托管的环境ID</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">await</span> that.cloud.init() <span class="comment">// init过程是异步的，需要等待init完成才可以发起调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> that.cloud.callContainer(&#123;</span><br><span class="line">        <span class="attr">path</span>: obj.path, <span class="comment">// 填入业务自定义路径和参数，根目录，就是 / </span></span><br><span class="line">        <span class="attr">method</span>: obj.method||<span class="string">&#x27;GET&#x27;</span>, <span class="comment">// 按照自己的业务开发，选择对应的方法</span></span><br><span class="line">        <span class="comment">// dataType:&#x27;text&#x27;, // 如果返回的不是json格式，需要添加此项</span></span><br><span class="line">        <span class="attr">header</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;X-WX-SERVICE&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">// xxx中填入服务名称（微信云托管 - 服务管理 - 服务列表 - 服务名称）</span></span><br><span class="line">          <span class="comment">// 其他header参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其余参数同 wx.request</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`微信云托管调用结果<span class="subst">$&#123;result.errMsg&#125;</span> | callid:<span class="subst">$&#123;result.callID&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> result.data <span class="comment">// 业务数据在data中</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">const</span> error = e.toString()</span><br><span class="line">       <span class="comment">// 如果错误信息为未初始化，则等待300ms再次尝试，因为init过程是异步的</span></span><br><span class="line">      <span class="keyword">if</span>(error.indexOf(<span class="string">&quot;Cloud API isn&#x27;t enabled&quot;</span>)!=-<span class="number">1</span> &amp;&amp; number&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(that.call(obj,number+<span class="number">1</span>))</span><br><span class="line">          &#125;,<span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`微信云托管调用失败<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法中调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> app.call(&#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;业务返回结果&#x27;</span>,res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>别的详细说明参考<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloudrun/src/development/call/mini.html">官方文档</a>。</li>
</ul>
<h2 id="cloudflare开发流程"><a href="#cloudflare开发流程" class="headerlink" title="cloudflare开发流程"></a>cloudflare开发流程</h2><h3 id="为什么用cloudflare？"><a href="#为什么用cloudflare？" class="headerlink" title="为什么用cloudflare？"></a>为什么用cloudflare？</h3><p>从前面介绍来说，讲到云托管的几个缺点，其中对于业务开发来说最有影响的，一个是没有缓存功能，另一个是访问外网受限。第一个可能导致云托管费用激增，第二个则限制了你的小程序功能，比如我想做一个外网的爬虫项目，单纯用云托管就没办法做到。</p>
<p>而这两点都可以通过cloudflare的功能来解决。</p>
<h3 id="worker解决外网受限"><a href="#worker解决外网受限" class="headerlink" title="worker解决外网受限"></a>worker解决外网受限</h3><p>worker是cloudflare的一个功能，简单说可以看成是一个路由，也可以认为是一个微型服务，总之，通过将你的域名绑定到worker，然后再通过小程序访问这个域名，就可以对小程序的请求进行转发处理，这么一个流程：【小程序 -》 你的域名worker -》 外网】。<strong>这当中唯一需要保证的就是小程序可以访问到你的域名</strong>，一般情况下，你的域名只要没做什么黄赌毒之类的事儿，应该是没问题的。</p>
<p>worker部署：详情看我的另一篇博文<a href="https://blog.cindyforever.com/2023/07/07/2023/07/how-to-build-project-by-cloudflare/">《如何通过cloudflare的worker处理复杂后台逻辑》</a></p>
<h3 id="kv实现缓存功能"><a href="#kv实现缓存功能" class="headerlink" title="kv实现缓存功能"></a>kv实现缓存功能</h3><p>kv是cloudflare另一个功能，就是其自带的键值对存储功能，用来当缓存简直再合适不过。以下配置和内容需要先看过上面的worker博文才好理解。</p>
<ul>
<li>在cloudflare的首页，点击[Workers &amp; Pages]</li>
<li>点击[KV]</li>
<li>选择[create a namespace]</li>
<li>输入name后，点击ADD完成新增</li>
<li>复制你的[KV]的[name]和[ID]</li>
<li>在你的本地worker项目中，在<code>wrangler.toml</code>中增加配置：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">kv_namespaces = [</span><br><span class="line">    &#123; binding = <span class="string">&quot;YOUR_KV_NAME&quot;</span>, id = <span class="string">&quot;YOUR_KV_ID&quot;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>使用<code>wrangler deploy</code>命令完成部署，<code>KV</code>会自动绑定到你的<code>worker</code>上</li>
<li><code>worker</code>项目中<code>KV</code>的使用（尽管官方文档写了直接在项目中使用KV的<code>NAME.get</code>和<code>NAME.put</code>就行，但是我怎么试都报错，所以还是直接用<a href="https://developers.cloudflare.com/api/operations/workers-kv-namespace-list-namespaces">API文档</a>的方式调用）：<ul>
<li>写入值：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> detailResponse = <span class="keyword">await</span> fetch(<span class="string">`https://api.cloudflare.com/client/v4/accounts/<span class="subst">$&#123;ACOUNT_ID&#125;</span>/storage/kv/namespaces/<span class="subst">$&#123;NAME_SPACE&#125;</span>/bulk`</span>, </span><br><span class="line">&#123; <span class="attr">method</span>: <span class="string">&quot;PUT&quot;</span>, <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify([</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="string">&quot;base64&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">		  <span class="string">&quot;expiration_ttl&quot;</span>: <span class="number">86400</span>,</span><br><span class="line">		  <span class="string">&quot;key&quot;</span>: reqData.key,</span><br><span class="line">		  <span class="string">&quot;value&quot;</span>: reqData.value</span><br><span class="line">		&#125;</span><br><span class="line">	  ]),</span><br><span class="line">	  <span class="attr">headers</span>: &#123;</span><br><span class="line">		<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;X-Auth-Key&#x27;</span>: X_AUTH_KEY,</span><br><span class="line">		<span class="string">&#x27;X-Auth-Email&#x27;</span>: X_Auth_Email</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>读取值：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> detailResponse = <span class="keyword">await</span> fetch(<span class="string">`https://api.cloudflare.com/client/v4/accounts/<span class="subst">$&#123;ACOUNT_ID&#125;</span>/storage/kv/namespaces/<span class="subst">$&#123;NAME_SPACE&#125;</span>/values/<span class="subst">$&#123;key&#125;</span>`</span>, </span><br><span class="line">&#123; <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,<span class="attr">headers</span>: &#123;</span><br><span class="line">	<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;X-Auth-Key&#x27;</span>: X_AUTH_KEY,</span><br><span class="line">	<span class="string">&#x27;X-Auth-Email&#x27;</span>: X_Auth_Email</span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>接下来通过前面所说的worker转发路由功能，就可以远程调用kv来进行缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上所述，云托管主要解决了：</p>
<ul>
<li>国内域名备案问题，证书问题</li>
<li>服务器费用过高问题</li>
<li>小程序鉴权问题</li>
</ul>
<p>而cloudflare主要解决了：</p>
<ul>
<li>云托管外网受限问题</li>
<li>云托管没有缓存功能问题</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>每日文章收集-20230719</title>
    <url>/2023/07/19/2023/07/daily-tech-blog-collection-20230719/</url>
    <content><![CDATA[<h3 id="Stable-Diffusion的一个网页DEMO"><a href="#Stable-Diffusion的一个网页DEMO" class="headerlink" title="Stable Diffusion的一个网页DEMO"></a><a href="https://islamov.ai/stable-diffusion-webgpu/">Stable Diffusion的一个网页DEMO</a></h3><p><img src="/2023/07/19/2023/07/daily-tech-blog-collection-20230719/sd1.png"><br>这个网页使用的是你本地的内存和GPU来生成AI图片，根据网页介绍：</p>
<blockquote>
<p>每个步骤大约需要1分钟+额外的约10秒来运行VAE解码器生成图像。打开DevTools会将所有操作减慢到大约2倍的速度。UNET仅在CPU上运行（速度快10%，在GPU上无法正确生成结果），因此会导致浏览器标签卡顿。</p>
<p>为了得到可接受的结果，最少需要20个步骤。然而，对于演示目的，3个步骤就足够了。</p>
<p>模型文件将被缓存，因此您无需每次下载它们。</p>
</blockquote>
<p>另外需要最新版本的chrome，并打开<code>Experimental WebAssembly</code>和<code>Experimental WebAssembly JavaScript Promise Integration (JSPI)</code>的设置。</p>
<p>为了生成图像，这个网页还需要下载3.5gb的数据和耗费8gb的内存。</p>
<p><img src="/2023/07/19/2023/07/daily-tech-blog-collection-20230719/sd2.png"></p>
<h3 id="lazydocker：管理Docker的懒人方式"><a href="#lazydocker：管理Docker的懒人方式" class="headerlink" title="lazydocker：管理Docker的懒人方式"></a><a href="https://github.com/jesseduffield/lazydocker">lazydocker：管理Docker的懒人方式</a></h3><p><img src="/2023/07/19/2023/07/daily-tech-blog-collection-20230719/lazydocker1.png"><br>这是一个简单的终端UI用于管理docker容器和镜像。</p>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ul>
<li>Docker 版本 &gt;= 1.13 (API &gt;= 1.25)</li>
<li>Docker-Compose 版本 &gt;= 1.23.2 (optional)</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>有多种不同的<a href="https://github.com/jesseduffield/lazydocker#installation">安装方法</a>，最通用的方法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh | bash</span><br></pre></td></tr></table></figure>

<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>使用命令<code>echo &quot;alias lzd=&#39;lazydocker&#39;&quot; &gt;&gt; ~/.zshrc</code>来展示lazydocker界面。</p>
<h4 id="主要feature"><a href="#主要feature" class="headerlink" title="主要feature"></a>主要feature</h4><ul>
<li>一目了然地查看Docker或Docker Compose容器环境的状态</li>
<li>查看容器/服务的日志</li>
<li>查看容器指标的ASCII图表，以便不仅感觉像开发人员，还能看起来像开发人员</li>
<li>自定义这些图表以测量几乎任何您想要的指标</li>
<li>附加到容器/服务</li>
<li>重新启动/删除/重建容器/服务</li>
<li>查看给定镜像的祖先层</li>
<li>清理占用磁盘空间的容器、镜像或卷</li>
</ul>
]]></content>
      <categories>
        <category>每日文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>关于个人开发者为什么应该放弃小程序</title>
    <url>/2023/07/21/2023/07/do-not-develop-in-wechat/</url>
    <content><![CDATA[<p>写在前面：<strong>个人开发放弃小程序吧</strong>😭，毫无希望的一条路。</p>
<h2 id="小程序被打回"><a href="#小程序被打回" class="headerlink" title="小程序被打回"></a>小程序被打回</h2><p>我好不容易研究出的<a href="https://blog.cindyforever.com/2023/07/18/2023/07/how-to-create-a-miniprogram-with-low-fee/">低成本开发小程序</a>，充满希望的点下发布，结果被毫不留情的打回，打回原因：<br><img src="/nowehcat1.png"></p>
<p>我也是太久没申请小程序了，忘记了要填类目的，结果我上去一看个人开发可填的类目：<br><img src="/2023/07/21/2023/07/do-not-develop-in-wechat/nowechat2.png"><br><img src="/nowehcat3.png"></p>
<p>具体罗列如下（截止20230721）：</p>
<ul>
<li>物流服务<ul>
<li>查件</li>
<li>装卸搬运</li>
</ul>
</li>
<li>交通服务<ul>
<li>代驾服务</li>
</ul>
</li>
<li>生活服务<ul>
<li>家政服务</li>
<li>丽人服务</li>
<li>婚庆服务</li>
</ul>
</li>
<li>餐饮服务<ul>
<li>餐饮排队</li>
</ul>
</li>
<li>旅游服务<ul>
<li>出境wifi</li>
</ul>
</li>
<li>工具<ul>
<li>记账</li>
<li>日历</li>
<li>天气</li>
<li>备忘录</li>
<li>办公</li>
<li>图片处理</li>
<li>计算器</li>
</ul>
</li>
<li>商业服务<ul>
<li>企业管理</li>
<li>环保回收/废品回收</li>
<li>摄影/扩印</li>
<li>会展服务</li>
<li>公关/推广/市场调查</li>
<li>律师</li>
</ul>
</li>
</ul>
<p>总之就是非常扯，一眼望去就没有适合独立开发者的项目，比如查件和代驾，这种根本不可能会有人点进你的个人小程序去用这种服务啊。再比如餐饮排队，废品回收，律师之类的，这种基本就是要进行客户拓展才能做起来的，但是说回来，你都能线下找到这么多客户了，还做啥小程序。</p>
<p>唯一有点适合个人开发的就是办公和图片处理，可能稍微能玩出点花来。也就是说独立开发者你想要在小程序上线项目，<strong>路非常非常的窄。</strong></p>
<p>另外，<strong>这些类目还有进一步缩减的可能</strong>，我N年前在这个小程序上申请的类目是【工具-效率】，现在看这个类目已经不在了，同时原来申请的也失效了。<br><img src="/2023/07/21/2023/07/do-not-develop-in-wechat/nowechat4.png"></p>
<h2 id="别的方法？"><a href="#别的方法？" class="headerlink" title="别的方法？"></a>别的方法？</h2><p>有没有别的办法呢？有，比如伪造一个审核页面糊弄审核人员，这个方法短时间内是可以的，但是关于微信的审核机制，网上找到这样的说法：</p>
<blockquote>
<p>小程序不同用户数数量， 审核机制是有区别的。<br>用户多了， 他会记录这些用户请求的每一个 api ，到下次审核的时候 就会用机器批量扫描 api ，还会有模拟真实用户来请求 api 看你是否有对抗审核行为。<br>总之就算你审核过了，用户量上来，大概率 over。</p>
</blockquote>
<p>另外看了下微信的<a href="https://developers.weixin.qq.com/community/develop/doc/000044d4a7c7c0031219da0bc56401">公告</a>，对于这样欺骗审核的行为，微信可能会养肥了杀，总之风险非常大。</p>
<h2 id="小程序开发总结"><a href="#小程序开发总结" class="headerlink" title="小程序开发总结"></a>小程序开发总结</h2><p>回过头来，当初自己要做小程序有几个原因：</p>
<ul>
<li>微信流量大，对于个人开发来说是个不错的起点。</li>
<li>公众号门槛太低，基本有手就行，没法和这么多自媒体竞争。</li>
<li>开发小程序不是谁都能干的，筛掉一大批竞争者，相对不那么卷。</li>
</ul>
<p>现在看来有几个非常致命的硬伤：</p>
<ul>
<li>可发布类目受限，路很窄，而且可能变得更窄。</li>
<li>无法调用很多国外网站的API，也无法爬取这些网站的数据。</li>
<li>无法使用国外注册的域名和服务器，因此你只能购买国内服务器或者使用云托管。<ul>
<li>购买国内服务器方案<ul>
<li>服务器费用过高，仅首单能够有所优惠，第二年开始这些费用最低要390一年。</li>
<li>单看服务器费用可能还能接受，但是购买国内服务器你还必须买国内的ssl证书，而这个在<a href="https://www.namecheap.com/">namecheap</a>只要6美元的泛域名证书，在国内要2000多。<br><img src="/2023/07/21/2023/07/do-not-develop-in-wechat/nowechat5.png"></li>
<li>至于为什么非要ssl证书，不买不行吗？不行，微信小程序和公众号所有的API调用都必须是https的请求。</li>
<li>国外呢？看下账单吧，域名加证书15.75刀，一百出头。<br><img src="/2023/07/21/2023/07/do-not-develop-in-wechat/nowechat6.png"></li>
<li>账单为啥没有国外服务器的费用，因为我发现cloudflare的免费套餐比国内最便宜的服务器还良心。</li>
</ul>
</li>
<li>云托管方案<ul>
<li>按量计费看似划算，其实非常的蛋疼，每一行代码都要精打细算，尤其数据库算力这项，只是做些限量的数据爬取任务，只有我一个人点击测试的情况下，两天也能产生五六元的费用。</li>
<li>功能非常有限，没有缓存，没有消息队列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>个人开发如果想要在小程序上开发项目，先看下上面的类目，路很窄，估计没啥合适的。</li>
<li>真要在小程序上开发，费用很高，我认为不适合个人开发用来起步，<strong>除非你不涉及任何后端逻辑</strong>，这样也就不用购买服务器+域名+证书。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
</search>
