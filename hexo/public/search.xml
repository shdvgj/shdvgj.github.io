<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新闻翻译.1</title>
    <url>/2019/10/10/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-1/</url>
    <content><![CDATA[<p><a href="https://www.latimes.com/politics/story/2019-10-09/trumps-legal-strategy-against-impeachment-shaky-constitutional-grounds-scholars-say">原文链接</a>  </p>
<h2 id="Trump’s-legal-strategy-against-impeachment-is-on-shaky-constitutional-grounds-scholars-say"><a href="#Trump’s-legal-strategy-against-impeachment-is-on-shaky-constitutional-grounds-scholars-say" class="headerlink" title="Trump’s legal strategy against impeachment is on shaky constitutional grounds, scholars say"></a>Trump’s legal strategy against impeachment is on shaky constitutional grounds, scholars say</h2><h3 id="学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据"><a href="#学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据" class="headerlink" title="学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据"></a>学者认为川普反对弹劾的律法政策是基于站不住脚的宪法依据</h3><p>1.Washington —  Constitutional lawyers said Wednesday that President Trump’s<br>vow not to cooperate with the impeachment inquiry is both unprecedented and<br>unlikely to spare him from being formally charged by the House.<br>In fact, they say, it may only increase the chances that he will be impeached.<br>华盛顿报道 - 宪法律师周三声明, 川普总统发誓不会与弹劾调查进行合作的言论是<br>前所未有的, 而且也很可能使他面临众议院的正式指控. 并且, 他们还说到, 这有可能<br>增加川普被弹劾的可能.</p>
<p>2.The Constitution says the “House of Representatives shall have the sole<br>power of impeachment,” and it does not give the president a specific role<br>in the process. A president is in some sense like an ordinary defendant<br>who may be subject to a criminal investigation and an indictment,<br>all without his participation or involvement, scholars say.<br>美国宪法里写到, “众议院拥有弹劾的唯一权力”, 而且没有赋予总统在此过程中的任何<br>特殊角色. 学者认为, 总统在整个过程中都不会参与到弹劾中, 某种意义上和普通被告一样,<br>可能面临刑事调查和指控.  </p>
<p>3.“The president’s cooperation is not required or needed,” said University of<br>North Carolina law professor Michael J. Gerhardt, an expert on impeachment.<br>And “the House may make that defiance grounds for impeachment,” he added,<br>noting that in 1974, a House committee approved articles of impeachment against<br>President Nixon based in part on his refusal to comply with congressional subpoenas.<br>北卡罗莱纳大学的法律学教授, 同时也是研究弹劾的专家, Michael J.Gerhardt认为,<br>“总统的配合并不是必需的, 众议院可以把这作为违抗理由去弹劾”. 他还补充到, 1974年,<br>众议院委员会通过了一项弹劾决议, 其部分原因就是尼克松总统拒绝了来自国会的传票. </p>
<span id="more"></span>
<p>4.Though both Nixon and President Clinton tried behind the scenes to slow<br>or stop impeachment proceedings, they also attempted to cooperate at times,<br>or at least appear to, out of respect for the process and fear they might<br>look like they were hiding something.<br>尽管尼克松和克林顿总统都试图在幕后减缓或者阻止弹劾的进程, 但至少他们在当时都是<br>试图配合弹劾工作的, 至少看上去是. 对于弹劾的不尊重和害怕会让他们看起来隐藏了<br>一些事.</p>
<p>5.“There is no precedent for the president doing what President Trump is<br>doing here: saying I will flatly refuse to cooperate and ordering all<br>employees of the executive branch to refuse to cooperate as well,”<br>said professor Frank O. Bowman, who teaches impeachment law at the<br>University of Missouri and Georgetown.<br>来自密苏里和乔治敦大学, 教弹劾法律的教授Frank O.Bowman说:”之前从来没有<br>一份先例像川普总统这样, 说自己断然拒绝合作, 而且还命令所有的行政雇员也拒绝合作.”</p>
<p>6.In Tuesday’s eight-page letter to House Democrats, White House Counsel<br>Pat Cipillone pronounced Trump innocent of wrongdoing and the inquiry<br>“unconstitutional.”<br>周四一份来自白宫的法律顾问Pat Cipillone的八页信件发往了众议院的民主党派,<br>他宣称川普的错误做法是无辜的, 而且弹劾调查也是违宪的.</p>
<p>7.He said Trump’s July 25 phone call asking the new president of Ukraine<br>to do him “a favor” and investigate former Vice President Joe Biden and<br>his son Hunter was “completely appropriate. The president did nothing wrong,<br>and there is no legitimate basis for an impeachment inquiry.”<br>他说, 川普在7月25号致电给乌克兰新总统, 要求他帮助和调查前副总统Joe Biden以及<br>他的儿子Hunter是”完全合理的. 总统没有做错什么, 而且也没有一个合法的法律依据<br>可以支撑弹劾的调查”</p>
<p>8.Legal experts, however, say Trump’s actions were exactly the kinds of<br>things that framers were thinking of when they included an impeachment<br>provision in the Constitution. Trump has acknowledged that even as he asked<br>Ukraine to investigate one of his political opponents, he had ordered<br>that nearly $400 million in aid to Ukraine be withheld.<br>然而法律专家认为, 川普的行为恰好就是制宪者将弹劾条款加入宪法时所考虑过的.<br>川普认识到即使他要求乌克兰去调查他其中的一个政治对手, 他下令资助给乌克兰的<br>将近40亿美元的援助也将被扣留.</p>
<p>9.The White House letter suggests that the inquiry is invalid because<br>there was no formal House vote to launch it, and that Trump and Republicans<br>have so far not been given the right to see evidence and call witnesses.<br>Based on this conclusion, he said, “President Trump and his administration<br>cannot participate in your partisan and unconstitutional inquiry.”<br>白宫的信件认为调查是无效的, 因为没有任何正式的众议院决议去启动这项调查, 而且<br>川普和共和党至今甚至没有权力见到证据和传唤目击者. 基于这些结论, 他说: “川普<br>总统和他的管理团队不会参与到你们的党派和违宪的调查中去”</p>
<p>10.Lawyers took to social media to express surprise and disdain, noting<br>that no such rights or requirements exist in the Constitution.<br>律师在社交媒体上表达了他的惊讶和蔑视, 指出在宪法中不存在这样的权力和请求.</p>
<p>11.“This letter is bananas. A barely-lawyered temper tantrum,” tweeted<br>Gregg Nunziata, a former counsel for Senate Republicans.<br>前任的共和党法律顾问, Gregg Nunziata发推说道:”这封信就是胡闹, 一份没有法律<br>常识的脾气的宣泄”</p>
<p>12.University of Texas law professor Steve Vladeck said it was remarkable<br>for the top White House lawyer to say in writing that it “is completely<br>appropriate for the president of the United States to actively solicit<br>foreign intervention in U.S. presidential elections. Let’s not lose<br>sight of just how insane that is.”<br>德克萨斯大学的法律教授Steve Vladeck表示, 对于一个顶级的白宫律师, 以书面形式<br>说”美国总统积极的寻求外国介入到美国的总统选择中是完全合理的. 让我们不要忘记<br>这是多么疯狂”, 真是太出色了.(这段真是不知道怎么翻译…)</p>
<p>13.Lisa Kern Griffin, a Duke law professor, described the letter as a<br>“political stunt that misinterprets the Constitution, ignores relevant<br>precedents and defies common sense.” She said the letter sets the stage<br>for a constitutional crisis.<br>杜克的法律教授, Lisa Kern Griffin形容这个信是”曲解宪法的政治手段, 忽略了<br>相关的先例, 否决了共识”. 她说这封信为宪法的危机奠定了一个基础.</p>
<p>14.“Of course, the House can proceed with impeachment based on the testimony<br>and evidence it can access, but it strikes me as dangerous for the entire<br>executive branch to defy congressional oversight.”<br>“理所当然的, 众议院可以继续根据已有的证词和证据进行弹劾, 但是令我感到危险的是<br>整个行政部门都违抗国会的监督”</p>
<p>15.Neal K. Katyal, who was acting solicitor general during the Obama administration,<br>noted that Trump’s lawyers have insisted that he is immune from criminal charges,<br>shielded from congressional and state legal demands, including for his tax returns,<br>and now shielded from an impeachment inquiry.<br>在奥巴马政府期间担任代理司法部副部长的Neal K. Katyal指出, 川普的律师坚持他(川普)<br>是免于刑事指控的, 受国会和国家法律要求的保护, 包括他的报税表, 所以现在也保护他免<br>于收到弹劾的调查.</p>
<p>16.Gerhardt said the White House letter “shows nothing but contempt for the<br>law and the Constitution. Its principal argument is that the president is<br>above the law. In fact, he is not. Impeachment is one of the unique constitutional<br>processes for holding the president accountable for abusing his power.”<br>Gerhardt认为白宫信件”展示了对于法律和宪法的蔑视. 这里面的主要内容就是总统<br>凌驾于法律之上. 但事实上, 他是错的. 弹劾是宪法中用于控制总统滥用职权的独特<br>法律条文之一”</p>
<p>17.It’s not clear how or whether House Democrats will respond to Trump’s<br>vow of noncooperation. In recent weeks, leaders of the House inquiry signaled<br>they are reluctant to go to court or seek to hold officials in criminal<br>contempt for refusing to comply with a subpoena.<br>还不清楚众议院民主党派怎么回应或者是否会回应川普拒绝合作的承诺. 在最近几周,<br>众议院调查团队的负责人发出信号, 他们不愿意因为拒绝传票而走上法庭或者让官方<br>人员陷于刑事指控的境地.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-2</title>
    <url>/2021/12/09/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-2/</url>
    <content><![CDATA[<p><a href="https://www.smithsonianmag.com/smart-news/chinese-rover-spots-weird-cube-on-the-moon-180979174/">原文链接</a> </p>
<h2 id="Chinese-Rover-Spots-Weird-Large-‘Cube’-on-the-Moon"><a href="#Chinese-Rover-Spots-Weird-Large-‘Cube’-on-the-Moon" class="headerlink" title="Chinese Rover Spots Weird, Large ‘Cube’ on the Moon"></a>Chinese Rover Spots Weird, Large ‘Cube’ on the Moon</h2><h2 id="中国航天器在月球发现了诡异巨大的”方块”"><a href="#中国航天器在月球发现了诡异巨大的”方块”" class="headerlink" title="中国航天器在月球发现了诡异巨大的”方块”"></a>中国航天器在月球发现了诡异巨大的”方块”</h2><h3 id="The-geometric-lunar-feature-dubbed-a-‘mystery-hut’-has-stumped-scientists-who-say-they-plan-to-take-a-closer-look"><a href="#The-geometric-lunar-feature-dubbed-a-‘mystery-hut’-has-stumped-scientists-who-say-they-plan-to-take-a-closer-look" class="headerlink" title="The geometric lunar feature dubbed a ‘mystery hut’ has stumped scientists, who say they plan to take a closer look"></a>The geometric lunar feature dubbed a ‘mystery hut’ has stumped scientists, who say they plan to take a closer look</h3><h3 id="这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看"><a href="#这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看" class="headerlink" title="这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看"></a>这个呈几何状的月球物体被戏称为”神秘小屋”，让科学家们感到困惑，他们计划靠近点看看</h3><p><img src="/2021/12/09/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-2/1.png"><br><em>The rover will spend two to three lunar days, which is about two to three months time on Earth, traversing the lunar landscape to take a closer look at the object. CNSA/Our Space/Gizmodo</em><br><em>航天器将花费两到三个月球日，相当于地球上两到三个月的时间，通过月球表面来更近的观察这个物体。<a href="https://mp.weixin.qq.com/s/dpKkjWHk9tay3JERnrfuUw">CNSA/Our Space/Gizmodo</a></em></p>
<p>An intriguing cube-shaped object spotted on the far side of the moon has attracted the attention of scientists.<br>一个有趣的方块形状物体，在月球的另一端被发现，这引起了科学家的注意。</p>
<p>China’s Yutu 2 rover captured images of the mystery structure from around 260 feet away while navigating across the Von Kármán crater in the South Pole-Aitken Basin on the moon, reports Popular Science’s Margo Milanowski. Chinese scientists have already rerouted the rover to take a closer look, but it will take a few months for Yutu 2 to reach the bizarre lunar feature.<br>据<a href="https://www.popsci.com/science/chinas-rover-mysterious-hut-on-moon/">《流行科学》</a>的Margo Milanowski报道，中国的月兔2号航天器在月球的北部<code>Pole-Aitken</code>盆地，正在穿越<code>Von Kármán</code>坑时，拍摄到一张260英尺外的神秘结构的物体。中国的科学家已经调整航天器的方向以更近的观察，但是这将花费月兔2号几个月的时间去靠近这个奇特的月球物体。</p>
<p>The shape was spotted on the horizon in November during the mission’s 36th lunar day, according to a Yutu 2 diary published by Our Space, a Chinese language science outreach channel affiliated with the China National Space Administration. Our Space first described the object in a post last week, temporarily dubbing it a “mystery hut” (神秘小屋/shenmi xiaowu).<br>根据<a href="https://mp.weixin.qq.com/s/dpKkjWHk9tay3JERnrfuUw">《我们的太空》</a>的月兔2号每日报告（这是一家隶属于中国国家航天局的对外中文平台），这个几何体在地平线处发现，正值12月份，执行任务的第36个月球日。《我们的太空》在上周首次描述这个物体，将其戏称为是一个”神秘小屋”。</p>
<span id="more"></span>
<p>Since Yutu 2 spotted the “mystery hut,” scientists have changed the six-wheeled vehicle course to investigate the cube. The solar-powered rover will spend two to three lunar days—equivalent to two to three months time on Earth—traversing the lunar landscape to take a closer look, so we should have more clues shortly, reports Andrew Jones for Space.<br>玉兔2号发现”神秘小屋”之后，科学家改变了这个六个轮子航天器的目标，转为探索这个方块。这个太阳能的航天器会花费两到三个月球日-等价于两到三个地球月-穿越月球表面去更近的观察，所以我们很快会获得更多线索，来自于<a href="https://www.space.com/china-yutu-2-moon-rover-cube-shaped-object-photos">《太空》</a>的Andrew Jones报道。</p>
<p>The rover’s images immediately sparked debate as to what the cube-shaped object was and inspired humorous guesses. “Was it a home built by aliens after the crash landing? Or is it the pioneer spacecraft of the predecessors to explore the moon?” writes Our Space.<br>航天器的照片马上引起了对于这个集合形状的物体到底是什么的讨论，并引发了无数的猜想。《我们的太空》写道，”这是外星人撞击月球后建立的房子吗？或者这是先驱者用来探索月球的的航天器？”</p>
<p>The “hut” may simply be a large boulder that’s been pushed up by meteor impact and taken on a geometric look in the low-resolution image. The blog post noted that there is an impact crater beside the mystery hut, further suggesting that the cube could just be an excavated lunar rock.<br>“小屋”可能就是受流星撞击而出现的巨石，而且在低像素的照片下看起来是一个几何形状。博客提醒说，在神秘小屋旁边有一个撞击巨坑，进一步推测这个方块可能只是一个被撞出来的月球石块。</p>
<p>This latest discovery isn’t the first curious thing the Yutu 2 rover has seen since its arrival on the far side of the moon almost three years ago. In September 2019, the rover encountered a strange, gel-like substance that turned out to be melted rock fragments cemented together from extreme heat. This year, Yutu 2 spotted unusual shards sticking out from the lunar surface that turned out to be rocks launched by a meteor impact, reports Gizmodo’s George Dvorsky.<br>自从月兔2号航天器在将近三年前到达月球的另一端后，已经不止一次有这种奇特发现。在2019年9月，航天器遇到了一个奇怪的<a href="https://www.inverse.com/science/chinese-lunar-lander-gel-substance">凝胶状物质</a>，这个来自于被溶解的石头成分在高温下又被粘合到一块。今年，月兔2号在月球表面发现了<a href="https://www.space.com/china-yutu-2-moon-far-side-rover-milestone-discovery">不寻常尖锐碎片</a>突出，这个来自于流星撞击后的石头。报道来自于<a href="https://gizmodo.com/chinese-rover-to-investigate-mysterious-hut-spotted-o-1848165985">《Gizmodo》</a>的George Dvorsky。</p>
<p>Whatever the cube-shaped object is, we will have to wait another few months before getting an answer—until then, it’s fun to speculate on what the “mystery hut” could be.<br>不管方块形状的物体是什么，我们都要等几个月才能获得答案，在这期间推测”神秘小屋”是什么将很有意思。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-3</title>
    <url>/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/</url>
    <content><![CDATA[<p><a href="https://time.com/6125959/best-movies-2021/?utm_source=roundup&utm_campaign=2021208">原文链接</a> </p>
<p>吐槽一下，这十佳电影看着满满都是政治正确的味道，Passing这部电影简直buff叠满，黑白片，双女主，关于美国梦和黑人白人之间的冲突，满脸写着”我是冲着奥斯卡来的”。</p>
<hr>
<h2 id="2021十佳电影"><a href="#2021十佳电影" class="headerlink" title="2021十佳电影"></a>2021十佳电影</h2><p>如果说2020年对于影迷来说是一个漫长黑暗的冬天（当然也有一些优秀的影片，但是不得不在家观影也是一个打击），2021就是一个生机勃勃，欢声笑语的春天。不仅仅是普通意义的春天，也是一个充满了斯特拉文斯基风格的春天，在祥和齐声的交响乐中绽放在大地上的番红花，雨滴阵阵落满了泥土，树木抽出了嫩芽。这么说的一部分原因很现实，也在预料之内：相当数量的今年的最佳影片早在2020年就已完成，但是推迟了，直到它们可以在影院上映。在黑暗的几个月过去后，这个值得欢庆的季节里绽放的曙光依然可以看作精神的慰藉。在本文的结尾，请参考这十部今年最好的电影（以及提名影片）作为你观影的选项。我们都值得这一切。</p>
<ul>
<li>10.Drive My Car</li>
</ul>
<p>Ryusuke Hamaguchi的三小时的流畅而又华丽的剧本（故事改编自Haruki Murakami的短篇小说），讲述了一个来自东京，经历了丧偶的演员和戏剧导演（Hidetoshi Nishijima），在广岛找了份工作，制作契柯夫的《万尼亚舅舅》。一个来自乡下（三浦店）的年轻女人被雇佣当他的司机；他们慢慢建立了友情，同时也帮助他分辨出他究竟迷失在哪里。Hamaguchi编织了一个关于失去和原谅，充满了光辉的故事，无论你有多么疲惫，一句轻轻的鼓励也能推动你在世界上继续前行。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/DriveMyCar.jpeg"> </p>
<ul>
<li>9.The Tragedy of Macbeth</li>
</ul>
<p>这个故事你可能已经看过几百次了。但是Joel Coen用令人战栗的黑白色调，以及Frances McDormand和Denzel Washington饰演的狡诈，奸险的苏格兰人，犹如魔咒般吸引人，他们共同对该经典进行了难以置信的表达，彷佛置身于400年前，你作为第一个观众看到这个戏剧的首次呈现。今时今日，犹如往昔，这个故事冻彻骨髓。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheTragedyofMacbeth.jpg"> </p>
<span id="more"></span>
<ul>
<li>8.C’mon C’mon</li>
</ul>
<p>Joaquin Phoenix贡献了一次有趣而又精致的表演，剧中作为一个无儿无女的纽约广播记者，要在几周内负责照顾他少年老成的来自洛杉矶的9岁外甥（Woody Norman）。这怎么听起来不像一部完整的电影呢？但在编剧兼导演Mike Mills的手中，这就是整部电影的内容。No one is better at chronicling late 20th and early 21st century family affection, in all its thorny, shimmery beauty.（翻译不出来）<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/CmonCmon.jpeg"></p>
<ul>
<li>7.The Disciple</li>
</ul>
<p>故事讲述一个歌手（公开资料显示，由Aditya Modak扮演），拥有十足的干劲和自律性，在一个曲高和寡的领域，为印度传统音乐奋斗终生，最终被迫认识到自己缺乏关键的天赋。导演Chaitanya Tamhane在他的鲜艳，动人的镜头下，审视了在一个现实世界中如此狂热的追求艺术之梦的意义，并没有那么重要。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheDisciple.jpeg"></p>
<ul>
<li>6.Passing</li>
</ul>
<p>这部电影改编自Nella Larsen的一部1929年的紧凑，强有力的小说，讲述了两个少女（由Tessa Thompson 和 Ruth Negga出色演绎）在成年后重新取得联系，她们的生活不仅仅发生交织，乃至最终的坍塌：两个女人都是黑人，但是其中一个却以白人自居。导演Rebecca Hall首次为我们深刻讲述了围绕在美国梦周围的是什么，是创造一切，或者成为谁–这被称为自由，有时候会付出惨痛的代价。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/Passing.jpeg"></p>
<ul>
<li>5.Parallel Mothers</li>
</ul>
<p>Penélope Cruz 贡献了杰出的表演，她饰演一个在马德里的女人，在中年成为母亲，同时她也在努力为她的曾祖父争取正义，他在西班牙内战中被杀害，尸体被抛弃在乱葬岗中。导演Pedro Almodóvar用情节剧的方式去回闪那些他的国家中的悲催历史，但同时也在强调关于母性的关键真理：历史由母亲们铸造，文明失去她们，将无法前行。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/ParallelMothers.jpeg"></p>
<ul>
<li>4.The Souvenir Part II</li>
</ul>
<p>这部英国制片人Joanna Hogg的令人刺痛和伤感的半自传电影中，讲述了在上世纪80年代的伦敦，一个年轻学生（Honor Swinton Byrne扮演，贡献了微妙迷人的表演）在完成她的毕业影片时，试图寻找令人心碎的个人悲剧的意义。在这个看似简单的故事中，Hogg捕捉到了一个年轻人渴望在世界中留下印记的方方面面，同时也需要绝望的寻找其中的意义。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheSouvenirPartII.jpeg"></p>
<ul>
<li>3.Summer of Soul</li>
</ul>
<p>Ahmir “Questlove” Thompson的光辉纪录片记录了一系列发生在Woodstock的夏天，在Harlem公园的众星云集的免费演唱会。但是获得的关注却不多。The Harlem Cultural Festival 吸引众多人群，但从几年前开始，这项音乐和骄傲的国民盛典就开始被大量遗忘，或者更准确的说，单纯被忽视了。就像隐藏在眼皮底下的珠宝，电影呈现了Mahalia Jackson, Stevie Wonder and Nina Simone的伟大表演。至少现在，世界开始注意到了。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/SummerofSoul.jpeg"></p>
<ul>
<li>2.The Worst Person in the World</li>
</ul>
<p>丹麦-挪威混血导演Joachim Trier这部无比温柔的喜剧像是上帝赋予的礼物。Julie（Renate Reinsve扮演，这是一场奇妙的而又粗中有细的表演）一路在弄清楚她自己是谁，她先后爱上两个男人，最后意识到她失去了更多。Trier将故事导向了一个苦乐参半的结局。提醒我们一直在路上，未竟的道路最终都会转向光明。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/TheWorstPersonintheWorld.jpeg"></p>
<ul>
<li>1.The Power of the Dog  </li>
</ul>
<p>上世纪20年代的蒙大拿，一个愤世嫉俗的农场主（Benedict Cumberbatch饰演）遇到了一个精力充沛，充满梦想的少年（Kodi Smit-McPhee饰演），农场主起初对他不屑一顾，之后发生了更多故事。故事基于Thomas Savage在1967年发布的小说，在Jane Campion镜头下雄伟壮丽的西部，是犹如天空一般辽阔的电影画卷。同时也让人类的情感分毫毕现，像一根纤细的草，却又异常锋利。<br><img src="/2021/12/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-3/ThePoweroftheDog.jpeg"></p>
<p>提名: West Side Story, The Card Counter, The Velvet Underground, The Lost Daughter, The Electrical Life of Louis Wain, I’m Your Man, King Richard, The Green Knight, The Truffle Hunters</p>
<p>生词：<br>misanthropic rancher 愤世嫉俗的农场主<br>a reedy（芦苇般）, dreamy teenager 精力充沛，充满梦想的少年<br>contempt 轻视<br>sinewy 强壮<br>a blade of grass 一叶草<br>staggeringly tender 惊人的／无比温柔<br>sturdy delicacy 粗犷细腻<br>bittersweet 苦乐参半<br>we’re all works in progress, unfinished beings whose only imperative is to turn toward the light 我们一直在路上，未竟的道路最终都会走向光明。<br>radiant 光辉<br>chronicles 把…载入编年史／历史<br>star-studded 群星荟萃<br>neglected 忽视<br>semiautobiographical 半自传<br>subtle 微妙的<br>captivating 迷人的<br>facets 方面<br>mass grave 乱葬岗<br>girlhood 少女时代<br>compact 紧凑<br>potent 强有力<br>superbly 极佳的<br>intersecting 相交／贯穿<br>A singer with great drive and discipline 一个拥有十足干劲和自律的歌手<br>with searching openness 根据公开资料显示（？）<br>rarefied 高深的／稀薄的／冷门领域<br>unlucrative 不幸的<br>examines 审视<br>feverishly 狂热的<br>takes a backseat 排在次要位置<br>wrought 精致<br>precocious 老成的<br>shimmery beauty 闪闪发光的美<br>shivery 颤抖<br>rendering 表演／翻译<br>treacherous 不可信任的<br>scheming Scots 诡计多端的苏格兰人<br>swimmingly 流畅<br>gorgeous 华丽<br>drama—adapted 戏剧改编<br>gig 现场表演／临时工作<br>nudge 推动<br>twig 树枝<br>bounty 奖金<br>We’ve all earned it 我们都值得这一切<br>copiously 大量的<br>Honorable mentions 荣誉提名</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-Metacritic评选的2021年度十佳PC游戏</title>
    <url>/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.gamespot.com/articles/best-pc-games-of-2021-according-to-metacritic/1100-6498757/">原文链接</a> </p>
<p>全都没玩过，甚至基本都没听过，看来确实是老了。。。</p>
<hr>
<p><em>本文提到的产品完全是我们编辑的独立选择。如果你通过我们的链接购买游戏的话，GameSpot会得到一些佣金。</em></p>
<h2 id="Metacritic评选的2021年度十佳PC游戏"><a href="#Metacritic评选的2021年度十佳PC游戏" class="headerlink" title="Metacritic评选的2021年度十佳PC游戏"></a>Metacritic评选的2021年度十佳PC游戏</h2><h3 id="PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏"><a href="#PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏" class="headerlink" title="PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏"></a>PC游戏爱好者们今年有理由感到高兴，毕竟今年有很多的优秀游戏</h3><hr>
<p>今年也许是被刚上市的PS5和xbox series X|S统治的一年，但是PC游戏在2021年也比以往更加出色。诸多游戏平台充斥着独立制作和3A大作的标题，但是他们中哪一款是最出色的呢？通过GameSpot的兄弟网站Metacritci，我们优中选优，一致讨论出了即使批评家们也挑不出毛病的10款PC游戏。列出的结果包含了众多体裁，但是他们都有共同点，至少有一点是一样的：他们在2021年为你们贡献了最佳的游戏乐趣。</p>
<h2 id="终焉之莉莉：骑士寂夜（Ender-Lilies-Quietus-of-the-Knights）"><a href="#终焉之莉莉：骑士寂夜（Ender-Lilies-Quietus-of-the-Knights）" class="headerlink" title="终焉之莉莉：骑士寂夜（Ender Lilies: Quietus of the Knights）"></a>终焉之莉莉：骑士寂夜（Ender Lilies: Quietus of the Knights）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/enderlilies.jpg"><br>受到<code>空洞骑士</code>和<code>黑暗之魂</code>的启发并将其二者融合，并伴随着大量的<code>银河战士</code>设计的影响，你将体验到的是一场美味的2D动作角色扮演游戏的盛宴，让你直到结尾也回味无穷。更棒的是，<code>终焉之莉莉</code>在以往那些老掉牙的探索和紧张战斗的套路中加入了一些现代化的改进，沿着路线攻克一些非常棘手的任务然后直接将你置于最强的boss之中，这个游戏中都将可能发生。</p>
<p>Meta评分: 86</p>
<h2 id="死亡循环（Deathloop）"><a href="#死亡循环（Deathloop）" class="headerlink" title="死亡循环（Deathloop）"></a>死亡循环（Deathloop）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/deathloop.jpeg"><br>在土拨鼠日带着抢，身怀时间操控的能力，并且口吐芬芳，这听起来像是美好时光的秘方，而在<code>死亡循环</code>里，这些元素烹制出了2021年的最佳游戏之一。<code>死亡循环</code>主要侧重于其绝妙的时间循环的玩法，但这游戏的美妙之处也在于如何在每一次新的循环中奖励你新的知识，技巧，以及最终逃离暴力的黑礁大陆之后，产生的顿悟。</p>
<p>这很可能是开发商Arkane目前的最佳作品，一个无尽的沙盒，充满创造力和魅力，并且满溢着个人风格和充满自信的大屠杀。</p>
<p>Meta评分: 86</p>
<span id="more"></span>
<h2 id="质量效应：传奇版（Mass-Effect-Legendary-Edition）"><a href="#质量效应：传奇版（Mass-Effect-Legendary-Edition）" class="headerlink" title="质量效应：传奇版（Mass Effect: Legendary Edition）"></a>质量效应：传奇版（Mass Effect: Legendary Edition）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/masseffect.jpeg"><br>如果你找一个最佳性价比的经典系列游戏的重制版，那<code>质量效应：传奇版</code>完美符合你的要求。即使是BioWare原作的科幻三部曲依旧散发着巨大的魔力。游戏首次加入一些适当的升级，让游戏更加现代化，上市后便连续两周位列销量榜首，传奇版几乎包括了薛帕德的传奇故事的所有篇章-删减了质量效应3的庞杂的多人模式以及少量的其他琐碎内容-顶尖的视觉效果，并在背后进行了若干调整，成就了这个系列的决定性版本。</p>
<p>Meta评分: 86</p>
<h2 id="漫野奇谭（Wildermyth）"><a href="#漫野奇谭（Wildermyth）" class="headerlink" title="漫野奇谭（Wildermyth）"></a>漫野奇谭（Wildermyth）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/wildermyth.jpeg"><br><code>漫野奇谭</code>切中了几个电视游戏设计的要害。他的美术风格像是让活生生的童话故事走进生活，他的玩法取自回合制RPG游戏的元素，通过巧妙的融合将二者融合为一种游戏体裁，而其天然的好上手让这游戏无论是玩一场马拉松的长度还是午饭间隙的一局都非常合适。对于一些特殊体裁，很少有电视游戏可以掌握休闲和硬核玩法之间的平衡并在特定的体裁领域提供新的东西，但是<code>漫野奇谭</code>接受了这个挑战并提供了一份不错的体验。</p>
<p>Meta评分: 87</p>
<h2 id="杀手3（Hitman-3）"><a href="#杀手3（Hitman-3）" class="headerlink" title="杀手3（Hitman 3）"></a>杀手3（Hitman 3）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/hitman3.jpg"><br>所有的故事都会走向终点，而对于47号特工来说，在经历了这么多年的全球旅行并对那些可望不可及的大人物执行了迟到的正义后，他会在<code>杀手3</code>迎来一个完美的终章。经历了前两作的打磨，<code>杀手3</code>的品质已经非常上乘，你可以沉浸在一系列的沙盒场景中度过大量游玩时光，并利用你的完美伪装来完成宿命般的屠杀。</p>
<p>开发商IO Interactive维持了游戏一贯的丰富内容，包括难以捉摸的目标人物，甚至在PC上加入了VR支持。第二年计划开发的内容也使得游戏的未来非常明朗，<code>杀手3</code>将继续在环绕全球的旅程中进行他优雅而致命的暗杀。</p>
<p>Meta评分: 87</p>
<h2 id="双人成行（It-Takes-Two）"><a href="#双人成行（It-Takes-Two）" class="headerlink" title="双人成行（It Takes Two）"></a>双人成行（It Takes Two）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/ittakestwo.jpeg"><br>这一年中不乏狂野而具有想象力的游戏发布，<code>双人成行</code>则是2021年中出类拔萃的存在。一对即将分崩离析的伙伴踏上一段奇妙的冒险，<code>双人成行</code>讲述了一个关于爱，失去以及混沌的故事。这些都囊括在一个个精妙的合作谜题和舞台中，它的美术风格令人印象深刻，最后以一个令人满意的结尾呈现。</p>
<p>Meta评分: 88</p>
<h2 id="脑航员2／疯狂世界2（Psychonauts-2）"><a href="#脑航员2／疯狂世界2（Psychonauts-2）" class="headerlink" title="脑航员2／疯狂世界2（Psychonauts 2）"></a>脑航员2／疯狂世界2（Psychonauts 2）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/psychonauts2.jpeg"><br><code>脑航员2</code>里有太多有趣的亮点，包括设计很好的角色，杰出的音效，但是其美术风格是游戏真正的闪光点，为你创造难以忘怀的体验。这些元素融合在坚实的冒险中，确切的契合着游戏的初心，<code>脑航员2</code>的开发商Double Fine在这方面做到了最佳，通过大脑的等级和充满想象力的地点构建一个吵闹的故事，让你和脑中的邪恶战斗并在一路上学到一些知识。</p>
<p>Meta评分: 89</p>
<h2 id="神笔狗良（Chicory-A-Colorful-Tale）"><a href="#神笔狗良（Chicory-A-Colorful-Tale）" class="headerlink" title="神笔狗良（Chicory: A Colorful Tale）"></a>神笔狗良（Chicory: A Colorful Tale）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/chicory.jpg"><br>尽管这一年在各种平台上发布了各种体裁的游戏和技术的展示，以及如何翻新老游戏的历程，<code>神笔狗良</code>依然是2021年并列最佳的游戏。有趣谜题的集合，尽情宣泄的画笔，多彩的角色，在数个小时的游玩中，<code>神笔狗良</code>将其不可思议的关联在一块。游戏唤起几乎每个人都有的和内心邪恶的斗争以及自我怀疑的处理，<code>神笔狗良</code>老练的将幽默和情感上的悬念融合，在一个你创建的独特视觉世界中贡献了顿悟自我的杰作。</p>
<p>Meta评分: 90</p>
<h2 id="极限竞速：地平线5（Forza-Horizon-5）"><a href="#极限竞速：地平线5（Forza-Horizon-5）" class="headerlink" title="极限竞速：地平线5（Forza Horizon 5）"></a>极限竞速：地平线5（Forza Horizon 5）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/forzahorizon5.jpeg"><br>极限竞速：地平线系列的最后一作是一场几乎没有缺点的纯粹享受。点燃所有的气缸，在重重阻碍的墨西哥之旅中体验瑰丽的风景，<code>地平线5</code>是一场汽车文化的盛宴。不仅仅是精美渲染的汽车合集以及多种多样的赛车道，<br>每次当你的收藏中加入新车时，<code>地平线5</code>都会在整个体验中给予你令人赞叹的个人体验。以华丽的画面表现在引擎盖下的马力和一些最精密的赛车部件，<code>地平线5</code>堪称是开放世界赛车游戏的天花板。</p>
<p>Meta评分: 91</p>
<h2 id="极乐迪斯科-最终剪辑版（Disco-Elysium-The-Final-Cut）"><a href="#极乐迪斯科-最终剪辑版（Disco-Elysium-The-Final-Cut）" class="headerlink" title="极乐迪斯科:最终剪辑版（Disco Elysium: The Final Cut）"></a>极乐迪斯科:最终剪辑版（Disco Elysium: The Final Cut）</h2><p><img src="/2021/12/24/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-Metacritic%E8%AF%84%E9%80%89%E7%9A%842021%E5%B9%B4%E5%BA%A6%E5%8D%81%E4%BD%B3pc%E6%B8%B8%E6%88%8F/discoelysium.jpeg"><br>在首部作品发布两年后，<code>极乐迪斯科</code>在2021年带着他的乐队回归了。这款早已饱受赞誉的游戏是关于谋杀和扮演一个侦探的故事，这个侦探同时也不得不面对个人失败的情感，而最终剪辑版更是一个残酷侦探故事的顶级展现。<br>强大的声优给这个故事带来了新的生命力，游戏性经过了一些内外的调整，新的内容也加入了冒险中，以及一些关键的更新使得游戏的一切都比以往更好。</p>
<p>独一无二的画风，令人迷幻的谜题，以及电视游戏中最佳的搞笑桥段，<code>极乐迪斯科</code>已经不能更好了。</p>
<p>Meta评分: 91</p>
<hr>
<p>time-manipulating 时间操控<br>charisma 魅力<br>carnage 大屠杀<br>oozes 滲出；充满<br>trilogy 三部曲<br>remaster 重制版<br>provided the best possible value for money 提供最高的性价比。<br>chart-topping 排行榜榜首<br>saga 传奇故事<br>fantastic 荒诞，可笑，巨大<br>vibrant 充满活力的<br>turn-based 回合制<br>catering 承办酒席<br>rises up to the challenge 迎接挑战<br>considered 认为；考虑过的<br>people who considered themselves to be untouchable 认为自己不可触碰的人<br>pure polish and class 纯正上等<br>revel 狂欢<br>karmic 业力；宿命<br>carnage 屠杀<br>assassination 暗杀<br>stands out from the pack 脱颖而出<br>saw no shortage of 不乏<br>quirky 古怪的<br>bickering 争吵的<br>on the rocks 岌岌可危<br>turmoil 混乱<br>powerhouses 强大的集团；强壮的人<br>rip-roaring 吵闹的<br>cerebral 大脑的<br>solid 坚实的；坚硬的<br>consoles 安慰／控制台<br>cathartic 宣泄的<br>plays out 演出<br>expertly 熟练的<br>cliffhangers 悬念<br>masterpiece 杰作<br>self-reflection 自我反省<br>visually distinctive 视觉上与众不同<br>bliss 幸福<br>pure V8 bliss 纯粹的幸福；纯粹的快乐<br>cylinders 圆筒；气缸<br>gorgeous 瑰丽；非常漂亮<br>beautifully-rendered 渲染精美<br>under its hood 在引擎盖下<br>horsepower 马力<br>stellar 恒星的；星光闪耀的；优秀的<br>grapple 搏斗<br>hard-hitting 直言不讳的<br>banter 调侃<br>mind-bending 心神不宁</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻翻译-考古发现罕见的中世纪符文</title>
    <url>/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/</url>
    <content><![CDATA[<p><a href="https://www.smithsonianmag.com/smart-news/newly-discovered-norwegian-runes-might-contain-a-medieval-joke-180979381/">原文链接</a> </p>
<hr>
<h2 id="考古学家发现并开始破译罕见的中世纪符文"><a href="#考古学家发现并开始破译罕见的中世纪符文" class="headerlink" title="考古学家发现并开始破译罕见的中世纪符文"></a>考古学家发现并开始破译罕见的中世纪符文</h2><h3 id="这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，"><a href="#这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，" class="headerlink" title="这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，"></a>这个刻了字的骨头是最新发现的出土文物，同时也是近几十年首次在奥斯陆有此发现，</h3><p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone.png"></p>
<p>去年下半年，挪威的考古学家在几天内连续有了惊人的发现，在奥斯陆<a href="https://www.middelalder.no/middelalderbyen-i-dag/middelalderparken">中世纪公园</a>的不同区域出土了两件罕见的符文文物。</p>
<p><a href="https://www.niku.no/">挪威国家遗产研究中心</a> (NIKU) 的<a href="https://www.niku.no/ansatt/solveig-thorkildsen/">Solveig Thorkildsen</a>和<a href="https://www.niku.no/en/ansatt/ingeborg-hornkjol/">Ingeborg Hornkjøl</a>在不断的<a href="https://www.niku.no/prosjekter/middelalderparken/">挖掘过程</a>中发现了这些文物，其中一个骨头上雕刻了挪威语铭文，另一个的符文则同时由拉丁语和挪威文字写就。根据<a href="https://www.niku.no/2021/12/unike-runefunn-i-middelalderparken/">声明</a>，符文骨是30多年来在挪威首都首次有这种发现。</p>
<p>团队在结束一天工作的时候，Thorkildsen发现了在地上的一个巨大骨头。她和同事开玩笑说：”看，这上面有符文！”</p>
<p>研究员捡起骨头然后把它翻过来，她震惊的发现在骨头的表面真的雕刻了14个符文。</p>
<p>“当时我的心脏狂跳，”Thorkildsen在声明中回忆说，”这次挖掘我心愿单的第一位就是找到符文。”NIKU介绍，符文骨可能是从马或牛的肋骨上取下的。至今为止在奥斯陆只发现了27块这样的骨头。</p>
<p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone2.png"></p>
<p>在Thorkildsen的发现几天后，Hornkjøl也有了同样令人振奋的发现。当时她站在一个用于灌满水的深坑中，她注意到一片木头被冲到了沟中。就像之前被翻过来的骨头一样，棍上的符文可追溯到中世纪。</p>
<p>这次同时发现两件刻字的文物，是及其罕见的，这将帮助研究者了解更多关于奥斯陆中世纪居民的信息。尽管文物还暂未在实验室中研究，考古学家已经推断这两个符文可追溯到公元1100年至1350年。</p>
<p>“每一次符文的发现都很重要，这将告诉我们更多关于中世纪的人民的喜好，且愿意将这些分享给周围的人，”来自奥斯陆大学的符文学专家Kristel Zilmer在一份声明中说道。”两份发现的符文提示了在那个时期人民的知识和兴趣的多样性。”</p>
<p>Zilmer初步研究发现在木板条符文的四面中，有三面刻着符文文字。文字包含拉丁语<code>manus Domine or Domini</code>，这可能是祷告的一部分，”Into your hands, O Lord, I commend my spirit. You have redeemed me, O Lord, O God of truth.”（学者告诉<code>挪威科学</code>，中世纪基督徒经常使用符文表达简单的祷告）</p>
<p><img src="/2022/01/13/news/%E6%96%B0%E9%97%BB%E7%BF%BB%E8%AF%91-%E5%9C%B0%E8%B4%A8%E5%8F%91%E7%8E%B0%E7%BD%95%E8%A7%81%E7%9A%84%E4%B8%AD%E5%8F%A4%E7%AC%A6%E6%96%87/bone3.png"></p>
<p>一个叫Bryngjerd的北欧人也在木棒中出现，也许描述了这个女人用了符文去表达她对上帝的奉献。</p>
<p>Thorkildsen发现的骨头上的符文的含义，Zilmer提供了两种理论解释。这个物品上带有北欧符文<code>basmarþærbæin</code>-这可能是一个名字或昵称，或者这是一个对于骨头本身的描述。</p>
<p>符文学者Karen Langsholt Holmqvist告诉<code>挪威科学</code>，符文是具有高度上下文相关含义的短文本。在中世纪的挪威，只有贵族可以读写，但也有相当一部分人熟知关于词汇，姓名和名句的符文。</p>
<p>12月份是中世纪公园的研究员们的大事件月。在Thorkildsen和Hornkjøl的发现前，NIKU的考古学家发掘出了一个中世纪的遗骸，戴着王冠，手持猎鹰。<code>挪威科学</code>当时发布报告时，一个三英尺长的文物发掘出来，来自动物的骨头，可能是用于刀具或工具。雕像可能是一种斯堪的纳维亚人对猎鹰的描绘，一种狩猎的鸟类用于对杀戮野生动物。</p>
<hr>
<p>Medieval 中世纪<br>Runes 符文<br>unearthed 出土；发掘<br>inscribed 在…上写(词语、名字等);题;刻<br>only days apart 相隔几天<br>stunning 令人震惊的<br>heritage 遗产(指国家或社会长期形成的历史、传统和特色)<br>Norse 挪威语<br>inscription 碑文；铭文<br>stick with 紧随；和……呆在一起<br>ongoing 不间断的<br>excavations (对古物的)发掘;发掘现场;挖掘;开凿;挖土<br>wrapping up 总结<br>per a translation 根据翻译<br>trench 沟槽;沟;海沟;战壕;堑壕;渠;大洋沟<br>prone 有做…倾向的;俯卧的;易于遭受;有做(坏事)的倾向;易于遭受…的<br>dated to the medieval era 追溯到中世纪<br>fragments 碎片<br>runology 符文学<br>diversity 多样性<br>preliminary 初步的<br>manus 手<br>redeemed 补偿<br>The object bears the Norse inscription 该物品带有北欧符文<br>That runes are short pieces of text with highly context-dependent meanings 符文是具有高度上下文相关含义的短文本<br>a broad segment of the population 相当一部分人<br>falcon 猎鹰<br>Scandinavian depictions of falconry 斯堪的纳维亚人对猎鹰的描绘<br>figurine 雕像</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>news</tag>
      </tags>
  </entry>
  <entry>
    <title>解决maven库中无法引入Oracle_jdbc_driver</title>
    <url>/2019/11/04/tech/OracleJDBC/</url>
    <content><![CDATA[<p>1.在maven库中直接引入oracle jdbc driver是不能下载到本地的，原因是oracle的jdbc工具包不是开放给公众下载的，需要用户是oracle的注册用户才能在oracle官网下载到。</p>
<p>2.解决方式：目前没有发现更简便的方法，只能从oracle官网上下载jdbc driver的包，然后从本地upload到本地仓库。</p>
<ul>
<li><p>进入JDBC<a href="https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html">下载网站</a>，选择自己需要的JDBC driver版本，点击进入。<br><img src="/2019/11/04/tech/OracleJDBC/1.png"></p>
</li>
<li><p>下载需要的JDBC driver的jar包</p>
</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/2.png"></p>
<ul>
<li><p>如果还没有登陆oracle账号，需要你登陆以后才能下载，没有注册过的注册一个账号，这里不再赘述。</p>
</li>
<li><p>下载完成后，进入下载完成的文件夹。在这里需要手动执行命令，在该文件夹打开git窗口，如何在windows安装git请自行百度。执行如下命令。</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn deploy:deploy-file -Dmaven.test.skip=<span class="literal">true</span> -Dfile=ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.0.0.7 -Dpackaging=jar -DrepositoryId=localmaven -Durl=http://localhost/nexus/content/repositories/releases</span><br></pre></td></tr></table></figure>

<p>各个参数含义如下：</p>
<p>-Dmaven.test.skip ：是否跳过jar包检测。这种官方的包，我们不需要对其进行测试，设置为true即可。</p>
<p>-Dfile：需要上传的jar包名。建议直接在jar包所在目录执行上述命令，可以避免再输入jar包的地址。</p>
<p>-DgroupId，-DartifactId，-Dversion：jar包在本地maven库中的地址。理论上这三个值都是自己定义的，只要自己能够区分出来即可。建议地址不要和官方的maven地址完全一致，改一个版本号，或者artifactId都行，这样可以避免自动从官方maven库下载jar包，导致还是不能引入。</p>
<p>-Dpackaging：打包方式。一般选择下载的是jar包，这里也写jar就行。</p>
<p>-DrepositoryId：部署的仓库ID。这个ID配置在maven的setings.xml中，参考如下：</p>
</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/3.png"></p>
<p>  自行写入本地仓库的用户名和密码。</p>
<p>  -Durl：部署的本地仓库的地址。</p>
<ul>
<li>执行完成后，显示如下页面，就表示上传成功。</li>
</ul>
<p><img src="/2019/11/04/tech/OracleJDBC/4.png"></p>
<ul>
<li><p>在项目的pom.xml文件下需要做如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加本地仓库地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>java.net2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入oracle包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--oracle--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据爬虫实践-爬取历年东西部周最佳对比</title>
    <url>/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>历年周最佳的数据来自于NBA数据官网，链接为 <a href="http://www.stat-nba.com/award/item18.html">http://www.stat-nba.com/award/item18.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/1.png"></p>
<p>这里可以看到每个赛季的周最佳球员。然后每个球员旁边有个数据的链接，表示的就是这名球员当周的平均数据。比如11月11日-11月17日的东部周最佳是武切维奇，其数据链接为<a href="http://www.stat-nba.com/player/3672.html">http://www.stat-nba.com/player/3672.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/2.png"></p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="爬取周最佳球员"><a href="#爬取周最佳球员" class="headerlink" title="爬取周最佳球员"></a>爬取周最佳球员</h3><p>首先看周最佳的页面，链接是<a href="http://www.stat-nba.com/award/item18.html%EF%BC%8C%E9%80%89%E4%B8%AD%E6%AD%A6%E5%88%87%E7%BB%B4%E5%A5%87%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%8C%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%EF%BC%8C%E9%80%89%E6%8B%A9%E2%80%9C%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E2%80%9D%E3%80%82%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A">http://www.stat-nba.com/award/item18.html，选中武切维奇的名字，右键打开右键菜单，选择“查看页面元素”。出现如下页面：</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/3.png"></p>
<p>注意，我们需要获取到的是<strong>所有的周最佳数据</strong>，而不是某个人的，因此我们需要找到这个页面元素的父元素，因此才能找到这个父元素下面的所有子元素-即所有的周最佳数据。</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/4.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如图所示，周最佳数据的节点来自于&lt;td class=&#x27;current&#x27;&gt; -&gt; &lt;table class=&#x27;stat-box&#x27;  style=&#x27;width:170px;border:0&#x27;&gt;  -&gt; &lt;td&gt;</span><br><span class="line"></span><br><span class="line">根据网页上下文的查看，可以知道&quot;&lt;td class=&quot;current&quot;&gt;是赛季的节点，&lt;table class=&quot;stat-box&quot; style=&quot;width:170px;border:0&quot;&gt;是每个赛季下每周的节点，而&lt;td&gt;就是每周下面每个球员的节点。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>因此我们根据节点的继承关系，可以写出如下的基本的爬虫逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取周最佳页面</span></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.stat-nba.com/award/item18.html&quot;</span>).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 格式化为lxml</span></span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="comment"># 查找&lt;td class=&quot;current&quot;&gt; 获取各个赛季</span></span><br><span class="line">outResult = soup.find_all(<span class="string">&quot;td&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;current&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outResult)):</span><br><span class="line">    single = outResult[i]</span><br><span class="line">    <span class="comment"># 获取每赛季数据 </span></span><br><span class="line">    data = single.parent.find_all(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;width:170px;border:0&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        singleData = data[j]</span><br><span class="line">        <span class="comment"># 获取周</span></span><br><span class="line">        week = singleData.find(<span class="string">&quot;th&quot;</span>)</span><br><span class="line">        tdList = singleData.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tdList)):</span><br><span class="line">            singleTd = tdList[k]</span><br><span class="line">            <span class="built_in">print</span>(week.text, singleTd.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/5.png"></p>
<h3 id="爬取周最佳数据"><a href="#爬取周最佳数据" class="headerlink" title="爬取周最佳数据"></a>爬取周最佳数据</h3><p>接下来我们爬取每个球员的周最佳数据，点击球员旁边的“数据”按钮，会跳转到周数据页面。</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/6.png"></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/7.png"></p>
<p>根据看到数据页面是在球员td标签下的第二个a标签下</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/8.png"></p>
<p>根据a标签的结构使用如下代码来获取球员数据的链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tdData = singleTd.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tdData) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 爬取最佳周数据</span></span><br><span class="line">    playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>获取到链接之后，按照前文所述来爬取球员的详细数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取最佳周数据</span></span><br><span class="line">playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">playerHtml = urlopen(playerUrl).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">playerSoup = BeautifulSoup(playerHtml, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">playerTable = playerSoup.find(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">    playerStatList = playerTable.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(playerStatList)):</span><br><span class="line">            playerStat = playerStatList[m]</span><br><span class="line">            <span class="comment"># 打印数据</span></span><br><span class="line">            <span class="built_in">print</span>(playerStat.text)</span><br></pre></td></tr></table></figure>

<h3 id="输出数据到Excel"><a href="#输出数据到Excel" class="headerlink" title="输出数据到Excel"></a>输出数据到Excel</h3><p>将前文进行整合，并将数据输出到Excel，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlwt <span class="keyword">as</span> xlwt</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单元格格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_style</span>(<span class="params">name=<span class="string">&#x27;Times New Roman&#x27;</span>, height=<span class="number">220</span>, bold=<span class="literal">False</span></span>):</span></span><br><span class="line">    style = xlwt.XFStyle()</span><br><span class="line">    font = xlwt.Font()</span><br><span class="line">    font.name = name</span><br><span class="line">    font.bold = bold</span><br><span class="line">    font.color_index = <span class="number">4</span></span><br><span class="line">    font.height = height</span><br><span class="line">    style.font = font</span><br><span class="line">    <span class="keyword">return</span> style</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.stat-nba.com/award/item18.html&quot;</span>).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">soup = BeautifulSoup(html, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">outResult = soup.find_all(<span class="string">&quot;td&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;current&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 创建excel</span></span><br><span class="line">f = xlwt.Workbook()</span><br><span class="line">sheet1 = f.add_sheet(<span class="string">&#x27;周最佳数据&#x27;</span>, cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">style = set_style()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(outResult)):</span><br><span class="line">    single = outResult[i]</span><br><span class="line">    <span class="comment"># 2000年以前数据不再显示</span></span><br><span class="line">    <span class="keyword">if</span> single.text.startswith(<span class="string">&quot;19&quot;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 获取每赛季数据</span></span><br><span class="line">    data = single.parent.find_all(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;width:170px;border:0&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        singleData = data[j]</span><br><span class="line">        <span class="comment"># 打印周</span></span><br><span class="line">        week = singleData.find(<span class="string">&quot;th&quot;</span>)</span><br><span class="line">        tdList = singleData.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tdList)):</span><br><span class="line">            singleTd = tdList[k]</span><br><span class="line">            <span class="comment"># 暂停随机时间，以避免被反爬虫</span></span><br><span class="line">            sleeptime = random.randint(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">            time.sleep(sleeptime / <span class="number">1000</span>)</span><br><span class="line">            tdData = singleTd.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="comment"># 获取球员名</span></span><br><span class="line">            playerName = tdData[<span class="number">0</span>].text</span><br><span class="line">            <span class="built_in">print</span>(single.text, week.text, playerName)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tdData) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 爬取最佳周数据</span></span><br><span class="line">                playerUrl = tdData[<span class="number">1</span>].attrs[<span class="string">&#x27;href&#x27;</span>].replace(<span class="string">&quot;..&quot;</span>, <span class="string">&quot;http://www.stat-nba.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                playerHtml = urlopen(playerUrl).read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                playerSoup = BeautifulSoup(playerHtml, features=<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">                playerTable = playerSoup.find(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;stat_box&quot;</span>&#125;)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">                    playerStatList = playerTable.find_all(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">                sheet1.write(num, <span class="number">0</span>, single.text, style)</span><br><span class="line">                sheet1.write(num, <span class="number">1</span>, week.text, style)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(playerTable, <span class="string">&#x27;find_all&#x27;</span>):</span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(playerStatList)):</span><br><span class="line">                        playerStat = playerStatList[m]</span><br><span class="line">                        <span class="comment"># 打印赛季</span></span><br><span class="line">                        sheet1.write(num, <span class="number">1</span> + m, playerStat.text, style)</span><br><span class="line">                num = num + <span class="number">1</span></span><br><span class="line">f.save(<span class="string">&#x27;nbastat-week.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>输出的结果如下：</p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/9.png"></p>
<h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>分析过程我就懒得再写一遍了，之前已经将分析结果发布到虎扑，链接是<a href="https://bbs.hupu.com/30738461.html">https://bbs.hupu.com/30738461.html</a></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/10.png"></p>
<p><img src="/2019/11/20/tech/Python%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5-%E7%88%AC%E5%8F%96%E5%8E%86%E5%B9%B4%E4%B8%9C%E8%A5%BF%E9%83%A8%E5%91%A8%E6%9C%80%E4%BD%B3%E5%AF%B9%E6%AF%94/11.png"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用hexo和github搭建个人博客</title>
    <url>/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="github建立个人网站"><a href="#github建立个人网站" class="headerlink" title="github建立个人网站"></a>github建立个人网站</h2><p>1.github的账号申请不再赘述<br>2.打开github.com, 点击new, 新建一个项目<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png"><br>3.输入项目名称, 注意项目名称的格式必须是”用户名.github.io”的格式<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png"><br>4.点击Create Repository完成项目新建<br>5.点击新建的项目, 进入settings, 往下找到GitHub Pages, 点击Choose a theme, 选择一个主题后, 点击select theme就完成了网站的发布<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.png"><br>6.在浏览器输入”用户名.github.io”, 就可以看到github为你默认创建的首页  </p>
<h2 id="hexo搭建博客"><a href="#hexo搭建博客" class="headerlink" title="hexo搭建博客"></a>hexo搭建博客</h2><p>1.在使用hexo搭建博客之前, 需要完成几个基础工作<br><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">安装git</a><br><a href="https://help.github.com/cn/articles/adding-a-new-ssh-key-to-your-github-account">新增ssh key到github</a><br><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html">安装node.js</a><br>2.在本地拉取github上刚刚创建的网页项目(用户名.github.io)<br>3.在项目目录下新建一个文件夹, 可以随意命名, 比如hexo<br>4.进入hexo目录, windows下右键空白处, 点击Git Bash Here<br>5.依次执行命令<br>npm install hexo-cli -g  (安装hexo)<br>hexo init  (初始化网站)<br>npm install hexo-deployer-git –save  (安装hexo发布到git的插件)<br>中间遇到需要确认的信息, 直接按回车即可<br>6.打开hexo目录下的_config.yml文件, 有几个地方可以进行修改<br>title: 你的网站名字<br>author: 网站作者<br>theme: 去<a href="https://hexo.io/themes/">hexo主题</a>可以选择, 注意要先将主题下载到hexo/themes下才可选择该主题<br>注意: <strong>必须要修改的部分是deploy, 改成如下格式</strong>  </p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>其他配置的详细说明在<a href="https://hexo.io/docs/configuration.html">hexo配置文件说明</a><br>7.接下来就可以开始写博客了<br>使用命令hexo n “博客标题”, 即完成了一个新的博客文件的创建<br>该命令会在hexo/source/_posts目录下新建一个”博客标题.md”的文件<br>该文件内容格式如下<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png"><br>正文内容使用markdown语法进行编写, 至于markdown怎么写, 可以参考<a href="http://www.markdown.cn/">markdown官方文档</a><br>8.博客写完之后, 保存文件, 然后依次执行如下命令<br>hexo g  (根据md文件创建静态网页文件, 注意每次更新博客内容都需要执行这个命令)<br>hexo s  (这一步是启动本地hexo服务器, 主要是为了本地预览博客效果, 浏览器打开localhost:4000预览效果)<br>hexo d (发布网页到github)<br>9.浏览器打开”用户名.github.io”即可看到你刚刚写的博客内容<br><img src="/2019/10/08/tech/%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.png">  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说, hexo+github搭建博客非常的简便, hexo内置的几种主题也都非常的简洁美观, 对于既想要有逼格的有自己的个人博客网站, 又不想太麻烦的人来说, 是个不错的选择</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>官方文档解释MySQL最左匹配(最左前缀)原则</title>
    <url>/2019/10/15/tech/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E9%87%8AMySQL%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D(%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80)%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h2><p>关于最左匹配原则的解释, 网上找了很多, 但是我感觉都不是特别准确, 于是一怒之下<br>直接找了官网的文档, 一下子就清晰了. 下面贴下官网的解释, 然后我自己翻译了一下.  </p>
<h3 id="来自官方文档的解释"><a href="#来自官方文档的解释" class="headerlink" title="来自官方文档的解释"></a>来自官方文档的解释</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html">原文链接</a>  </p>
<blockquote>
<p>MySQL can create composite indexes (that is, indexes on multiple columns).<br> An index may consist of up to 16 columns. For certain data types,<br> you can index a prefix of the column (see<br> <a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">Section 8.3.5, “Column Indexes”</a>).  </p>
</blockquote>
<p>MySQL可以创建联合索引(即, 多列的索引). 一个索引可以包含最多16列. 对于<br>某些数据类型, 你可以索引列的前缀(这里说的是对于Blob和Text类型, 索引列的前几位就可以,<br>如INDEX(blob_col(10)), 详见<a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">索引文档</a>)  </p>
<blockquote>
<p>MySQL can use multiple-column indexes for queries that test all the columns in the index,<br>or queries that test just the first column, the first two columns, the first three columns, and so on.<br>If you specify the columns in the right order in the index definition,<br>a single composite index can speed up several kinds of queries on the same table.  </p>
</blockquote>
<p>MySQL的联合索引可以用于包含索引中所有列的查询条件的语句, 或者包含索引中的第一列的查询条件的语句,<br>以及索引中前两列, 索引中的前三列, 以此类推. 如果你在索引定义中以正确的顺序指定列,<br>那么联合索引就可以加速同一张表中的多个不同类型的查询.  </p>
<blockquote>
<p>A multiple-column index can be considered a sorted array, the rows of<br>which contain values that are created by concatenating the values of the indexed columns.  </p>
</blockquote>
<p>一个联合索引可以看作是一个有序队列, 里面有值的列是根据连接索引列的值创建的.(这句可能不准确)  </p>
<blockquote>
<p>Note<br>As an alternative to a composite index, you can introduce a column that<br>is “hashed” based on information from other columns. If this column is<br>short, reasonably unique, and indexed, it might be faster than a “wide”<br>index on many columns. In MySQL, it is very easy to use this extra column:  </p>
</blockquote>
<p>提示<br>作为联合索引的一个替代项, 你可以采用一个Hash值列, 这个列的Hash值来自其他的列.<br>如果该列简短, 合理唯一, 且被索引, 那该列就可能比一个很”宽”的由多个列构成的索引<br>更快. MySQL里可以很容易的使用这种列:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> hash_col<span class="operator">=</span>MD5(CONCAT(val1,val2))</span><br><span class="line">  <span class="keyword">AND</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>Suppose that a table has the following specification:</p>
</blockquote>
<p>假设有如下表定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id         <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name  <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX name (last_name,first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The name index is an index over the last_name and first_name columns.<br>The index can be used for lookups in queries that specify values in a known<br>range for combinations of last_name and first_name values. It can also be used<br>for queries that specify just a last_name value because that column is a<br>leftmost prefix of the index (as described later in this section).<br>Therefore, the name index is used for lookups in the following queries:  </p>
</blockquote>
<p>索引name是一个包含了last_name和first_name列的索引. 该索引可以用于为last_name<br>和first_name值的组合指定一个已知范围内的查询. 同样也可以用于只指定了last_name列值的查询,<br>因为这个列是索引的一个最左前缀(就如下一节所说). 因此, 索引name可以用于下列的查询语句:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span> <span class="keyword">AND</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> (first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;Jon&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> first_name <span class="operator">&gt;=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span> first_name <span class="operator">&lt;</span> <span class="string">&#x27;N&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>However, the name index is not used for lookups in the following queries:  </p>
</blockquote>
<p>然而, 索引name不能用于下列的查询:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Jones&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Suppose that you issue the following SELECT statement:  </p>
</blockquote>
<p>假设存在以下select语句:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If a multiple-column index exists on col1 and col2, the appropriate<br>rows can be fetched directly. If separate single-column indexes exist<br>on col1 and col2, the optimizer attempts to use the Index Merge optimization<br>(see Section 8.2.1.3, “Index Merge Optimization”), or attempts to find<br>the most restrictive index by deciding which index excludes more rows<br>and using that index to fetch the rows.  </p>
</blockquote>
<p>如果一个联合索引存在于col1和col2, 相应的列会被直接抓取. 如果是分为单独的索引<br>分别存在于col1和col2, 优化器会尝试利用索引联合优化(详见8.2.1.3, <a href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html">“索引联合<br>优化”</a>),<br>或者尝试去寻找包含最多列, 最大限制的索引, 并利用该索引去抓取列.  </p>
<blockquote>
<p><strong>If the table has a multiple-column index, any leftmost prefix of the<br>index can be used by the optimizer to look up rows. For example,<br>if you have a three-column index on (col1, col2, col3), you have indexed<br>search capabilities on (col1), (col1, col2), and (col1, col2, col3).</strong>  </p>
</blockquote>
<p><strong>如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如,<br>如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1),<br>(col1, col2), 以及(col1, col2, col3)</strong>  </p>
<blockquote>
<p><strong>MySQL cannot use the index to perform lookups if the columns do not<br>form a leftmost prefix of the index. Suppose that you have the SELECT<br>statements shown here:</strong>  </p>
</blockquote>
<p><strong>如果查询的列不是索引的最左前缀, 那MySQL不会将索引用于执行查询. 假设你有<br>下列查询语句:</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2 <span class="keyword">AND</span> col3<span class="operator">=</span>val3;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If an index exists on (col1, col2, col3), only the first two queries<br>use the index. The third and fourth queries do involve indexed columns,<br>but do not use an index to perform lookups because (col2) and (col2, col3)<br>are not leftmost prefixes of (col1, col2, col3).  </p>
</blockquote>
<p>如果索引存在于(col1, col2, col3), 那只有头两个查询语句用到了索引. 第三个和<br>第四个查询包含索引的列, 但是不会用索引去执行查询. 因为(col2)和(col2, col3)<br>不是(col1, col2, col3)的最左前缀  </p>
<h2 id="官方文档小结"><a href="#官方文档小结" class="headerlink" title="官方文档小结"></a>官方文档小结</h2><p>其实官方文档已经解释的非常详细了, 总结关于最左匹配的解释, 那其实只有这么<br>几句话:<br>1.按照文档, 更准确的说法应该是最左前缀原则, 即如果你创建一个联合索引, 那<br>这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀<br>就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索<br>引查询.<br>2.其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列<br>也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.<br><strong>注意, (col1, col3)会启用(col1)的索引查询</strong>  </p>
<h3 id="官方文档的其他细节"><a href="#官方文档的其他细节" class="headerlink" title="官方文档的其他细节"></a>官方文档的其他细节</h3><p>读一下官方文档, 还有很多别的发现, 跟最左前缀无关, 关于联合索引的别的细节,<br>总结如下:  </p>
<ul>
<li>联合索引最多只能包含16列  </li>
<li>blob和text也能创建索引, 但是必须指定前面多少位  </li>
<li>官方推荐了一种联合索引的替代方案: 可以额外创建一列, 其列值由联合索引包含<br>的所有列值所生成的hash值来构成(个人认为似乎破坏了第一范式的设计规则) </li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建新项目的框架</title>
    <url>/2019/10/22/tech/%E6%90%AD%E5%BB%BA%E6%96%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> 基础架构：Spring Boot / Spring Cloud</li>
<li><input checked="" disabled="" type="checkbox"> 数据库：MySQL / Oracle</li>
<li><input checked="" disabled="" type="checkbox"> 数据库层连接：Hibernate / Mybatis / JPA</li>
<li><input checked="" disabled="" type="checkbox"> 分页</li>
<li><input checked="" disabled="" type="checkbox"> 日志：Log4j / Slf4J</li>
<li><input checked="" disabled="" type="checkbox"> 数据库连接池：Druid</li>
<li><input checked="" disabled="" type="checkbox"> 消息中间件：Dubbo / Grpc</li>
<li><input disabled="" type="checkbox"> 缓存：Redis</li>
<li><input checked="" disabled="" type="checkbox"> 权限：Spring Security / Shiro</li>
<li><input checked="" disabled="" type="checkbox"> 包管理仓库：Maven / Gradle</li>
<li><input disabled="" type="checkbox"> 统一日志记录-数据库层面</li>
<li><input checked="" disabled="" type="checkbox"> JSON处理：FastJSON</li>
<li><input checked="" disabled="" type="checkbox"> 统一返回结果处理</li>
<li><input checked="" disabled="" type="checkbox"> Zookeeper</li>
<li><input disabled="" type="checkbox"> MQ组件：RabbitMQ / RocketMQ / Kafka</li>
<li><input checked="" disabled="" type="checkbox"> 统一Exception处理</li>
<li><input checked="" disabled="" type="checkbox"> 公用Util类</li>
<li><input checked="" disabled="" type="checkbox"> 测试用例：JUnit</li>
<li><input disabled="" type="checkbox"> 集群</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
  </entry>
  <entry>
    <title>用curl计算网络请求的时间</title>
    <url>/2021/11/29/tech/%E7%94%A8curl%E8%AE%A1%E6%97%B6/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://susam.in/maze/timing-with-curl.html">Timing With Curl</a></p>
<hr>
<p>当一个http请求花费了太长时间的时候，我经常用下面的命令来查找原因。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -w &quot;time_namelookup: %&#123;time_namelookup&#125;</span><br><span class="line">time_connect: %&#123;time_connect&#125;</span><br><span class="line">time_appconnect: %&#123;time_appconnect&#125;</span><br><span class="line">time_pretransfer: %&#123;time_pretransfer&#125;</span><br><span class="line">time_redirect: %&#123;time_redirect&#125;</span><br><span class="line">time_starttransfer: %&#123;time_starttransfer&#125;</span><br><span class="line">time_total: %&#123;time_total&#125;</span><br><span class="line">&quot; https://example.com/</span><br></pre></td></tr></table></figure>
<p>下面是用一条指令来实现的同样的命令，我可以在未来用到的时候，在这个页面通过三次点击快速复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -w &quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot; https://example.com/</span><br></pre></td></tr></table></figure>
<p>这个命令输入之后，一般能看到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;namelookup: %&#123;time_namelookup&#125;\nconnect: %&#123;time_connect&#125;\nappconnect: %&#123;time_appconnect&#125;\npretransfer: %&#123;time_pretransfer&#125;\nstarttransfer: %&#123;time_starttransfer&#125;\ntotal: %&#123;time_total&#125;\n&quot;</span> https://example.com/</span></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001403</span><br><span class="line">time_connect: 0.245464</span><br><span class="line">time_appconnect: 0.757656</span><br><span class="line">time_pretransfer: 0.757823</span><br><span class="line">time_redirect: 0.000000</span><br><span class="line">time_starttransfer: 0.982111</span><br><span class="line">time_total: 0.982326</span><br></pre></td></tr></table></figure>
<p>为了简洁起见，在上面的输出中，我用省略号忽略了大部分的html部分的输出。<br>下面的列表描述了输出中每一个数字的含义。这些信息直接取自curl 7.20.0版本的手册。以下是详情：</p>
<ul>
<li><em>time_namelookup</em>: 以秒为单位，表示从命令开始到域名被解析完成所需时间。</li>
<li><em>time_connect</em>: 以秒为单位，表示从命令开始到TCP请求完成连接到远程端口（或代理）所需时间。</li>
<li><em>time_appconnect</em>: 以秒为单位，表示从命令开始到SSL／SSH等请求完成到远程端口的连接／握手所需时间。（7.19.0版本后加入）</li>
<li><em>time_pretransfer</em>: 以秒为单位，表示从命令开始到文件传输开始所需时间。这包括所有的预传输命令和协议。包含所有涉及到特定协议的预传输指令和谈判（？）。</li>
<li><em>time_redirect</em>: 以秒为单位，包括所有的重定向步骤，从域名检索，连接，预传输以及在最后交换数据开始之前的传输所需时间。time_redirect展示了多个重定向请求的完整执行时间。（7.12.3版本后加入）</li>
<li><em>time_starttransfer</em>: 以秒为单位，表示从命令开始到第一个字节被传输所属时间。这包含了<em>time_pretransfer</em>，以及服务器计算结果所属的时间。</li>
<li><em>time_total</em>: 以秒为单位，表示整个操作持续到最后所需的总时间。这个时间会精确到毫秒进行展现。</li>
</ul>
<p>一个没啥用的关键细节是，<em>time_appconnect</em>和<em>time_connect</em>之间的时间差可以告诉我们SSL／TLS握手所需时间。对于一个没有SSL／TLS的干净连接，这个时间会显示为0。下面的输出证明了这件事：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot;</span> http://example.com/</span></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001507</span><br><span class="line">time_connect: 0.247032</span><br><span class="line">time_appconnect: 0.000000</span><br><span class="line">time_pretransfer: 0.247122</span><br><span class="line">time_redirect: 0.000000</span><br><span class="line">time_starttransfer: 0.512645</span><br><span class="line">time_total: 0.512853</span><br></pre></td></tr></table></figure>

<p>同样注意<em>time_redirect</em>在上面的输出中也是0。这是因为访问example.com的时候，没有重定向发生。以下是另一个例子，展示了当重定向发生时输出会是什么样子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -w <span class="string">&quot;time_namelookup: %&#123;time_namelookup&#125;\ntime_connect: %&#123;time_connect&#125;\ntime_appconnect: %&#123;time_appconnect&#125;\ntime_pretransfer: %&#123;time_pretransfer&#125;\ntime_redirect: %&#123;time_redirect&#125;\ntime_starttransfer: %&#123;time_starttransfer&#125;\ntime_total: %&#123;time_total&#125;\n&quot;</span> https://susam.in/blog</span></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">time_namelookup: 0.001886</span><br><span class="line">time_connect: 0.152445</span><br><span class="line">time_appconnect: 0.465326</span><br><span class="line">time_pretransfer: 0.465413</span><br><span class="line">time_redirect: 0.614289</span><br><span class="line">time_starttransfer: 0.763997</span><br><span class="line">time_total: 0.765413</span><br></pre></td></tr></table></figure>

<p>当网络服务遭遇一个潜在的延迟事件时，我会在多个客户端优先使用这条命令，因为这个命令返回的结果帮助我快速找到网络延迟的原因。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>用ssh加密文件</title>
    <url>/2021/12/06/tech/%E7%94%A8ssh%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://www.agwa.name/blog/post/ssh_signatures">Andrew Ayer博客</a><br>翻译水平不佳，自己学习使用</p>
<hr>
<h2 id="现在可以使用SSH密钥给任意数据加密"><a href="#现在可以使用SSH密钥给任意数据加密" class="headerlink" title="现在可以使用SSH密钥给任意数据加密"></a>现在可以使用SSH密钥给任意数据加密</h2><p>你知道吗，你可以使用ssh-keygen命令加密和验证任意数据，比如文件和发行软件？尽管这个特性并不是特别新（在2019年随着OpenSSH 8.0发布），依然很少有人知道。<br>这就有点尴尬，因为这个功能非常有用而且可以作为PGP的有效替换用以加密数据。如果你现在在用PGP加密数据，你可以考虑转到SSH签名上。</p>
<p>以下是我喜欢用SSH签名的原因：</p>
<ul>
<li><strong>不是PGP。</strong> 多年来，安全专家已经<a href="https://latacora.micro.blog/2019/07/16/the-pgp-problem.html">对PGP做出了警告</a>，包括其最重要的组件GnuPG/GPG。<br>PGP太复杂了，用户体验非常糟糕，而且充斥着门槛很高的粗糙老旧的密码学原理，</li>
<li><strong>SSH无处不在，而且用户早就有SSH密钥了。</strong> 如果你用的是 Debian Bullseye 或者 Ubuntu 20.04以及更新的版本，你已经有了足够的SSH安装版本。如果你有用Github，<br>或者任何其他的借助SSH命令来验证的服务，你也早就有了一个SSH密钥用于创建签名了。这就是为什么我对SSH签名更热衷，而不是其他PGP的替代品，比如<a href="https://github.com/aperezdc/signify">signify</a> 或者<br><a href="https://jedisct1.github.io/minisign/">minisign</a>。后两者很优秀，但是需要你安装新的软件和创建一个新的密钥，这就会阻碍更大范围的兼容性。</li>
<li><strong>SSH密钥很容易分配。</strong> SSH公钥只用一行代码就可以轻松到处复制。你不需要网络白名单或者费心去配置密钥的”信任等级”。Github作为一个密钥分配服务早就演示过，比起原先的<br>PGP密钥服务器更加简易也更加安全。你可以通过访问网页<a href="https://github.com/USERNAME.keys%E5%8E%BB%E6%A3%80%E7%B4%A2%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%9A%84SSH%E5%85%AC%E9%92%A5%E3%80%82%EF%BC%88%E6%AF%94%E5%A6%82%EF%BC%8C%E6%88%91%E7%9A%84%E5%85%AC%E9%92%A5%E5%9C%A8[https://github.com/AGWA.keys](https://github.com/AGWA.keys)%EF%BC%89">https://github.com/USERNAME.keys去检索任意用户的SSH公钥。（比如，我的公钥在[https://github.com/AGWA.keys](https://github.com/AGWA.keys)）</a><br>（这个例子可能不适用于所有的情况，毕竟Github在这里作为一个可信任的第三方，而且你也必须相信他们不会对大众的公钥作假。但是依赖于Github这样的专业安全团队作为可信赖的第三方，应该比几乎不可能用到的PGP的网络白名单更好。<br>在实践中，如果你曾经想搞清楚如何审核透明度日志，那第三方的公钥的透明度需要考虑进去。）</li>
<li><strong>SSH有可选的轻量级证书。</strong> SSH证书不是必需的（而且大部分人也用不到），但是证书可以让你的操作更轻松，SSH有一套比X.509简单很多的轻量级证书系统。这使得SSH签名和S/MIME一样是一个好的选项。</li>
</ul>
<h2 id="你现在可以使用SSH给Git提交和标签加签名"><a href="#你现在可以使用SSH给Git提交和标签加签名" class="headerlink" title="你现在可以使用SSH给Git提交和标签加签名"></a>你现在可以使用SSH给Git提交和标签加签名</h2><p>给Git的提交和标签加签名可以帮助你确认你的的仓库在被别人使用的时候，代码未曾被篡改。但是，你必须用PGP或者S/MIME来做到这件事，而我个人从2018年PGP密钥过期后就没在这件事上被困扰过。<br>马上在Git 2.34这些都会改变了，这个版本支持了SSH签名。（TODO 咋翻译都不对。。）</p>
<h2 id="文件签名"><a href="#文件签名" class="headerlink" title="文件签名"></a>文件签名</h2><p>像这样直接对一个文件进行签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -Y sign -f ~/.ssh/id_ed25519 -n file file_to_sign</span><br></pre></td></tr></table></figure>
<p>需要更改的参数如下：</p>
<ul>
<li><p><code>~/.ssh/id_ed25519</code>是你私钥的路径。例子里的是你的SSH Ed25519私钥的标准路径。如果你有一个RSA密钥，改为使用id_rsa。</p>
</li>
<li><p><code>file</code> 参数是”命名空间”，用来描述签名的目的，对于一般文件的签名，SSH将其定义为<code>file</code>，邮件的签名定义为<code>email</code>，Git则使用<code>git</code>作为签名。<br>如果你的签名用于其他目的，比如一个一般协议，你必须指明你自己的命名空间。这样，你可以避免来自一个单一协议信息的合法签名被移除后，或者附属在不同的协议信息，发起的跨协议攻击。<br>如果对于协议签名不使用特定的命名空间，那第一个协议的签名就有可能被视作第二个签名的协议，从而被认为是合法的。<br>命名空间可以是随机字符。为了保证全局的命名空间的唯一性，SSH推荐对于你自己的签名使用email作为命名空间的一部分。比如，我会使用类似于<code>protocolname-v1@agwa.name</code>的名字作为命名空间。</p>
</li>
<li><p><code>file_to_sign</code> 是要被签名的文件的路径。</p>
</li>
</ul>
<p>签名会写入一个叫做<code>file_to_sign.sig</code>的新文件中，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----BEGIN SSH SIGNATURE-----</span><br><span class="line">U1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAg2rirQQddpzEzOZwbtM0LUMmlLG</span><br><span class="line">krl2EkDq4CVn/Hw7sAAAAEZmlsZQAAAAAAAAAGc2hhNTEyAAAAUwAAAAtzc2gtZWQyNTUx</span><br><span class="line">OQAAAEDyjWPjmOdG8HJ8gh1CbM8WDDWoGfm+TTd8Qa8eua9Bt5Cc+43S24i/JqVWmk98qV</span><br><span class="line">YXoQmOYL4bY8t/q7cSNeMH</span><br><span class="line">-----END SSH SIGNATURE----- </span><br></pre></td></tr></table></figure>
<p>如果你指明了文件名，那文件签名会从该标准输入并从该标准写出。</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>签名验证稍微更复杂点。首先你需要创建一个被允许的签名者文件，该文件将邮件地址映射到公钥，类似于这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alice@example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINq4q0EHXacxMzmcG7TNC1DJpSxpK5dhJA6uAlZ/x8O7</span><br><span class="line">alice@example.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfHGCK5jjI/Oib4vRBLB9rG30A8y/Br9U75rfAYsitwFPFfl/CaTAvfRlW1lIBqOCshLWxGsN+PFiJCiCWzpW4iILkD5X5KcBBYHTq1ojYXb70BrQXQ+QBDcGxqQjcOp/uTq1D9Z82mYq/usI5wdz6f1KNyqM0J6ZwRXMu6u7NZaAwmY7j1fV4DRiYdmIfUDIyEdqX4a1Gan+EMSanVUYDcNmeBURqmTkkOPYSg8g5xYgcXBMOZ+V0ZUjreV9paKraUD/mVDlZbb/VyWhJGT4FLMNXHU6UHC2FFgqANMUKIlL4vhqc23MoygKbfF3HgNB6BNfv3s+GYlaQ3+66jc5j</span><br><span class="line">bob@example.net ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBgQuuEvhUXerOTIZ2zoOx60M/HHJ/tcHnD84ZvTiX5b</span><br></pre></td></tr></table></figure>
<p>一旦你拥有了你的被允许的签名文件，验证的步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -Y verify -f allowed_signers -I alice@example.com -n file -s file_to_verify.sig &lt; file_to_verify</span><br></pre></td></tr></table></figure>
<p>你需要修改如下参数：</p>
<ul>
<li><code>allowed_signers</code> 是被允许的签名者文件的路径。</li>
<li><code>alice@example.com</code> 是对文件加签名的用户邮件地址。该邮件地址会在允许的签名者文件里进行查找到对应的公钥。</li>
<li><code>file</code> 是”命名空间”，该参数必须匹配前文描述的签名中的命名空间。</li>
<li><code>file_to_verify.sig</code> 是签名文件的路径。</li>
<li><code>file_to_verify</code> 是被验证的文件的路径。注意该文件是从标准读入的。在前面的命令中，<code>&lt;</code>这个shell操作符用于重定向标准到该文件。</li>
</ul>
<p>如果签名是有效的，命令行会返回状态0并打印如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Good <span class="string">&quot;file&quot;</span> signature <span class="keyword">for</span> alice@example.com with ED25519 key SHA256:ZGa8RztddW4kE2XKPPsP9ZYC7JnMObs6yZzyxg8xZSk</span><br></pre></td></tr></table></figure>
<p>否则，命令行会返回非0状态并打印错误信息。</p>
<h2 id="SSH密钥的复用安全吗？"><a href="#SSH密钥的复用安全吗？" class="headerlink" title="SSH密钥的复用安全吗？"></a>SSH密钥的复用安全吗？</h2><p>简单来说：安全。</p>
<p>对一个不同协议总是要小心的对密钥进行复用。如果不注意的话，有可能导致跨协议攻击的风险。比如，当一个Git签名信息的结构和SSH协议信息的结构相似，攻击者就可以通过SSH副本挪用签名，并伪造一个Git的人工提交。</p>
<p>幸运的是，SSH协议信息的结构和ssh-keygen签名信息的结构并不相似，因此并没有这方面风险的担忧。</p>
<p>为了证明这点，我们可以参考这篇<a href="https://datatracker.ietf.org/doc/html/rfc4252#section-7">RFC 4252 section 7</a>，阐明了SSH密钥是如何在传统用途上通过SSH验证用户登录服务器。<br>RFC指出输入的签名语法拥有如下结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string    session identifier</span><br><span class="line">byte      SSH_MSG_USERAUTH_REQUEST</span><br><span class="line">string    user name</span><br><span class="line">string    service name</span><br><span class="line">string    <span class="string">&quot;publickey&quot;</span></span><br><span class="line">boolean   TRUE</span><br><span class="line">string    public key algorithm name</span><br><span class="line">string    public key to be used <span class="keyword">for</span> authentication</span><br></pre></td></tr></table></figure>
<p>第一个字段是会话标识，是个字符串。在SSH协议中，字符串的前缀由一个<a href="https://datatracker.ietf.org/doc/html/rfc4251#section-5">32位字符</a>构成。会话标识是一个<a href="https://datatracker.ietf.org/doc/html/rfc4253#section-7.2">hash</a>值。除非hash值很短，否则一般的上述签名的前三位字符都会是0。</p>
<p>同时，<a href="https://github.com/openssh/openssh-portable/blob/d575cf44895104e0fcb0629920fb645207218129/PROTOCOL.sshsig">PROTOCOL.sshsig</a>分发OpenSSH仓库，表明了如何通过<code>ssh-keygen-generated</code>签名使用SSH密钥。以下是输入的签名语法的结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define MAGIC_PREAMBLE &quot;SSHSIG&quot;</span></span><br><span class="line"></span><br><span class="line">byte[6]   MAGIC_PREAMBLE</span><br><span class="line">string    namespace</span><br><span class="line">string    reserved</span><br><span class="line">string    hash_algorithm</span><br><span class="line">string    H(message)</span><br></pre></td></tr></table></figure>
<p>在这里，头三个字节是SSH，来自magic preamble（直译是魔法序言？）。SSH协议签名输入的头三个字节之后就开始和ssh-keygen签名输入不一样，SSH客户端和ssh-keygen不会生成同样的签名。因此，在这里不会有跨协议攻击的风险，我也有绝对的信心使用现存的SSH密钥，通过ssh-keygen来对信息加密。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Dubbo无法处理自定义异常的问题</title>
    <url>/2019/11/04/tech/%E8%A7%A3%E5%86%B3Dubbo%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Dubbo有一个比较奇怪的问题，目前不知道Apache和Alibaba公司出于什么样的考虑，貌似一直都没有一个比较合适的解决方案，问题如下：</p>
<ul>
<li><p>项目搭建中你需要自定义一个本地的Exception，命名为比如BusinessException。比较一般的书写代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> linqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24 16:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 业务异常类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(Integer code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通常这个BusinessException是要能够跨模块使用的，一般放在commons或者core模块中，同时别的模块的pom.xml文件引入这些模块，使得整个项目都可以使用这个BusinessException。</p>
</li>
<li><p>问题来了，如果在A模块调用了B模块，B模块抛出了一个BusinessException，这时A模块接收到的不是BusinessException，而是一个RuntimeException，而且关于BusinessException的细节已经完全丢失，只会剩下一个类名的描述。</p>
</li>
</ul>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>关于该问题出现的原因，参考<a href="https://blog.csdn.net/qq_25673113/article/details/78574514">这篇文章</a>，归纳一下，就是在Dubbo的传输信息过程中，类ExceptionFilter.java会对Exception做一个过滤，其过滤器的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// directly throw if it&#x27;s checked exception</span></span><br><span class="line"><span class="keyword">if</span> (!(exception <span class="keyword">instanceof</span> RuntimeException) &amp;&amp; (exception <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// directly throw if the exception appears in the signature</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());</span><br><span class="line">    Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; exceptionClass : exceptionClassses) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception.getClass().equals(exceptionClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="comment">// for the exception not found in method&#x27;s signature, print ERROR message in server&#x27;s log.</span></span><br><span class="line">logger.error(<span class="string">&quot;Got unchecked and undeclared exception which called by &quot;</span> + RpcContext.getContext().getRemoteHost() + <span class="string">&quot;. service: &quot;</span> + invoker.getInterface().getName() + <span class="string">&quot;, method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, exception: &quot;</span> + exception.getClass().getName() + <span class="string">&quot;: &quot;</span> + exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line"><span class="comment">// directly throw if exception class and interface class are in the same jar file.</span></span><br><span class="line">String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());</span><br><span class="line">String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());</span><br><span class="line"><span class="keyword">if</span> (serviceFile == <span class="keyword">null</span> || exceptionFile == <span class="keyword">null</span> || serviceFile.equals(exceptionFile)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// directly throw if it&#x27;s JDK exception</span></span><br><span class="line">String className = exception.getClass().getName();</span><br><span class="line"><span class="keyword">if</span> (className.startsWith(<span class="string">&quot;java.&quot;</span>) || className.startsWith(<span class="string">&quot;javax.&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directly throw if it&#x27;s dubbo exception</span></span><br><span class="line"><span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherwise, wrap with RuntimeException and throw back to the client</span></span><br><span class="line">appResponse.setException(<span class="keyword">new</span> RuntimeException(StringUtils.toString(exception)));</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>即Dubbo在遇到异常时会这样处理：</p>
<ul>
<li>非RuntimeException不处理，直接返回</li>
<li>抛出的是方法上注明的异常，直接返回</li>
<li>如果异常类和接口类在同一jar包，直接返回</li>
<li>java或者javax目录下的异常类，直接返回</li>
<li>Dubbo自带的RpcException，直接返回</li>
<li>其他的异常，会被封装为RuntimeException返回</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>根据以上的分析，那么很显然，自定义异常是被直接封装为RuntimeException返回了，而且只带了自定义异常的类名信息，丢失了别的细节。</p>
<p>那么我们想要自定义异常进行正常返回，那只有满足这个FIlter所写的上述条件。我们可以分析一下：</p>
<ul>
<li><p>不继承RuntimeException，以检查时异常抛出。<strong>不推荐，正常的业务异常应该是运行时异常。</strong></p>
</li>
<li><p>在接口方法上要写上throws BusinessException，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">DemoUser <span class="title">getUserInfo</span><span class="params">(Long userID)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不推荐，不符合接口设计原则，且这样是把运行时异常作为检查时异常处理。</strong></p>
</li>
<li><p>把自定义异常类和接口放在同一个包目录下。<strong>不推荐，毕竟这样相当于绑定了异常类的目录，耦合性变高。</strong></p>
</li>
<li><p>改包名，以“java.”或者“javax.”来开头。<strong>不推荐，违反了类命名原则。</strong></p>
</li>
<li><p>继承Dubbo的RpcException。RpcException也是继承了RuntimeException，因此能够以RuntimeException的方式进行处理。<strong>不推荐，相当于自定义异常属于Dubbo的RpcException，这在程序设计上不合理。</strong></p>
</li>
</ul>
<p>我们发现，想要满足Dubbo的过滤器直接返回异常的条件，我们就必须做出一些违反程序设计的操作，如果一定要从这些方法中选择一种的话，相对来说，<strong>自定义异常类和接口放在同一目录下，以及继承RpcException</strong>是对于程序侵入性更小的方式。</p>
<h3 id="其他解决方式"><a href="#其他解决方式" class="headerlink" title="其他解决方式"></a>其他解决方式</h3><p>参考 <a href="https://blog.csdn.net/yangzaizi/article/details/80638306">这篇文章</a>，提供了两种解决方式：</p>
<p>1.在配置文件中配置如下，效果是：关闭ExceptionFIlter，使所有异常绕过该过滤器直接返回。<strong>不推荐，Dubbo既然设置了这个异常过滤类，一定是出于安全和功能上的考虑，直接禁用可能会引发别的问题。</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">provider:</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">-exception</span></span><br></pre></td></tr></table></figure>

<p>2.修改Dubbo源文件ExceptionFilter，使其遇到BusinessException也能直接返回。<strong>不推荐，相当于定制了本地的Dubbo包，是一个后续很容易被人忽略的大坑。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Dubbo在处理自定义异常时，会直接返回RuntimeException，且抹去自定义异常的所有细节，导致无法处理。</p>
<p>本文写下的时候，Dubbo版本为2.7.3，该问题还没有非常完美的解决方案，相对来说，把<strong>自定义异常和接口类放在同一目录下</strong>是侵入性最小的方案。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次用代码分辨坑爹保险产品的经历</title>
    <url>/2021/11/19/tech/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E8%BE%A8%E5%9D%91%E7%88%B9%E4%BF%9D%E9%99%A9%E4%BA%A7%E5%93%81%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>这两天刚好一年交一次的保险开始催我交年费，最近由于基金太绿，手头实在有点紧，因此这个年费一直拖着还没交，于是我动了是不是要退保的想法。</p>
<p>而销售则继续去年的话术，说我这个交满20年就可以不交了，现在交到12年退保太可惜了之类的。</p>
<p>今年我没有轻易把这话听进去，于是我又去搜了下这个保险产品的条例，这个产品的介绍如下图。<br><img src="/2021/11/19/tech/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E8%BE%A8%E5%9D%91%E7%88%B9%E4%BF%9D%E9%99%A9%E4%BA%A7%E5%93%81%E7%9A%84%E7%BB%8F%E5%8E%86/1.png"></p>
<p>按照我当前的情况，排除意外身故的情况，简单概括下就是：</p>
<ul>
<li>我每年交7600，交20年</li>
<li>到66岁每两年领一次总保额(总保额是50000)的8%，我这份产品从19岁开始买，到66岁总共可以领23次</li>
<li>66岁一次性给100%全保额</li>
<li>66岁开始每年领一次总保额的8%，我假设我能活到88岁，那总共领22次<span id="more"></span></li>
</ul>
<h2 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h2><p>剔除别的因素，最简单的加减算法就是</p>
<ul>
<li>交的保费是20*7600 = 152000</li>
<li>到66岁每两年领一次8%，领23次，那就是23*(50000*0.08)=92000</li>
<li>66岁一次性领100%总保额，就是50000</li>
<li>66-88岁每年领一次8%，领22次，22*(50000*0.08)=88000<br>简单说来总保费是 <strong>152000</strong>，<strong>最后收益是230000</strong></li>
</ul>
<p>其实就算是这么简单的计算，也会发现这是一份很坑的产品，230000的最终收益前提是要活到88岁。而我在39岁就会交完152000的总保费，相当于从39岁<br>到88岁之间的49年时间，这份产品只帮我赚到了8万的收益，如果换算成一个理财产品的话，那这份产品的年收益是可怜的0.9%……</p>
<p>我感觉已经不用分析了，这破产品分析到这已经是垃圾中的战斗机了啊。</p>
<p>但是不行，我还要继续分析，因为如果考虑到通货膨胀率之类的东西，我得出的结论是，买这个产品，甚至收益完全是负的。。。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>之前的分析还是有点粗浅的，如果仔细分析的话其实还需要考虑至少下面几点</p>
<ul>
<li>产品分红会每年加到总保额里，每年收益应当是(50000+分红)*0.08</li>
<li>钱是会通货膨胀的，今年给你的收益4000，到明年就不值4000了</li>
<li>同样的因为通货膨胀，你今年交的保费7600，到明年可能就不值7600了</li>
</ul>
<p>我直接上代码解决吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countInsuranceIncome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> eachYearOut = <span class="number">7600</span>;<span class="comment">//每年缴纳费用</span></span><br><span class="line">    <span class="keyword">let</span> eachYearRate = <span class="number">0.08</span>;<span class="comment">//年金率</span></span><br><span class="line">    <span class="keyword">let</span> inflationRate = <span class="number">0.05</span>;<span class="comment">//每年通胀率</span></span><br><span class="line">    <span class="keyword">let</span> eachYearIncreaseRate = <span class="number">0.01</span>;<span class="comment">//每年获得分红率</span></span><br><span class="line">    <span class="keyword">let</span> allMoney = <span class="number">50000</span>;<span class="comment">//总保额</span></span><br><span class="line">    <span class="keyword">let</span> allOut = <span class="number">0</span>;<span class="comment">//总支出</span></span><br><span class="line">    <span class="keyword">let</span> allIn = <span class="number">0</span>;<span class="comment">//总收入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第二年开始算通胀</span></span><br><span class="line">            eachYearOut = eachYearOut * (<span class="number">1</span>-inflationRate);</span><br><span class="line">        &#125;</span><br><span class="line">        allOut = allOut + eachYearOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到66岁每两年领一次8%</span></span><br><span class="line">    <span class="comment">// 总共领23次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">23</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> rate = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第二年开始算通胀</span></span><br><span class="line">            rate = <span class="number">1</span> + eachYearIncreaseRate - inflationRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总保额每年变化，由于是两年一次，所以乘两次</span></span><br><span class="line">        allMoney = allMoney * rate * rate;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次计算得总保额为&quot;</span> + allMoney.toFixed(<span class="number">2</span>));</span><br><span class="line">        allIn = allMoney * eachYearRate + allIn;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次年金为&quot;</span> + (allMoney * eachYearRate).toFixed(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 66岁一次性给100%</span></span><br><span class="line">    allIn = allIn + allMoney;</span><br><span class="line">    <span class="comment">//66岁开始假设活到88岁，每年领一次8%</span></span><br><span class="line">    <span class="comment">//总共领22次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">22</span>; i++) &#123;</span><br><span class="line">        allIn = allMoney * (<span class="number">1</span> + eachYearIncreaseRate - inflationRate) * eachYearRate + allIn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;总共支出&#x27;</span> + allOut.toFixed(<span class="number">2</span>) + <span class="string">&#x27;，总共收入&#x27;</span> + allIn.toFixed(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑基本上就是把我列的条件都写进去了，不多解释，总之最后的计算结果非常让我震惊。<br>假设从今年开始买这个产品，基于当前物价水平</p>
<ul>
<li>基于5%的通胀率，1%的分红率</li>
<li>付出<strong>97510.14</strong>元</li>
<li>收益<strong>65532.89</strong>元 </li>
<li>收益 <strong>-31977.25</strong>元</li>
</ul>
<p>也就是说考虑到通货膨胀，拉长到将近70年的周期，这份产品最终是让你倒亏3万多。<br>而通胀率我设置的其实不算高，5%算是偏低水平，1%的每年分红率我甚至还比现实更高。而且现实中也基本不太可能每年保持1%的分红率，如果调整成6%的通胀率，和0.9%的分红率，</p>
<ul>
<li>基于6%的通胀率，0.9%的分红率</li>
<li>付出<strong>89919.88</strong>元</li>
<li>收益<strong>49962.45</strong>元</li>
<li>收益 <strong>-39957.43</strong>元</li>
</ul>
<p>不得不说，算还是保险公司会算，你乍一看，只要交20年，然后长达70年给你持续分红和年金，似乎怎么想都是划算的，而且分红方式还按照不固定的分红增长，给人以更大的迷惑性。<br>让你如果不依靠专业的工具，自己根本算不清楚，只能任保险公司鱼肉。</p>
<p>最后，如果想要这份产品能够盈利，那最低条件是通胀率要小于等于3%，且年均分红率要稳定在1%，这样70年后能够血赚2000。。。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>solved</tag>
      </tags>
  </entry>
  <entry>
    <title>logback日志配置模板</title>
    <url>/2019/11/05/tech/logback%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 常量定义start --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认日志输出格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;HOST_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Project_Name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DEFAULT_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ** $&#123;HOST_NAME&#125; ** [%thread] ** %level ** [%logger] ** - %file:%line ** [%method] - ** %msg%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MAX_HISTORY&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_QUEUE_SIZE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DEFAULT_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 常量定义end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 默认日志的console appender，本地使用的日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>E:/logs/$&#123;HOST_NAME&#125;/$&#123;HOST_NAME&#125;-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!local&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务器上使用的appender start --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认的file appender，按天切分日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/home/logs/$&#123;HOSTNAME&#125;/$&#123;HOSTNAME&#125;-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 错误日志，按天切分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE_ERROR&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/home/logs/$&#123;HOSTNAME&#125;/$&#123;HOSTNAME&#125;_error-%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;MAX_HISTORY&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;DEFAULT_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;DEFAULT_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_ROLLING_FILE_DEFAULT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ASYNC_ROLLING_FILE_ERROR&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_ERROR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE_DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
  </entry>
  <entry>
    <title>linux版本过低情况下使用高版本nodejs</title>
    <url>/2021/12/17/tech/linux%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%ACnodejs/</url>
    <content><![CDATA[<p><strong>我这里针对的低版本linux指的是centos6。</strong></p>
<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>最近需要写一个页面，我前段时间一直在用nodejs开发，所以我就选择了react来写页面。在本机开发调试完成之后，部署到linux上出现问题，在运行npm install命令的时候出现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm WARN notsup Unsupported engine for react-scripts@5.0.0: wanted: &#123;&quot;node&quot;:&quot;&gt;=14.0.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: react-scripts@5.0.0</span><br><span class="line">npm WARN notsup Unsupported engine for css-loader@6.5.1: wanted: &#123;&quot;node&quot;:&quot;&gt;= 12.13.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: css-loader@6.5.1</span><br><span class="line">npm WARN notsup Unsupported engine for css-minimizer-webpack-plugin@3.3.1: wanted: &#123;&quot;node&quot;:&quot;&gt;= 12.13.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: css-minimizer-webpack-plugin@3.3.1</span><br><span class="line">npm WARN notsup Unsupported engine for eslint@8.5.0: wanted: &#123;&quot;node&quot;:&quot;^12.22.0 || ^14.17.0 || &gt;=16.0.0&quot;&#125; (current: &#123;&quot;node&quot;:&quot;10.24.1&quot;,&quot;npm&quot;:&quot;6.14.12&quot;&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: eslint@8.5.0</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>显然，根据提示是因为node版本太低导致，那首先想到的必然就是升级node版本。</p>
<h2 id="尝试升级node版本失败，gcc版本过低"><a href="#尝试升级node版本失败，gcc版本过低" class="headerlink" title="尝试升级node版本失败，gcc版本过低"></a>尝试升级node版本失败，gcc版本过低</h2><p>升级node版本有几种办法：</p>
<ul>
<li>通过下载<a href="https://nodejs.org/en/download/releases/">官网</a>的二进制包，然后解压缩到目录，再通过ln指令进行node版本的关联。</li>
<li>第二种方法比较简单，安装node的一个版本管理工具，叫<a href="https://github.com/tj/n">n</a>，然后运行如下指令就可以完成安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line">n node版本号</span><br></pre></td></tr></table></figure>
<span id="more"></span>
然而在我运行了n 14 之后，却出现了报错如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.5&#x27; not found (required by node)</span><br><span class="line">node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#x27; not found (required by node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.18&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.5&#x27; not found (required by /usr/local/bin/node)</span><br><span class="line">/usr/local/bin/node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#x27; not found (required by /usr/local/bin/node)</span><br></pre></td></tr></table></figure>
这个报错我去网上搜了下，原因基本就是因为gcc的版本过低导致。在解决这个问题的时候，我出现了非常多的路线错误，导致这个问题本来挺容易解决的，却绕了很多的弯。</li>
</ul>
<h2 id="尝试升级gcc版本失败，yum安装源版本过低"><a href="#尝试升级gcc版本失败，yum安装源版本过低" class="headerlink" title="尝试升级gcc版本失败，yum安装源版本过低"></a>尝试升级gcc版本失败，yum安装源版本过低</h2><p>首先我直接尝试了运行yum安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure>
<p>结果报错，提示404。经查发现原来centos已经停止支持centos6版本的linux了，甚至还卸磨杀驴，将之前的yum源也都关闭，不仅如此，国内的所有centos6的镜像yum源也都关闭了。最终我在阿里的镜像源里看到一句话，如果非要用centos6的yum源，访问<a href="https://vault.centos.org/">https://vault.centos.org/</a>。看来centos还是归档了一份镜像源，还算有点良心，但是这个网站也写了下面一段话。</p>
<blockquote>
<p>This is <em>NOT</em> an updated tree for installing CentOS Linux : It is a snapshot of the older trees that have been removed from the main CentOS servers as new point releases are released.<br>  This is provided for reference and to provide access to older archived versions, and we do not put security updates into the trees on this server.<br>  Please see this <a href="http://www.centos.org/download">link</a> for active versions of CentOS Linux </p>
</blockquote>
<p>总之就是告诉你这个镜像也尽量别用，只是为了老版本linux做的一个备份而已。反正centos意思也很明显了，centos6你就别用了，能升级就升级。<br>那有什么办法呢，先用这个镜像源看看吧。尝试替换yum源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 最好是先备份一份，我只是为了复盘问题处理过程，所以省略这一步</span></span></span><br><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>
<p>可以直接用如下内容替换进去：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意，这是centos6的yum源，更高版本的不要用这个源</span></span><br><span class="line"><span class="attr">[base]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Base - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/os/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line"><span class="attr">[updates]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Updates - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/updates/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line"><span class="attr">[extras]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Extras - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/extras/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line"><span class="attr">[centosplus]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Plus - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/centosplus/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#contrib - packages by Centos Users</span></span><br><span class="line"><span class="attr">[contrib]</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">CentOS-6.10 - Contrib - vault.centos.org</span></span><br><span class="line"><span class="attr">failovermethod</span>=<span class="string">priority</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://vault.centos.org/6.10/contrib/$basearch/</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://vault.centos.org/RPM-GPG-KEY-CentOS-6</span></span><br></pre></td></tr></table></figure>
<p>这样一通操作之后，通过yum安装gcc倒是走通了，可是。。。安装的版本还是不符合要求，这个yum源下的gcc最高版本还是太低。那咋办？我想到了两个方式，一是手动安装，二是。。。升级linux版本。</p>
<h2 id="尝试手动安装高版本gcc失败"><a href="#尝试手动安装高版本gcc失败" class="headerlink" title="尝试手动安装高版本gcc失败"></a>尝试手动安装高版本gcc失败</h2><p>过程不再赘述了，基本原因是linux内核版本太低，使得make命令执行失败。</p>
<h2 id="升级lunux版本失败"><a href="#升级lunux版本失败" class="headerlink" title="升级lunux版本失败"></a>升级lunux版本失败</h2><p>升级linux我确实也去查了下方法，升级失败的原因也挺操蛋的，就是centos全面关闭centos6的支持，甚至连centos6升级到centos7的通道都关了，导致网上查的那些方法都不能用，centos真是全面诠释了什么叫全面关闭对老系统的支持。</p>
<h2 id="回归最早的报错，解决-39-GLIBCXX-3-4-20-39-not-found的问题"><a href="#回归最早的报错，解决-39-GLIBCXX-3-4-20-39-not-found的问题" class="headerlink" title="回归最早的报错，解决&#39;GLIBCXX_3.4.20&#39; not found的问题"></a>回归最早的报错，解决<code>&#39;GLIBCXX_3.4.20&#39; not found</code>的问题</h2><p>上面解决问题的过程持续了几乎一整天，我在linux版本升级也失败之后，我突然意识到，我只是想要部署个web页面而已啊，为啥会搞的这么麻烦？于是我回归到最早的那个报错，<code>&#39;GLIBCXX_3.4.20&#39; not found</code>，在百度上连续吃瘪之后，我用了谷歌来查这个问题，没想到的是，谷歌出来的一片文章五分钟就解决另外我的问题。<br>这篇文章链接：<a href="https://www.jianshu.com/p/050b2b777b9d">version ‘GLIBCXX_3.4.20’ not found 解决方法</a>。<br>为了防止原文404，我也备份一下这个解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 查看系统版本</span><br><span class="line">strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line"></span><br><span class="line">发现少了GLIBCXX_3.4.20，解决方法是升级libstdc++.</span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line">sudo yum provides libstdc++.so.6</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">libstdc++-4.8.5-39.el7.i686 : GNU Standard C++ Library</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Provides    : libstdc++.so.6</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">cd /usr/local/lib64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载最新版本的libstdc.so_.6.0.26</span></span><br><span class="line">sudo wget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip</span><br><span class="line">unzip libstdc.so_.6.0.26.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下载的最新版本拷贝到 /usr/lib64</span></span><br><span class="line">cp libstdc++.so.6.0.26 /usr/lib64</span><br><span class="line">cd  /usr/lib64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 /usr/lib64下libstdc++.so.6链接的版本</span></span><br><span class="line">ls -l | grep libstdc++</span><br><span class="line">libstdc++.so.6 -&gt;libstdc++.so.6.0.19</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除/usr/lib64原来的软连接libstdc++.so.6，删除之前先备份一份</span></span><br><span class="line">sudo rm libstdc++.so.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接新的版本</span></span><br><span class="line">sudo ln -s libstdc++.so.6.0.26 libstdc++.so.6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看新版本，成功</span></span><br><span class="line">strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_3.4.20</span><br><span class="line">GLIBCXX_3.4.21</span><br><span class="line">GLIBCXX_3.4.22</span><br><span class="line">GLIBCXX_3.4.23</span><br><span class="line">GLIBCXX_3.4.24</span><br><span class="line">GLIBCXX_3.4.25</span><br><span class="line">GLIBCXX_3.4.26</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其实这个方法也算是手动安装，但是问题的关键是他的方式是只升级了libstdc，而我之前纠结的一直是gcc版本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问题最后圆满解决了，这个过程中也算是学到了不少东西，所以想记录一下。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux日常维护命令</title>
    <url>/2019/10/16/tech/linux%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="删除测试库创建日期在10天以前的日志"><a href="#删除测试库创建日期在10天以前的日志" class="headerlink" title="删除测试库创建日期在10天以前的日志"></a>删除测试库创建日期在10天以前的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -ctime +10 -type f -name &quot;*log.log.20*&quot; | xargs rm -rf</span><br></pre></td></tr></table></figure>

<h2 id="查看磁盘空间和大文件"><a href="#查看磁盘空间和大文件" class="headerlink" title="查看磁盘空间和大文件"></a>查看磁盘空间和大文件</h2><h3 id="查看磁盘剩余空间"><a href="#查看磁盘剩余空间" class="headerlink" title="查看磁盘剩余空间"></a>查看磁盘剩余空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h3 id="查看目录下大文件"><a href="#查看目录下大文件" class="headerlink" title="查看目录下大文件"></a>查看目录下大文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>

<h2 id="查看进程中的java程序"><a href="#查看进程中的java程序" class="headerlink" title="查看进程中的java程序"></a>查看进程中的java程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死某个进程</span></span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>

<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br></pre></td></tr></table></figure>

<h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp C:/Users/Administrator/Downloads/elasticsearch-7.3.1-linux-x86_64.tar.gz root@192.168.15.161:/home/bos-provider/bos-provider-1.0-SNAPSHOT/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="MQ查询命令"><a href="#MQ查询命令" class="headerlink" title="MQ查询命令"></a>MQ查询命令</h2><h4 id="查询某条消息的生产者和消费者，以及消息的track路径"><a href="#查询某条消息的生产者和消费者，以及消息的track路径" class="headerlink" title="查询某条消息的生产者和消费者，以及消息的track路径"></a>查询某条消息的生产者和消费者，以及消息的track路径</h4><p>1.进入/usr/java/rocketmq/bin<br>2.根据key查找</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin queryMsgBykey -n 127.0.0.1:9876 -k b6df2c64-4654-409d-b457-ec1db294a606 -t ORDER</span><br></pre></td></tr></table></figure>

<p>3.根据key可以找到ID<br>   根据ID查找消费者和生产者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin queryMsgById -n 127.0.0.1:9876 -i C0A8074100002A9F00000001A2BC9012</span><br></pre></td></tr></table></figure>

<h4 id="查看topiclist"><a href="#查看topiclist" class="headerlink" title="查看topiclist"></a>查看topiclist</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh mqadmin topicList –n 127.0.0.1:9876</span><br></pre></td></tr></table></figure>

<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins简单搭建</title>
    <url>/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="下载和安装jenkins"><a href="#下载和安装jenkins" class="headerlink" title="下载和安装jenkins"></a>下载和安装jenkins</h2><p>相对简单的办法，依次执行以下语句(前提，需要先安装rpm) </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取jenkins的rpm安装文件</span></span><br><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.222.3-1.1.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">使用rpm安装</span></span><br><span class="line">rpm -ivh jenkins-2.222.3-1.1.noarch.rpm </span><br></pre></td></tr></table></figure>

<h2 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h2><p>jenkins启动需要先安装java，java的安装不再赘述，java安装完成后，修改jenkins配置文件，指向java的安装目录 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/jenkins</span><br></pre></td></tr></table></figure>
<p>在”candidates=”这一行加入java安装目录，如果默认配置里面已经指向了你的java安装目录，则不需要再次配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">candidates=&quot;</span><br><span class="line">/etc/alternatives/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.8.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-1.7.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-1.7.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-11.0/bin/java</span><br><span class="line">/usr/lib/jvm/jre-11.0/bin/java</span><br><span class="line">/usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">/usr/bin/java</span><br><span class="line">/usr/java/jdk1.8.0_121/jre/bin/java</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>修改jenkins端口 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> JENKINS_PORT=<span class="string">&quot;8999&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>配置完成后，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service jenkins start</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service jenkins status</span><br></pre></td></tr></table></figure>
<p>出现以下截图说明成功启动<br><img src="/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/1.png">  </p>
<h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><p>访问 <a href="http://localhost:8999/">http://localhost:8999/</a> 即可看到jenkins的启动页面，稍等一会儿，看到如下页面：<br><img src="/2020/05/14/tech/jenkins%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/2.png"><br>接下来按照页面指引一步步安装即可。</p>
<ul>
<li>需要注意的点：插件按照推荐插件安装后，可能会有个别插件无法完成安装，这时不要选择重试，直接跳过，在Manage Jenkins - Mange Plugins - 高级，修改URL为 <a href="http://mirror.esuni.jp/jenkins/updates/update-center.json">http://mirror.esuni.jp/jenkins/updates/update-center.json</a> ，然后再更新插件即可。  </li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用技巧</title>
    <url>/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>1.进入<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 可以选择多种主题<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1.png"><br>点击图片进去可以看到这种主题的预览效果<br>点击文字进去将进入这个主题的github站点, 里面会详细说明该主题的安装和配置方式  </p>
<p>2.目前最流行的hexo主题应该是NexT, 我这次选的是3-hexo作为例子来讲解一下, 这个也是一个优秀的国产hexo主题<br>其最终效果如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2.png">   </p>
<p>3.关于3-hexo的安装和设置方法, 都可以直接参照<a href="https://github.com/yelog/hexo-theme-3-hexo">该主题的github主页</a><br>简单介绍一下:  </p>
<ul>
<li>获取3-hexo: git clone <a href="https://github.com/yelog/hexo-theme-3-hexo.git">https://github.com/yelog/hexo-theme-3-hexo.git</a> themes/3-hexo  </li>
<li>将3-hexo的主题文件夹复制到hexo的themes目录下  </li>
<li>修改3-hexo目录下的_config.yml文件, 修改方式在_config.yml中已经有详细的注释, 按照注释修改即可  </li>
<li>hexo主目录下打开git窗口, 依次输入如下命令<br>hexo clean (清除静态页面缓存文件, 防止出现缓存影响页面样式的情况)<br>hexo g (生成静态页面)<br>hexo s (启动本地hexo服务器, 可以打开localhost:4000查看页面效果)<br>hexo d (发布到github)  <span id="more"></span></li>
</ul>
<h2 id="设置分类和标签"><a href="#设置分类和标签" class="headerlink" title="设置分类和标签"></a>设置分类和标签</h2><p>1.每一个由hexo生成的md文件, 其内容开头都是由两个”—“组成的, hexo把这部分称为<a href="https://hexo.io/zh-cn/docs/front-matter">Front-Matter</a>, 如图:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/3.png">  </p>
<p>2.在Front-Matter的区域内可以设置关于文章的诸多信息, 包括标题, 创建时间, 标签, 目录, 是否开启评论等  </p>
<p>3.标签的参数名称为tags, 目录的参数名称为categories, 设置单个标签和目录的格式如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: hexo</span><br><span class="line">categories: hexo</span><br></pre></td></tr></table></figure>
<p>设置多个标签和多级目录的格式如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">- hexo</span><br><span class="line">- blog</span><br><span class="line">categories: </span><br><span class="line">- 学习</span><br><span class="line">- 搭建相关</span><br></pre></td></tr></table></figure>
<p><strong>注意:目录的先后顺序决定了其父子级关系, 如上面的例子中, “学习”目录是”搭建相关”目录的父目录. 在3-hexo主题中的效果如下:</strong><br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/4.png"></p>
<h3 id="以下是我的hexo更新之后需要额外操作的步骤"><a href="#以下是我的hexo更新之后需要额外操作的步骤" class="headerlink" title="以下是我的hexo更新之后需要额外操作的步骤"></a>以下是我的hexo更新之后需要额外操作的步骤</h3><p>4.使用命令创建tags和categories目录<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><br>这样会在source目录下生成tags和categories目录，并在该目录下生成index.md文件<br>5.在tags目录下index.md文件内增加一行 <strong>type: tags</strong>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2021-11-23 08:46:12</span><br><span class="line">type: tags</span><br></pre></td></tr></table></figure>
<p>在categories.md文件内增加一行 <strong>type: categories</strong>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2021-11-23 08:46:12</span><br><span class="line">type: categories</span><br></pre></td></tr></table></figure>
<p>6.重新执行hexo g即生成目录和标签</p>
<h2 id="MarkDown开发工具"><a href="#MarkDown开发工具" class="headerlink" title="MarkDown开发工具"></a>MarkDown开发工具</h2><p>我本人不太喜欢为markdown开发再安装一个软件, 所以以下都是针对程序员电脑上通常已有的软件上安装插件, 当然如果没有这些软件, 那推荐直接安装<a href="https://typora.io/">typora</a>  </p>
<p>1.Notepad++插件MarkdownViewer++<br>如果已经安装了Notepad++, 可以直接下载<a href="https://github.com/nea/MarkdownViewerPlusPlus/releases">MarkdownViewer++</a>插件<br>下载完成后, 直接将dll文件放入Notepad++主目录下的plugin文件夹下, 然后重新启动Notepad++即可, 在Notepad++的工具栏会出现一个”m”图标:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/5.png"><br>点击即可实时查看页面效果<br>优点: 插件轻量级, 1MB不到, 占用系统的内存消耗极小<br>缺点: 功能非常有限, 只能实时查看效果, 不能对markdown语法高亮  </p>
<p>2.Idea插件MarkDown Navigator<br>其实Idea自带了一个MarkDown的插件, 但是这个插件不太好用, 所以这里不再介绍了<br>打开Idea, 打开File-Settings-Plugins-Browse Repositories, 查找MarkDown Navigator, 点击Install, 重新启动Idea即可<br>效果如图:<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/6.png"><br>优点: 支持MarkDown语法高亮, 支持语法快捷键, 且在Idea内开发, 对于程序员来说比较习惯<br>缺点: 毕竟需要Idea来开发, 对于仅仅只要写博客的人来说, 显得有点笨重  </p>
<p>3.MarkDown在线编辑器<br>在线编辑的好处不言自明, 不用安装任何软件和插件, 只要有浏览器就行<br>推荐<a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a> </p>
<h2 id="为博客设置密码"><a href="#为博客设置密码" class="headerlink" title="为博客设置密码"></a>为博客设置密码</h2><p>1.安装插件: 在hexo主目录下执行npm install –save hexo-blog-encrypt<br>2.在需要设置密码的博客的Front-Matter里面加一个参数<br>password:*****  </p>
<h2 id="如何上传图片"><a href="#如何上传图片" class="headerlink" title="如何上传图片"></a>如何上传图片</h2><p>1.在github存储图片并在博客内关联图片链接<br>这种方式比较推荐, 因为别的博客网站通常都会有防止外部访问的措施在, 存储<br>在github上的图片不会有外部无法访问的情况. 对于各个版本的hexo都能适用.</p>
<ul>
<li>打开hexo主目录下的_config.yml文件, 修改参数post_asset_folder为true</li>
<li>使用hexo n “博客标题” 新建博客时将会同时新建一个同名的资源文件夹, 如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/7.png">  </li>
<li>将博客内用到的图片放置到资源文件夹内, 可以按顺序号命名, 如图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/8.png"></li>
<li>在博客内链接该图片, 格式为 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](https://raw.githubusercontent.com/#username/#username.github.io/master/#YYYY/#MM/#DD/#title/#photoname)  </span><br><span class="line">#username : github用户名</span><br><span class="line">#YYYY/#MM/#DD : 如果没有修改_config.yml里的默认文件夹创建方式的话, 就是填入年月日即可, 如2019/10/14  </span><br><span class="line">#title : 文章标题  </span><br><span class="line">#photoname : 图片名称  </span><br></pre></td></tr></table></figure>
比如我这篇博客的图片链接地址如下图<br><img src="/2019/10/08/tech/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/9.png">  </li>
<li>链接完图片后目前在博客的预览界面还无法看到图片, 需要先执行<br>hexo clean (非必要步骤, 如果博客页面格式显示不正确, 需要执行)<br>hexo g (创建博客静态网页文件)<br>hexo d (这一步用于发布博客, 也同时发布图片)<br>hexo d的命令将会把图片发布到github服务器上, 也就可以在上述格式的图片地址里看到该图片  </li>
</ul>
<p>2.直接链接本地地址, 这种方式也很方便, 网上也有挺多人使用这种方式, 主要优点<br>是不用多操作一步链接网络地址, 我贴一下该方式:</p>
<ol>
<li>打开hexo主目录下的_config.yml文件, 修改参数post_asset_folder为true</li>
<li>安装图片插件 npm install hexo-asset-image –save<br>或者安装  npm install hexo-renderer-marked -s</li>
<li>在博客内直接引用本地地址即可, 如  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](/1.png)</span><br></pre></td></tr></table></figure>
<h2 id="设置首页文章摘要"><a href="#设置首页文章摘要" class="headerlink" title="设置首页文章摘要"></a>设置首页文章摘要</h2>有三种方法，推荐使用第一种，更加灵活的根据文章进行不同长度的摘要截断，而且对于不同的插件也有最好的适应性</li>
<li>在文章中使用 <!-- more --> 手动进行截断，Hexo 提供的方式</li>
<li>在文章的 front-matter 中添加 description，并提供文章摘录 </li>
<li>自动形成摘要，在 主题配置文件 中添加<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">enable</span>: <span class="string">true</span></span><br><span class="line">  <span class="attr">length</span>: <span class="string">150</span></span><br></pre></td></tr></table></figure>
默认截取的长度为 150 字符，可以根据需要自行设定</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架中使用get和post</title>
    <url>/2021/11/26/tech/Express%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8get%E5%92%8Cpost/</url>
    <content><![CDATA[<p>之所以有这个文章，是因为遇到在nodejs中使用express框架直接接受post请求时，无法获取到body中的内容，于是google了一篇英文文章解决了这个问题。<br>翻译自<a href="https://codeforgeek.com/handle-get-post-request-express-4/">codeforgeek</a></p>
<hr>
<p>GET和POST是两种用于构建REST接口的普通HTTP请求。两者的命名包含着不同的使用目的。<br>根据定义，GET请求从指定的地址抓取数据，POST请求则是发送数据到指定的地址。</p>
<p>Express框架提供了router()方法用于构建HTTP终端。下面让我们看下怎么使用Express来实现GET和POST请求。</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>在Express中使用GET请求非常直接。你首先必须创建一个express和router的实例。下面是实现的一小段代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">router.get(‘/handle’,<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//code to perform particular action.</span></span><br><span class="line"><span class="comment">//To access GET variable use req.query() and req.params() methods.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router in the Express app.</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, router);</span><br></pre></td></tr></table></figure>
<p>GET请求会缓存在浏览器历史中。这就是为什么不推荐使用GET请求发送敏感数据（密码，ATM取款码，等等）。你应该只使用GET请求从服务器获取数据。</p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>Express需要一个额外的中间件模块提取POST请求中的数据。这个中间件叫做”body-parser”。我们需要在Express的实例中安装和配置它。<br>你可以使用如下命令安装body-parser。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install --save body-parser</span><br></pre></td></tr></table></figure>
<p>你需要在你的项目中导入这个包并告知Express去使用这个中间件。参考如下代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here we are configuring express to use body-parser as middle-ware.</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line">router.post(‘/handle’,<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//code to perform particular action.</span></span><br><span class="line"><span class="comment">//To access POST variable use req.body()methods.</span></span><br><span class="line"><span class="built_in">console</span>.log(request.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router in the Express app.</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, router);</span><br></pre></td></tr></table></figure>
<p>通过这种方式，你可以在Express框架中使用GET和POST请求。（译者注：注意先后顺序，body-parser的注入一定要在router的注入之前，否则也会不起作用）</p>
<hr>
<p>后面的内容是博主写的demo，感觉也没必要发上来，就略过了。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>translate</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日常维护相关</title>
    <url>/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="配置启动ELK-FileBeats后台运行-不随着窗口关闭而关闭"><a href="#配置启动ELK-FileBeats后台运行-不随着窗口关闭而关闭" class="headerlink" title="配置启动ELK+FileBeats后台运行, 不随着窗口关闭而关闭"></a>配置启动ELK+FileBeats后台运行, 不随着窗口关闭而关闭</h2><p>只要在后面加上&amp;即可, 如  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/logstash -f config/log4j-es.conf &amp;</span><br></pre></td></tr></table></figure>
<p>注意: 退出时使用Ctrl+D命令, 直接关闭窗口依然有可能使得进程关闭  </p>
<h2 id="LogStash自动重新加载配置"><a href="#LogStash自动重新加载配置" class="headerlink" title="LogStash自动重新加载配置"></a>LogStash自动重新加载配置</h2><p>启动logstash时在后面加上命令–config.reload.automatic  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/logstash -f config/log4j-es.conf --config.reload.automatic &amp;</span><br></pre></td></tr></table></figure>

<h2 id="重新发送filebeat抓取的内容"><a href="#重新发送filebeat抓取的内容" class="headerlink" title="重新发送filebeat抓取的内容"></a>重新发送filebeat抓取的内容</h2><p>1.删除registry下的data.json<br>如:  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /home/elk/filebeats/filebeat-7.3.1-linux-x86_64/data/registry/filebeat</span><br></pre></td></tr></table></figure>
<p>2.重启filebeat<br>如果存在正在运行的filebeat, 先kill掉  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep filebeat  </span><br><span class="line">kill -s 9 pid</span><br></pre></td></tr></table></figure>
<p>然后执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="设置索引内容30天过期删除"><a href="#设置索引内容30天过期删除" class="headerlink" title="设置索引内容30天过期删除"></a>设置索引内容30天过期删除</h2><p>本来我理解的理论上应该可以用索引的生命周期来实现, 但是半天没整明白, 所以现在<br>是简单粗暴的使用linux的cron任务来实现, 更具体的cron配置详见<a href="https://blog.csdn.net/mengzuchao/article/details/81172305">cron详解</a><br>1.编辑shell脚本, 文件名为removeDataByTime.sh, 内容如下  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">limit_date=30</span><br><span class="line">for var in `curl &#x27;localhost:9200/_cat/indices&#x27; | awk &#x27;!/kibana*/ &#123;print $3&#125;&#x27;`</span><br><span class="line">do</span><br><span class="line">  curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;query&quot;: &#123;&quot;range&quot;: &#123;&quot;@timestamp&quot;: &#123;&quot;lt&quot;: &quot;now-&#x27;$&#123;limit_date&#125;&#x27;d/d&quot;&#125;&#125;&#125;&#125;&#x27; &quot;http://localhost:9200/$&#123;var&#125;/_delete_by_query&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>2.编辑cron文件, 执行crantab -e, 打开crontab配置文件<br>加上刚才的shell脚本, 设置每天0点15分执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">15 00 * * * /home/elk/removeDataByTime.sh</span><br></pre></td></tr></table></figure>
<p>设置cron重新启动, 执行/sbin/service crond restart  </p>
<p>3.查看cron执行情况<br>查看cron任务列表 : crontab -l<br>查看cron执行日志 : grep ‘removeDataByTime’ /var/log/cron  </p>
<h2 id="设置LogStash不写入指定的内容"><a href="#设置LogStash不写入指定的内容" class="headerlink" title="设置LogStash不写入指定的内容"></a>设置LogStash不写入指定的内容</h2><p>在logstash中写入如下内容即可 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 过滤message中的内容 , 注意drop后面有一个空格</span></span><br><span class="line">    if &quot;somethingA&quot; in [message] &#123;</span><br><span class="line">      drop &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # 过滤tags中的内容</span><br><span class="line">    if &quot;somethingB&quot; in [tags] &#123;</span><br><span class="line">      drop &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="设置索引别名来实现中文索引搜索"><a href="#设置索引别名来实现中文索引搜索" class="headerlink" title="设置索引别名来实现中文索引搜索"></a>设置索引别名来实现中文索引搜索</h2><p>有时候需要在搜索页面使用中文的索引名，但是在ES中不支持直接用中文名来命名索引，原因我认为应该是跟索引的Btree算法有关。</p>
<p>但是我们可以给索引设置别名来在搜索页面使用中文的索引来搜索。</p>
<p>可以按照如下方式来设置</p>
<ul>
<li>在postman发送如下请求（前提：在ElasticSearch中已经存在datadocking和activity-provider两个索引）：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST: <span class="number">192.168</span><span class="number">.15</span><span class="number">.161</span>:<span class="number">9200</span>/_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;外部对接&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;datadocking&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;微商城活动&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;activity-provider&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进入项目的索引模式</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/1.png"></p>
<p>输入刚刚设置的中文名，就可以直接对应到英文的索引名，然后按照步骤创建索引模式</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/2.png"></p>
<p>在搜索界面就可以使用中文的索引名来搜索</p>
<p><img src="/2019/10/14/tech/ELK%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3/3.png"></p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次ELK+FileBeats搭建</title>
    <url>/2019/10/07/tech/ELK_FileBeats/</url>
    <content><![CDATA[<h2 id="获取ElasticSearch-LogStash-Kibana-FileBeats"><a href="#获取ElasticSearch-LogStash-Kibana-FileBeats" class="headerlink" title="获取ElasticSearch+LogStash+Kibana+FileBeats"></a>获取ElasticSearch+LogStash+Kibana+FileBeats</h2><p>关于elk搭建的全部产品都可以从elastic的官方网站获取最新版本<br><a href="https://www.elastic.co/cn/products/">elastic官网</a></p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/1.png"><br>如图所示<br>当前elastic官方已经不再推荐单纯使用elk(ElasticSearch+LogStash+Kibana)三个产品搭建日志平台, 而是在此基础上加上了轻量级的日志收集插件FileBeats.  </p>
<h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><p>我们首先获取安装包<br>进入<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a>  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/2.png"><br>在Downloads里点击linux就可以下载到用于linux安装的tar包<br>如果是直接在linux安装,使用wget命令即可<br>如 : wget <a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.4.0-linux-x86_64.tar.gz</a><br>如果需要更旧的历史版本, 点击下面的past release即可</p>
<span id="more"></span>
<p><img src="/2019/10/07/tech/ELK_FileBeats/3.png">  </p>
<p>在获取到安装包之后, windows环境需要将tar包传送到linux , 使用scp(windows需要预装git)命令即可<br>如: scp C:/Users/Administrator/Downloads/elasticsearch-7.3.1-linux-x86_64.tar.gz <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x30;&#48;&#46;&#x31;&#48;&#x30;&#x2e;&#49;&#48;&#x30;&#x2e;&#49;&#48;&#48;">&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x30;&#48;&#46;&#x31;&#48;&#x30;&#x2e;&#49;&#48;&#x30;&#x2e;&#49;&#48;&#48;</a>:/home/elk/<br>在linux, 进入到安装包的目录, 使用tar -zxvf命令进行解压<br>如: tar -zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz<br>解压完成后, elasticsearch其实就已经完成了安装  </p>
<h3 id="启动ElasticSearch"><a href="#启动ElasticSearch" class="headerlink" title="启动ElasticSearch"></a>启动ElasticSearch</h3><p>在启动elasticserach之前需要注意:elasticsearch不可以用root用户启动, 因此, 需要事先在linux建立一个非root用户<br><a href="https://www.cnblogs.com/sunyllove/p/9772053.html">linux如何创建一个管理员用户</a><br>创建完linux用户后, 切换到该用户, 进入到elasticsearch目录, 执行bin/elasticserach即可<br>默认elasticsearch的端口是9200, 打开浏览器, 输入<a href="http://elasticsearch地址:9200/">http://elasticsearch地址:9200/</a>  , 出现如下画面, 说明elasticsearch启动成功</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/4.png"></p>
<h2 id="安装LogStash"><a href="#安装LogStash" class="headerlink" title="安装LogStash"></a>安装LogStash</h2><p>windows环境下载和上传到linux的方法不再赘述, 参照前文<br>linux环境, 参照如下命令即可:<br>1.执行wget <a href="https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.tar.gz">https://artifacts.elastic.co/downloads/logstash/logstash-7.4.0.tar.gz</a><br>2.进入logstash安装包目录, 执行tar -zxvf logstash-7.4.0.tar.gz  </p>
<h3 id="配置和启动LogStash"><a href="#配置和启动LogStash" class="headerlink" title="配置和启动LogStash"></a>配置和启动LogStash</h3><p>1.在启动logstash之前, 需要先新建一个logstash的配置文件<br>参照logstash目录下的config/logstash-sample.config文件(如图), 新建一个logstash-elk.config文件  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/5.png"><br>input, 即输入数据的监听端口, 这个一般不需要改.<br>output, 用于将接收到的数据发送到elasitcsearch. 将hosts改成elasticsearch部署的地址, 如果elasticsearch和logstash是同一台机器, 则不需要更改.<br>注意: 如果多个实例中的FileBeats发送过来的数据希望进入同一个elasticsearch实例, 并根据不同的ip地址划分为不同的索引, 按照如下方式配置  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    if &quot;100.100.100.101&quot; in [host][ip] &#123;</span><br><span class="line">        elasticsearch&#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">          index =&gt; &quot;sample1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if &quot;100.100.100.102&quot; in [host][ip] &#123;</span><br><span class="line">        elasticsearch&#123;</span><br><span class="line">          hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">          index =&gt; &quot;sample2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      elasticsearch&#123;</span><br><span class="line">        hosts =&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">        index =&gt; &quot;other&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后, 启动logstash, 执行bin/logstash -f config/logstash-elk.conf </p>
<h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>linux参照如下命令<br>1.wget <a href="https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-7.4.0-linux-x86_64.tar.gz</a><br>2.进入kibana安装包目录, 执行tar -zxvf kibana-7.4.0-linux-x86_64.tar.gz  </p>
<h3 id="配置和启动kibana"><a href="#配置和启动kibana" class="headerlink" title="配置和启动kibana"></a>配置和启动kibana</h3><p>进入config/kibana.yml<br>1.修改server.host为linux机器的实际地址<br>2.修改i18n.locale: “zh-CN” 这样kibana界面会显示为中文<br>3.返回kibana主目录, 执行bin/kibana  (注意:kibana也不能用root用户启动)<br>4.打开浏览器, 输入<a href="http://kibana地址:5601/">http://kibana地址:5601</a>, 出现如下画面  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/6.png"></p>
<h2 id="安装FileBeats"><a href="#安装FileBeats" class="headerlink" title="安装FileBeats"></a>安装FileBeats</h2><p>注意: <strong>FileBeats需要安装在所有需要发送日志的服务器上</strong><br>linux参照如下命令<br>1.wget <a href="https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.0-linux-x86_64.tar.gz</a><br>2.tar -zxvf filebeat-7.4.0-linux-x86_64.tar.gz</p>
<h3 id="配置和启动FileBeats"><a href="#配置和启动FileBeats" class="headerlink" title="配置和启动FileBeats"></a>配置和启动FileBeats</h3><p>进入filebeats安装目录, vi filebeat.yml<br>1.修改paths下的目录, 输入filebeats所在服务器需要收集的日志地址, 如:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paths:</span><br><span class="line">    - /home/sample1/logs/log.*</span><br><span class="line">    - /home/sample2/logs/log.*</span><br></pre></td></tr></table></figure>

<p>2.修改output.logstash下的内容, 将logstash部署的地址输入, 参照如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;100.100.100.101:5044&quot;]</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>
<p>3.进入filebeats主目录, 执行 ./filebeat -e -c filebeat.yml, 启动成功  </p>
<h2 id="kibana查看日志内容"><a href="#kibana查看日志内容" class="headerlink" title="kibana查看日志内容"></a>kibana查看日志内容</h2><p>将上述Elk+FileBeats都安装搭建完成后, 浏览器进入到kibana的界面.<br>1.打开管理-索引模式-创建索引模式, 进入如下界面:  </p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/7.png"><br>2.可以看到有三个索引可以匹配, 在索引模式的输入框内输入自己想要创建的索引, 如other, 然后点击下一步</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/8.png"><br>3.选择timestamp, 点击创建索引模式</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/9.png"><br>4.创建成功, 点击discover</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/10.png"><br>5.可以看到有一个新的索引other可以选择</p>
<p><img src="/2019/10/07/tech/ELK_FileBeats/11.png"></p>
<p>6.到此, elk+filebeats的基本搭建工作就已经完成了</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>azkaban简单搭建</title>
    <url>/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>前言：<br>azkaban的用处和好处不再赘述，这里只讲怎么将azkaban在项目中使用起来。<br>另外非常推荐直接看<a href="https://azkaban.readthedocs.io/en/latest/">官方的英文文档</a>进行学习，那将是最新最可靠的教程。</p>
<h2 id="下载和安装azkaban"><a href="#下载和安装azkaban" class="headerlink" title="下载和安装azkaban"></a>下载和安装azkaban</h2><h3 id="下载azkaban"><a href="#下载azkaban" class="headerlink" title="下载azkaban"></a>下载azkaban</h3><p>方法1：直接到azkaban的github网页下载tar.gz包。截止2020.4.29日最新版本的包地址为(<a href="https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz">https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz</a>)<br>方法2：在linux执行   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/azkaban/azkaban/archive/3.84.10.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="安装azkaban"><a href="#安装azkaban" class="headerlink" title="安装azkaban"></a>安装azkaban</h3><p>将包进行解压，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf azkaban-3.81.10.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压完成后目录结构如下图  </p>
<span id="more"></span>
<p><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/1.png"><br>如果使用solo-server方式的话，不需要建表，下面的步骤也都可以不用看，直接跳转看<a href="https://azkaban.readthedocs.io/en/latest/getStarted.html#getting-started-with-the-solo-server">solo-server</a><br>但是个人理解solo-server只适用于小型简单的项目，如果考虑项目以后的扩充和发展的话，建议一开始就使用multi-executor-server方式，该方式需要建表。<br>步骤如下：</p>
<h3 id="新增azkaban相关表"><a href="#新增azkaban相关表" class="headerlink" title="新增azkaban相关表"></a>新增azkaban相关表</h3><p>复制如下文件内的sql语句，在事先建好的数据库内执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi azkaban-3.81.10/azkaban-db/build/sql/create-all-sql-0.1.0-SNAPSHOT.sql</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可能有的坑：<br>早期版本的mysql可能不支持长度过长的字段设为索引和主键，遇到这种报错时，需要将对应的字段改短再执行。过长的字段比如 execution_logs.name，sql给设置的长度是varchar(640)，在我的mysql数据库中执行会报错，我改成了varchar(200)，这个字段的含义是任务名，一般来说你正常命名的话完全用不到640个字段的长度，所以可以放心修改。  </p>
<h3 id="编译azkaban"><a href="#编译azkaban" class="headerlink" title="编译azkaban"></a>编译azkaban</h3><p>在azkaban目录下执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew build installDist</span><br></pre></td></tr></table></figure>
<p>可能有的坑:</p>
</li>
<li><p>部分依赖包可能无法下载，修改build.gradle，将repositories指向国内阿里云地址，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/repository/google&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/repository/jcenter&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &#x27;com.cinnober.gradle:semver-git:2.2.3&#x27;</span><br><span class="line">    classpath &#x27;net.ltgt.gradle:gradle-errorprone-plugin:0.0.14&#x27;</span><br><span class="line">    classpath  &#x27;com.github.jengelman.gradle.plugins:shadow:4.0.0&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果出现编译报错的情况，可以尝试将编译期间的test过程注释掉，或者进入azkaban-executor-server和azkban-web-server目录下单独编译这两个包。  </p>
</li>
</ul>
<h3 id="启动azkban-executor-server"><a href="#启动azkban-executor-server" class="headerlink" title="启动azkban-executor-server"></a>启动azkban-executor-server</h3><ul>
<li><p>修改配置文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ../azkaban-3.81.0/azkaban-exec-server/build/install/azkaban-exec-server/conf/azkaban.properties</span><br></pre></td></tr></table></figure>
<p>需要修改的内容如下  </p>
<blockquote>
<p>default.timezone.id=Asia/Shanghai # 修改为中国时区<br>azkaban.webserver.url=localhost:8199 # 指向本地的azkaban-web-server地址<br>#数据库配置，指向azkban建表的数据库，根据实际的数据库配置来<br>database.type=mysql<br>mysql.port=3306<br>mysql.host=110.110.110.110<br>mysql.database=azkaban<br>mysql.user=azkaban<br>mysql.password=azkaban  </p>
</blockquote>
</li>
<li><p>启动azkaban-executor-server  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../azkaban-3.81.0/azkaban-exec-server/build/install/azkaban-exec-server;</span><br><span class="line">bin/start-exec.sh; # 注意一定要按照这个语句执行,不要在bin目录下执行./start-exe.sh，否则某些资源文件会加载不到，导致报错</span><br></pre></td></tr></table></figure></li>
<li><p> 激活executor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指向executor地址和端口</span><br><span class="line">curl localhost:port/executor?action=activate</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="启动azkaban-web-server"><a href="#启动azkaban-web-server" class="headerlink" title="启动azkaban-web-server"></a>启动azkaban-web-server</h3><ul>
<li><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-exec-server/conf/azkaban.properties</span><br></pre></td></tr></table></figure>
<p>需要修改的内容如下  </p>
<blockquote>
<p>default.timezone.id=Asia/Shanghai # 修改为中国时区<br>#邮件配置<br>mail.sender=<a href="mailto:&#x38;&#x38;&#x38;&#56;&#x38;&#x38;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x38;&#x38;&#x38;&#56;&#x38;&#x38;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a> # 发送邮件的邮箱<br>mail.host=smtp.qq.com  # 邮件服务器<br>mail.user=<a href="mailto:&#x38;&#x38;&#56;&#x38;&#x38;&#x38;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#x38;&#x38;&#56;&#x38;&#x38;&#x38;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a> # 邮件用户<br>mail.password=abc123456 #密码需要取qq邮箱中获取到的授权码<br>job.failure.email=<a href="mailto:&#56;&#x38;&#x38;&#x38;&#x38;&#56;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#56;&#x38;&#x38;&#x38;&#x38;&#56;&#56;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a> # 定时任务执行失败发送邮件的邮箱<br>#数据库配置，指向azkban建表的数据库，根据实际的数据库配置来<br>database.type=mysql<br>mysql.port=3306<br>mysql.host=110.110.110.110<br>mysql.database=azkaban<br>mysql.user=azkaban<br>mysql.password=azkaban</p>
</blockquote>
</li>
<li><p>启动azkaban-web-server  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-web-server;</span><br><span class="line">bin/start-web.sh;</span><br></pre></td></tr></table></figure>
<h3 id="访问azkaban"><a href="#访问azkaban" class="headerlink" title="访问azkaban"></a>访问azkaban</h3><p>浏览器输入 localhost:8199，出现如下界面<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/2.png"><br>用户名密码默认均为azkban，可以在 ../azkaban-3.81.0/azkaban-web-server/build/install/azkaban-web-server/conf/azkaban-users.xml 修改用户和密码  </p>
</li>
</ul>
<h2 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h2><p>1.打开azkaban主页面，点击create project，在弹出页面输入项目名和描述<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/3.png"><br>2.随后点击项目名进入配置页面，azkaban目前无法在页面直接配置，需要通过上传和下载配置文件来完成对定时任务的增删改，也就是用到页面上的upload和download按钮<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/4.png"><br>3.在本地新建一个test.flow文件，azkaban的基本配置文件需要用flow后缀的文件进行配置，配置的基本格式如下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">config</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">failure.emails</span>: <span class="string">user@qq.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nodes</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">-</span> <span class="string">name: testA</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">command</span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">command</span>: <span class="string">echo &#x27;hello wrold&#x27;</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">name: testB</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">command</span></span><br><span class="line">    <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">command</span>: <span class="string">echo &#x27;hello wrold&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中nodes节点下的就是执行的任务，commnad写的就是该任务需要执行的指令，azkaban还支持其他job类型，具体见<a href="https://azkaban.readthedocs.io/en/latest/jobTypes.html">官方文档</a><br>我暂时只用到commond<br>4.同时新建一个flow20.project文件，里面只需要一条内容，如下<br>azkaban-flow-version: 2.0<br>5.将flow文件和flow20.project文件打包成 <strong>【项目名.zip】</strong>，然后在azkaban页面点击upload，上传该zip文件<br>6.点击项目名就可以看到刚创建的job，然后点击execute flow-schedule，就可以配置cron表达式，设置该任务的运行周期<br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/5.png"><br><img src="/2020/04/29/tech/azkaban%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/6.png"><br>7.以后对于任务的新增和命令修改，都只能通过在azkaban页面点击download下载zip文件，然后修改里面的内容，再重新上传来完成
      </p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>搭建相关</category>
      </categories>
      <tags>
        <tag>azkaban</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 8.0参考手册中文版（一）</title>
    <url>/2019/10/17/tech/MySql-Document/</url>
    <content><![CDATA[<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">原文文档</a>  </p>
<p><strong>声明</strong></p>
<p>该文档纯粹自己手动翻译， 也许网上有更好的版本， 但是我这个属于自己学习的版本， 为了提高英语水平和对MySQL的理解， 后续不保证会持续更新，内容如有理解错误， 还请指正。</p>
<h2 id="MySQL-8-0-参考手册"><a href="#MySQL-8-0-参考手册" class="headerlink" title="MySQL 8.0 参考手册"></a>MySQL 8.0 参考手册</h2><h3 id="包含MySQL-NDB集群8-0"><a href="#包含MySQL-NDB集群8-0" class="headerlink" title="包含MySQL NDB集群8.0"></a>包含MySQL NDB集群8.0</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>这是一份MySQL参考手册。 该文档分别记录了MySQL8.0到8.0.20，以及基于NDB8.0版本到NDB8.0.19版本的NDB集群发布版本。这份文档可能包括一些目前还没发布的MySQL版本的特性。想要了解哪些版本已经发布，请查看<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">MySQL8.0发布日志</a>。  </p>
<p><strong>MySQL8.0特性</strong>。这份手册描述的特性并没有包含在所有版本的MySQL8.0中；这些特性可能不包含在你所购买的MySQL8.0版本中。如果你有任何问题是关于你的MySQL8.0版本中所包含的特性的，请参阅你的MySQL8.0许可协议或者联系你的oracle销售代表。  </p>
<p>有关每个发布版本的变化，请查看<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">MySQL8.0发布日志</a>。  </p>
<p>有关法律信息和许可信息，请查看<a href="https://dev.mysql.com/doc/refman/8.0/en/preface.html">前言和法律声明</a>。  </p>
<p>在使用MySQL中需要帮助，请访问<a href="http://forums.mysql.com/">MySQL论坛</a>，你可以在那里向别的MySQL用户描述你的问题。  </p>
<p>文档创建于：2019-10-16  </p>
<h2 id="1-一般信息"><a href="#1-一般信息" class="headerlink" title="1.  一般信息"></a>1.  一般信息</h2><p>MySQL提供了非常快速的，多线程，多用户，和健壮的SQL数据库服务。MySQL服务用于关键服务，高负荷生产的系统以及嵌入大量部署的软件。Oracle是Oracle公司及其分支机构的注册商标。MySQL是Oracle公司及其分支机构的商标，未经Oracle正式的书面许可，客户不得使用。其他的名字可能是其各自所有者的商标。  </p>
<p>MySQL软件具有双重许可。用户可以在GNU通用公共许可 (<a href="http://www.fsf.org/licenses/">http://www.fsf.org/licenses/</a>)  条款下将MySQL软件作为开源软件产品使用，或者从Oracle购买一份标准的商业许可。访问 <a href="http://www.mysql.com/company/legal/licensing/">http://www.mysql.com/company/legal/licensing/</a>  以获取更多关于授权政策的信息。  </p>
<p>下面的列表描述了一些在本手册中需要特别关注的部分：  </p>
<ul>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/features.html">1.3.2章节，“MySql的主要特性”</a>，讨论关于MySQL数据库服务的功能。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html">1.4章节，“MySQL8.0更新了什么”</a>，获取关于MySQL新功能的概况。访问<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">发布日志</a>，获取关于每个版本的更新信息。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html">2章节，安装和升级MySQL</a>，获取安装介绍。访问<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading.html">章节2.11</a>，获取MySQL升级说明。  </p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/tutorial.html">第3章节，教程</a>，获取MySQL数据库服务的教程介绍。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-administration.html">第5章节，MySQL服务管理</a>，获取关于MySQL服务的配置和管理的信息。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/security.html">第6章节，安全</a>，获取关于MySQL的安全信息。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/replication.html">第17章节，复制</a>，获取关于设置复制服务器的信息。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-enterprise.html">第30章节，MySQL企业版</a>，获取关于MySQL企业版的信息，商用版的MySQL会发布一些进阶的功能和管理工具。</p>
</li>
<li><p>访问 <a href="https://dev.mysql.com/doc/refman/8.0/en/faqs.html">附录A，MySQL8.0常见问题</a>，获取关于MySQL服务及其功能的一些常见问题的答案。</p>
</li>
<li><p>访问<a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/">发布日志</a>，获取关于新特性和bug修复的发布信息。</p>
<p><strong>重要</strong>  </p>
<p>如果要报告问题或者bug，请按照<a href="https://dev.mysql.com/doc/refman/8.0/en/bug-reports.html">章节17，“如何报告bug和问题”</a>的指示。如果你发现在MySQL中的一个敏感的安全性的bug，请立即发送邮件信息到&lt; <a href="mailto:secalert_us@oracle.com">secalert_us@oracle.com</a> &gt;让我们知晓。例外：支持客户应该报告所有的问题，包括安全bug，发送给Oracle支持部门。  </p>
</li>
</ul>
<h3 id="1-1-关于本手册"><a href="#1-1-关于本手册" class="headerlink" title="1.1 关于本手册"></a>1.1 关于本手册</h3><p>这份参考手册适用于MySQL数据库系统8.0版本到8.0.20版。在本文中关于和MySQL8.0镜像版本的区别参照了（8.0.x）的发行版本。查看<a href="https://dev.mysql.com/doc/refman/8.0/en/preface.html#legalnotice">法律声明</a>，获取许可的信息。</p>
<p>本手册不适用于MySQL软件的更早版本，因为在MySQL8.0和更早版本之间存在着很多功能及别的方面的不同。如果你正在使用MySQL软件的早期发布版本，请参考对应的手册。比如：<a href="https://dev.mysql.com/doc/refman/5.7/en/">MySQL5.7操作手册</a>可以覆盖MySQL软件的5.7发布版本系列。</p>
<p>由于这个手册是作为参考来使用，因此不会提供关于SQL或关联的数据库概念的一般介绍。同样也不会教你如何使用你的操作系统或命令行解释器。</p>
<p>MySQL数据库软件在经历不断的发展，其手册同样也会不断的更新。最新版本的手册可以在 <a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a> 在线搜索到。其他格式也可以在这里获取，包括HTML，PDF和EPUB版本。</p>
<p>参考手册的源文件由DocBook XML格式写成。其HTML版本和其他版本都自动生成，主要使用DocBook XSL样式表。关于DocBook的信息，详见 <a href="http://docbook.org/">http://docbook.org/</a> 。</p>
<p>MySQL的源代码包括内部文档，由Doxygen编写。已完成的Doxygen内容可以访问 <a href="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html</a> 。同样也可以按照 <a href="https://dev.mysql.com/doc/refman/8.0/en/source-installation-doxygen.html">章节2.9.10，“创建MySQL Doxygen文档内容”</a>的介绍从MySQL源分发创建本地的内容。</p>
<p>如果你有使用MySQL的的问题，加入 <a href="https://mysqlcommunity.slack.com/">MySQL开发者社区</a>，或者在我们的论坛提问；详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/forums.html">章节1.6.2，“MySQL论坛的MySQL社区支持”</a>。如果你对本手册有补充或者更正的建议，请发送到 <a href="http://www.mysql.com/company/contact/%E3%80%82">http://www.mysql.com/company/contact/。</a></p>
<p>本手册最初由 David Axmark 和 Michael “Monty” Widenius 编写。主要由MySQL文档团队编写，成员包括 Chris Cole， Paul DuBois， Margaret Fisher， Edward Gilmore， Stefan Hinz， David Moss， Philip Olson， Daniel Price， Daniel So， 以及 Jon Stephens 。</p>
<h3 id="1-2-排版和语法约定"><a href="#1-2-排版和语法约定" class="headerlink" title="1.2  排版和语法约定"></a>1.2  排版和语法约定</h3><p>本手册使用下列的排版约定：</p>
<p>// TODO</p>
<h3 id="1-3-MySQL数据库管理系统总览"><a href="#1-3-MySQL数据库管理系统总览" class="headerlink" title="1.3 MySQL数据库管理系统总览"></a>1.3 MySQL数据库管理系统总览</h3><h4 id="1-3-1-什么是MySQL？"><a href="#1-3-1-什么是MySQL？" class="headerlink" title="1.3.1 什么是MySQL？"></a>1.3.1 什么是MySQL？</h4><p>MySQL是最受欢迎的开源的SQL数据库管理系统，由Oracle公司开发，发布和支持。</p>
<p><a href="http://www.mysql.com/">MySQL官网</a>提供了MySQL软件的最新版本的信息。</p>
<ul>
<li><p>MySQL是一个数据库管理系统  </p>
<p>数据库是数据的结构化集合。它可以是任何东西，从简单的购物清单，到一个图片集，或者公司网络中的海量信息。在一个计算机数据库上添加，访问和执行数据存储，你需要一个像MySQL服务器一样的数据库管理系统。由于计算机非常善于处理大量的数据，数据库管理系统就在计算机中扮演了一个中心角色，无论是作为一个独立的程序，还是别的应用的一部分。</p>
</li>
<li><p>MySQL数据库是关系型的</p>
<p>一个关系型数据库将数据存储在不同的表中，而不是把所有的数据放在一个大的存储库中。数据库结构组织成物理文件以优化速度。具有对象（诸如数据库，表，视图，行和列）的逻辑模型提供了灵活的程序设计环境。你可以建立规则去管理不同字段之间的关系，比如一对一，一对多，唯一，必填或者选填，以及不同表之间的指向。数据库强制执行这些规则，所以一个良好设计的数据库，可以使你的程序避免看到不一致，重复，孤立，过期，或者缺失的数据。</p>
<p>MySQL中的SQL代表“结构化查询语言”。SQL是用于访问数据库的最通用的标准化语言。基于你的程序设计环境，又可以直接输入SQL（比如，用于创建报表），用另一种语言把SQL注入到代码中，或者使用隐含SQL语法的特定语言的API。</p>
<p>SQL由 ANSI/ISO 的SQL标准来定义。SQL的标准从1986年以来不断发展，存在多个不同的版本。在本手册中，“SQL-92”是指1992年发布的标准，“SQL:1999”是指在1999年发布的版本，以及“SQL:2003”，指现在的版本。我们在任何时用到“SQL标准”这个词时，都是指当前版本的SQL标准。</p>
</li>
<li><p>MySQL软件是开源的</p>
<p>开源意味着对于任何人来说都可以使用和修改该软件。任何人都可以从网络上下载MySQL软件并且免费使用。你也可以按照你的意愿去学习和更改源代码以适应你的需求。MySQL软件使用<a href="http://www.fsf.org/licenses/">GPL</a>)（通用公共许可），来定义你在不同情景下对软件能做的和不能做的事。如果你对GPL感到不适，或者想要将MySQL的代码注入到一个商用软件中，你可以从我们这里购买一份商用许可。访问<a href="http://www.mysql.com/company/legal/licensing/">MySQL许可概览</a>以获取更多信息。</p>
</li>
<li><p>MySQL数据库服务快速，可靠，可拓展且易用</p>
<p>如果你寻求的就是这个，你应该去尝试一下。MySQL服务可以在笔记本或者台式机上与其他应用，网络服务一起舒适的运行，只需要一点甚至无需额外的关注。如果你将整台机器都用于MySQL，你可以调整设置利用所有的内存，CPU功率，以及IO性能。MySQL同样可以扩大网络和机器的集群。</p>
<p>MySQL服务最初开发用来比现有方式更快的处理数据，而且成功的应用在高要求的生产环境很多年。尽管经历了不断的发展，MySQL如今提供了一组丰富而有用的功能。其可连接性，速度以及安全性使得MySQL服务高度适合在网络上访问数据库。</p>
</li>
<li><p>MySQL服务运行于客户端/服务端或者嵌入式系统</p>
<p>MySQL数据库软件是一个客户端/服务端系统，其包含了一个多线程的SQL服务器用于支持不同的后端，不同的客户端程序以及库，管理工具，以及大范围的应用程序接口。</p>
<p>我们也提供MySQL服务作为一个嵌入的多线程库，你可以将其链接到你的应用以实现一个更小，更快，易于管理的独立产品。</p>
</li>
<li><p>大量捐赠的MySQL软件已经可用</p>
<p>MySQL服务有一些使用的功能是由与我们密切合作的用户开发的。很有可能你最喜欢的应用或者语言由MySQL数据库服务支持。</p>
</li>
</ul>
<p>“MySQL”的官方读法是“ My Ess Que Ell ”（而不是 “my sequel” ），但是我们不介意你把它读作“my sequel”或者别的当地的读法。</p>
<h4 id="1-3-2-MySQL的主要功能"><a href="#1-3-2-MySQL的主要功能" class="headerlink" title="1.3.2 MySQL的主要功能"></a>1.3.2 MySQL的主要功能</h4><p>本节描述了一些MySQL数据库软件的重要特征。在大部分情况下，该路线图适用于所有版本的MySQL。想要知道在特定版本的MySQL中引入的功能，请在“In a Nutshell”章节查看对应的手册：</p>
<ul>
<li>MySQL8.0：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html">章节1.4，“MySQL8.0更新了什么”</a></li>
<li>MySQL5.7：<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html">MySQL5.7更新了什么</a></li>
<li>MySQL5.6：<a href="https://dev.mysql.com/doc/refman/5.6/en/mysql-nutshell.html">MySQL5.6更新了什么</a></li>
<li>MySQL5.5：<a href="https://dev.mysql.com/doc/refman/5.5/en/mysql-nutshell.html">MySQL5.5更新了什么</a></li>
</ul>
<p><strong>内部实现和可移植性</strong></p>
<ul>
<li>由C和C++实现</li>
<li>通过了大规模的不同编译器的测试</li>
<li>在多个不同的平台上运行。详见<a href="https://www.mysql.com/support/supportedplatforms/database.html">https://www.mysql.com/support/supportedplatforms/database.html</a></li>
<li>关于移植，MySQL5.5及以上的版本使用CMake命令。更早的版本使用GNU Automake，Autoconf和Libtool。</li>
<li>经过了Purify（一个商用的内存泄漏探测器）以及Valgrind（一个GPL工具）的测试。（<a href="http://developer.kde.org/~sewardj/%EF%BC%89">http://developer.kde.org/~sewardj/）</a></li>
<li>使用具有独立模块的多层服务的设计。</li>
<li>设计为使用核心线程的多线程方式，如果多核CPU可用，则可以很容易的被使用。</li>
<li>提供了基于事务和非事务的存储引擎。</li>
<li>使用索引压缩的非常快速的B-tree磁盘（MyISAM）</li>
<li>设计为可以相对简单的增加另一个存储引擎。如果你想为一个内部的数据库提供一个SQL接口，这会非常有用。</li>
<li>使用了非常快速的基于线程的内存分配系统。</li>
<li>使用了一种优化了的内部循环的join来非常快速的执行join。</li>
<li>实现了在内存的hash table，其作为临时表来使用。</li>
<li>使用了一种尽可能快的高度优化的类库来实现SQL功能。在所有的查询初始化后一般就不会再有内存分配。</li>
<li>为使用客户端/服务端环境提供了作为单独程序的服务，作为一个库可以嵌入到独立的应用中。这种应用可以单独使用或者在网络无法访问的环境中使用。</li>
</ul>
<p><strong>数据类型</strong></p>
<ul>
<li>很多的数据类型：带符号/无符号的整数类型，1、2、3、4以及8比特的长度， <a href="https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html"><code>FLOAT</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html"><code>DOUBLE</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>BINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html"><code>VARBINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>TEXT</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>BLOB</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>DATE</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/time.html"><code>TIME</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>DATETIME</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html"><code>TIMESTAMP</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/year.html"><code>YEAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/set.html"><code>SET</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/enum.html"><code>ENUM</code></a> ，以及OpenGIS的空间数据类型。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">章节11，数据类型</a>。</li>
<li>固定长度和可变长度的字符串类型。</li>
</ul>
<p><strong>语句和功能</strong></p>
<ul>
<li><p>所有的操作符和功能支持都在Select列表和Where条件语句查询中。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> CONCAT(first_name, <span class="string">&#x27; &#x27;</span>, last_name)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> citizen</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> income<span class="operator">/</span>dependents <span class="operator">&gt;</span> <span class="number">10000</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>完全支持SQL中的<code>Group By</code>和<code>Order By</code>条件。提供Group的功能的支持（ <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count"><code>COUNT()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_avg"><code>AVG()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_std"><code>STD()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_sum"><code>SUM()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max"><code>MAX()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min"><code>MIN()</code></a>, 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_group-concat"><code>GROUP_CONCAT()</code></a>) ）</p>
</li>
<li><p>完全支持拥有SQL和ODBC语法的 <code>LEFT OUTER JOIN</code> 和 <code>RIGHT OUTER JOIN</code>  </p>
</li>
<li><p>支持标准SQL要求的表和列的别名。</p>
</li>
<li><p>支持<code>Delete</code>，<code>Insert</code>，<code>Replace</code>，以及在<code>update</code>时返回修改的数量，或者返回匹配的行数，而不是在连接服务器时设置一个标识。</p>
</li>
<li><p>支持MySQL特定的<code>show</code>语句，用于返回数据库，存储引擎，表，以及索引的信息。支持 <code>INFORMATION_SCHEMA</code>数据库，实现自标准SQL。</p>
</li>
<li><p> <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> 语句会展现优化器如何处理查询语句的。</p>
</li>
<li><p>函数名称独立于表明和列名。比如，<code>ABS</code>是一个合法的列明。唯一的限制是在调用函数时，在函数名和(之间不能存在空格。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">章节9.3，关键字和保留字</a>。</p>
</li>
<li><p>你可以在一个语句内指定不同数据库的表。</p>
</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>权限和密码系统非常灵活和安全，并支持基于主机的认证。</li>
<li>连接服务器时，通过对所有密码通信进行加密来实现密码安全。</li>
</ul>
<p><strong>可拓展性和限制</strong></p>
<ul>
<li>支持大型数据库。我们使用的MySQL服务拥有可以包含5000万条数据的数据库。我们也知道拥有20万张表和50亿条数据的MySQL服务器的用户。</li>
<li>支持每张表最多64个索引。每个索引可以包含1-16列或者部分列。InnoDB表的索引最大宽度为767字节或者3072字节。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html">章节15.6.1.16，“InnoDB表的限制”</a>。MyISAM表的最大索引宽度为1000字节。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html">章节16.2，“MyISAM存储引擎”</a>。可以使用Char，Varchar，Blob或者Text字段类型的前缀作为一个索引。</li>
</ul>
<p><strong>可连接性</strong></p>
<ul>
<li>客户端可以通过不同的协议连接MySQL服务：<ul>
<li>客户端可以在任何平台上使用TCP/IP端口进行连接。</li>
<li>在windows系统，如果服务端启用了 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_named_pipe"><code>named_pipe</code></a> 系统参数进行启动，那客户端就可以使用name pipe进行连接。如果服务端启用了 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_shared_memory"><code>shared_memory</code></a>  系统参数进行启动，那客户端也可以使用  <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_shared_memory"><code>shared_memory</code></a>  方式进行连接。客户端可以通过使用  <a href="https://dev.mysql.com/doc/refman/8.0/en/connection-options.html#option_general_protocol"><code>--protocol=memory</code></a> 选项来进行shared memory的连接。</li>
<li>在unix系统，客户端可以使用Unix域的套接字文件来进行连接。</li>
</ul>
</li>
<li>MySQL的客户端程序可以用不同的语言编写。一个C语言编写的客户端库可以用于C语言和C++编写的客户端，或者任何别的提供C语言绑定的语言。</li>
<li> C, C++, Eiffel, Java, Perl, PHP, Python, Ruby, 和 Tcl 的API都是可用的，使得MySQL客户端可以被多种语言编写。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/connectors-apis.html">章节28，连接器和API</a>.</li>
<li>连接器/ODBC（MyODBC）接口为那些使用ODBC（Open Datebase Connectivity）连接的客户端程序提供了MySQL支持。比如说，你可以使用MS Access去连接你的MySQL服务器。客户端可以运行在Windows或者Unix。连接器/ODBC源是可用的。和很多其他的功能一样，所有的ODBC2.5的功能都是被支持的。详见<a href="https://dev.mysql.com/doc/connector-odbc/en/">MySQL 连接器/ODBC开发者指南</a>。</li>
<li>连接器/J 接口为那些使用了JDBC连接器的java客户端程序提供了MySQL支持。客户端可以运行于Windows或者Unix。连接器/J 源是可用的。详见<a href="https://dev.mysql.com/doc/connector-j/5.1/en/">MySQL连接器/J 5.1开发者指南</a>。</li>
<li>MySQL连接器/NET 允许开发者创建一个要求安全和高性能数据连接MySQL的.NET应用程序。它实现了必须的ADO.NET的接口并融入进了ADO.NET的感知工具。开发者可以选择他们的.NET语言去构建应用。MySQL连接器/NET是一个完全托管的ADO.NET驱动，100%由纯粹的C#编写。详见<a href="https://dev.mysql.com/doc/connector-net/en/">MySQL连接器/NET开发者指南</a>。</li>
</ul>
<p><strong>本地化</strong></p>
<ul>
<li>服务器可以提供各种语言的报错信息。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/error-message-language.html">章节10.12，设置错误提示的语言</a>。</li>
<li>完全支持不同的字符集，包括 <code>latin1</code> (cp1252)，<code>german</code>，<code>big5</code>，<code>ujis</code> ，几种Unicode编码，以及别的。比如， Scandinavian 的字符 “<code>å</code>”, “<code>ä</code>” 和“<code>ö</code>” 可以用在表和列的名字中。</li>
<li>所有的数据以选定的字符集存储。</li>
<li>根据默认的字符集和校对规则进行排序和比较。当MySQL服务运行的时候也可以对该规则进行更改(详见<a href="https://dev.mysql.com/doc/refman/8.0/en/charset-server.html">章节10.3.2，“服务器字符集和校验”</a>)。一个非常高级的排序例子，可以看下捷克的排序编码。MySQL支持多种可以在编译和运行阶段指定的字符集。</li>
<li>服务器时区可以动态的改变，而且单独的客户端可以指定各自的时区。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">章节5.1.13，MySQL服务器时区支持</a>。</li>
</ul>
<p><strong>客户端和工具</strong></p>
<ul>
<li>MySQL包含多个客户端和实用程序。包括命令行程序，比如 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html"><strong>mysqldump</strong></a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqladmin.html"><strong>mysqladmin</strong></a> ，以及图形化程序 <a href="https://dev.mysql.com/doc/refman/8.0/en/workbench.html">MySQL Workbench</a> 。</li>
<li>MySQL服务器内置了对于SQL语句的检查，优化和表修复的支持。这些语句可以通过<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlcheck.html">mysqlcheck</a>客户端从命令行使用。MySQL也包含了<a href="https://dev.mysql.com/doc/refman/8.0/en/myisamchk.html">myisamchk</a>工具，一个非常快速的命令行工具，用于在MyISAM表提交这些操作。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/programs.html">章节4，MySQL程序</a>。</li>
<li>可以调用 –help 和 -?来呼叫MySQL程序用以获取在线协助。</li>
</ul>
<h4 id="1-3-3-MySQL的历史"><a href="#1-3-3-MySQL的历史" class="headerlink" title="1.3.3 MySQL的历史"></a>1.3.3 MySQL的历史</h4><p>我们一开始想要用我们自己的快速，低级的引擎来使用mSQL数据库来连接我们的表。然而，经过了一些测试后，我们认为mSQL的速度和灵活性达不到我们的要求。这导致了我们的数据库的一个新的SQL接口，但是其API接口和mSQL几乎一样。该API设计为允许那些为mSQL编写的第三方代码可以很方便的移植以用于MySQL。</p>
<p>MySQL得名于联合创建人Monty Widenius的女儿，My。</p>
<p>MySQL的海豚（我们的logo）的名字是“Sakila”，这来自于“为海豚取名”的比赛中用户建议的庞大的名字列表里选择出来的。最后获胜的名字由来自非洲Swaziland， 一个名叫Ambrose Twebaze的开源软件开发者提供。据 Ambrose所说，这个女性化的名字Sakila出自 Swaziland 的当地语Siswati。Sakila也是坦桑尼亚的 Arusha 的一个城镇的名字，邻近 Ambrose 的原籍国乌干达。</p>
<h3 id="1-4-MySQL8-0更新了什么"><a href="#1-4-MySQL8-0更新了什么" class="headerlink" title="1.4 MySQL8.0更新了什么"></a>1.4 MySQL8.0更新了什么</h3><p>这一节总结了在MySQL8.0中哪些被添加，启用，以及移除。随附的部分罗列了在MySQL8.0中已经被新增，启用，移除的选项和变量。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/added-deprecated-removed.html">章节1.5，“服务器，状态变量和选项在MySQL8.0中的添加，弃用和删除”</a>。</p>
<span id="more"></span>
<p><strong>MySQL8.0新增的特性</strong></p>
<p>以下特性被加入到MySQL8.0中：</p>
<ul>
<li><p><strong>数据字典。</strong> MySQL现在合并了一个可以存储数据库对象的事务化的数据字典。在之前的MySQL发行版中，数据字典存储在元数据文件和非事务的表。关于更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary.html">章节14，MySQL数据字典</a>。</p>
</li>
<li><p><strong>原子数据定义语句(原子DDL)。</strong> 一个原子DDL语句包含了数据字典的升级，存储引擎的操作，以及将关联DDL操作的二进制日志写入到单独的原子事务中。要获取更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html">章节13.1.1，“原子数据定义语句的支持”</a>。</p>
</li>
<li><p><strong>升级过程。</strong> 在以前，安装了一个新版本的MySQL后，MySQL服务器会在下一次启动时自动升级数据字典表，在此之后，需要DBA在mysql的schema里手动调用 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 去升级系统表，也包括在别的schema比如sys schema和user schema里面的对象。</p>
<p>对于MySQL8.0.16来说，服务器会执行先前由 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 控制的任务。在安装了新版本的MySQL之后，服务器会在下次升级时自动执行所有的升级任务，而不是依赖DBA去调用 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 。而且，服务器会更新帮助表里面的内容（这是 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-upgrade.html"><strong>mysql_upgrade</strong></a> 没有做的）。一个新的 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-options.html#option_mysqld_upgrade"><code>--upgrade</code></a> 服务器参数为服务器如何自动执行数据字典和服务器升级的选项提供了控制。想要了解更多，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-what-is-upgraded.html">章节2.11.3，MySQL的升级流程升级了什么</a>。</p>
</li>
<li><p><strong>安全和账户管理</strong>。增加下列增强的功能后，可以提高安全性以及增加DBA在账户管理方面的灵活性：</p>
<ul>
<li><p>在mysql系统数据库中的授权表现在属于InnoDB（事务型）表。以前它们是MyISAM（非事务型）表。授权表的存储引擎的变化是伴随账户管理语句变化的基础。以前一句命名多个用户的账户管理的语句（如 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-user.html"><code>CREATE USER</code></a> 或 <a href="https://dev.mysql.com/doc/refman/8.0/en/drop-user.html"><code>DROP USER</code></a>) ，在其中一些用户命名失败的情况下也可以对别的用户命名成功。现在，每一个语句都是事务的，且要么所有的命名用户都成功，要么其中任何一个失败之后语句都会回滚并不发生任何效果。语句如果成功会被写入二进制表中，但是在失败时不会写入；在这种情况下，会发生回滚且没有任何变化发生。想要了解更多，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html">13.1.1“原子数据定义语句的支持”</a>。</p>
</li>
<li><p>一个新的 <code>caching_sha2_password</code>  认证插件已经可用。类似于 <code>sha256_password</code>  插件， caching_sha2_password 实现了 SHA-256 的密码Hash，但是在连接时用缓存来解决延迟问题。它也支持更多的连接协议，而且不需要为了基于RAS密钥对的密码交换功能和OpenSSL进行连接。</p>
<p> caching_sha2_password 和 sha256_password 的认证方式相比 mysql_native_password 插件提供了更多的安全加密方式，而且 caching_sha2_password 的性能比sha256_password更好。由于这些 caching_sha2_password 卓越的安全和性能的特点，现在已经成为首选的认证插件，而且也是默认的认证插件，而不是  <code>mysql_native_password</code> 。想要了解这种默认插件的变化对于服务器操作和服务器与客户端及连接器之间的兼容性的信息，详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password"> caching_sha2_password 作为首选的认证插件</a>。</p>
</li>
<li><p>MySQL如今支持角色，即权限集合的命名。角色可以被创建和删除。角色可以被授权和撤销权限。角色可以从用户账号中授权和删除。一个账户下的活跃的适用角色可以从账户里已授权的角色中选择，也可以在账户的登陆期间进行修改。想要了解更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/roles.html">6.2.10，使用角色</a>。</p>
</li>
<li><p>MySQL现在包含了用户账号目录的概念，根据系统和普通用户区分他们是否有 <a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a> 权限。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/account-categories.html">6.2.11，账户目录</a>。</p>
</li>
<li><p>在以前，除非在某些schema里，否则不能授予一个全局的权限。现在只要设置 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_partial_revokes"><code>partial_revokes</code></a>  系统参数为 enabled 就可以做到。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/partial-revokes.html">6.2.12，使用部分撤销的权限限制</a>。</p>
</li>
<li><p>授权语句拥有一个可以指定额外的权限信息的用户条件去用于语句执行。这种语法在SQL层面可见， 尽管其主要目的是使在部分撤销所施加的授予者特权限制的所有节点之间实现统一复制， 通过使这些限制出现在二进制日志中。</p>
</li>
<li><p>MySQL现在会保留历史密码信息，限制重复使用以前的密码。DBA可以要求一些数量的密码更改或者一段时间内不可以从以前的密码中选择。可以为全局和每个账户建立密码重新使用的策略。</p>
<p>现在可以通过指定当前要被取代的密码来验证更改密码的操作。这可以让DBA去避免那些不能提供他们知道的当前密码的用户去修改密码。可以为全局或每个账户建立密码验证策略。</p>
<p>账户现在允许使用双重验证，这使得在复杂的多服务器系统上可以无缝的提交分阶段的密码修改，而不需要停机。</p>
<p>这些功能为DBA提供了对密码管理的完全掌控。关于更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/password-management.html">6.2.15，密码管理</a>。</p>
</li>
<li><p>MySQL现在支持FIPS模式，它使用OpenSSL编译，在运行时一个OpenSSL库和FIPS对象模式都是可用的。FIPS模式为密码相关操作强加了一些条件，比如对于可接受的加密方式的限制，或者对于密码长度的要求。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/fips-mode.html">6.5，FIPS支持</a>。</p>
</li>
<li><p>服务器现在可以在运行时重新配置服务器用于新连接的SSL上下文。该功能可能会很有用，比如，在一个MySQL服务器运行太久而SSL证书过期，可以避免去重启该服务器。详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/using-encrypted-connections.html#using-encrypted-connections-server-side-runtime-configuration">加密连接的服务器端运行时配置</a>。</p>
</li>
<li><p>OpenSSL1.1.1支持用于加密连接的TLS1.3协议，如果服务端和客户端都用OpenSSL或更高版本来编译，那么MySQL8.0.16和更高版本下也将支持TLS1.3协议。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/encrypted-connection-protocols-ciphers.html">6.3.2，加密连接TLS协议和密码</a>。</p>
</li>
<li><p>MySQL现在授予客户端在已命名的管道上用于windows尽量少的必要连接的访问控制。新的MySQL客户端软件可以不用任何额外配置打开命名管道连接。如果更早版本的客户端软件不能马上升级，那么新的 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_named_pipe_full_access_group"><code>named_pipe_full_access_group</code></a>系统参数可以给予windows用户组必要的权限用于打开命名管道连接。完全访问权限的用户组的成员应该是暂时的且被限制的。</p>
</li>
</ul>
</li>
<li><p><strong>资源管理。</strong> MySQL现在支持资源组的创建和管理，并且允许跟服务器一起运行的线程分配给特定的组，以便线程根据组的可用的资源执行。组属性可以控制其资源，允许或者限制组内线程的资源消费。DBA可以根据不同的工作量来调整这些属性为合适的值。现在，CPU时间是可以管理的资源，其概念由”虚拟CPU”来表示，其包含了CPU内核，超线程，硬件线程等等。服务器在启动时决定有多少虚拟CPU可用，并且拥有相应权限的数据库管理员可以将这些CPU与资源组关联并分配线程给组。要了解更多信息，详见<a href="https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html">8.12.5，资源组</a>。</p>
</li>
<li><p><strong>表加密管理。</strong> 现在可以通过定义和强制加密默认值来全局管理表加密。default_table_encryption常量为新创建的schema和一般表空间定义了一个加密默认值。当创建一个schema时，加密默认值同时也可以用DEFAULT ENCRYPTION条款来进行定义。默认情况下，创建一个表的同时<br>会继承当前的schema或一般表空间的加密方式。设置table_encryption_privilege_check常量为可用，会强制使用加密默认值。当创建和修改一个不同于默认表加密设置的schema或表空间，或创建和修改一个不同于默认schema加密设置的表时，会发生权限检查。在table_encryption_privilege_check常量<br>为可用时，TABLE_ENCRYPTION_ADMIN权限会允许覆盖默认加密设置。想要了解更多这方面信息，查看《为Schemas和一般表空间定义一个加密默认值》章节。</p>
</li>
<li><p><strong>InnoDB的优化</strong> 包含以下对于InnoDB的优化：</p>
<ul>
<li>当前最大的自增计数器发生值改变时，会写入到redo日志，并在每一次检查点保存在私有引擎的系统表里。这个改进使得自增计数器的值在系统重启时保持不变。额外的：<ul>
<li>服务器重启时不会取消表选项里<code>AUTO_INCREMENT=N</code>的效果。如果你重新设置了自增计数器的值，或者你将自增计数器的值修改为一个很大的值，新的值也会在服务器重启时保持不变。</li>
<li>服务器重启时会立刻跟随一项<a href="https://dev.mysql.com/doc/refman/8.0/en/commit.html">ROLLBACK</a>的操作，而不再重新使用事务回滚后的自增值。</li>
<li>如果你将自增列的值修改为一个比当前最大自增值更大的值（比如一个update的操作），新的值会持久化，并且随之的新增操作会在这个值基础上自增。<br>更多的信息，详见15.6.1.6章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">InnoDB中的自增操作</a>，以及<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization">InnoDB自增计数器的初始化</a>。</li>
</ul>
</li>
<li>当索引树的损坏发生时，InnoDB会往redo日志写入一个损坏标识，这会保证损坏标识安全的销毁。InnoDB也会在每个检查点往私有引擎的系统表里写入内存崩溃的标识数据。在还原时，InnoDB在表和索引被标识为崩溃对象前会从这两个地方读取崩溃标识并合并结果内容。</li>
<li>InnoDB缓存插件支持多种get操作（在一个缓存查询中获取多种key-value组合）和范围查询。详见15.20.4章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html">InnoDB缓存的多种get和范围查询支持</a></li>
<li>innodb_deadlock_detect是一个新的动态变量，可以用于对不可用的死锁的监控。在高级的金融系统中，死锁监控可以缓解大量的线程等待同一个锁的情况。同时，在死锁发生时，使用在事务回滚时的innodb_lock_wait_timeout的设置并关闭死锁监控也可能是更有效的办法。</li>
<li>新的<code>INFORMATION_SCHEMA.INNODB_CACHED_INDEXES</code>表会在InnoDB缓冲池中为每个索引记录索引页缓存的数量。</li>
<li>现在，InnoDB的临时表会在共享的临时表空间ibtmp1中创建。</li>
<li>InnoDB<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html">表空间加密功能</a>支持对于redo日志和undo日志数据的加密。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html#innodb-data-encryption-redo-log">Redo日志加密</a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html#innodb-data-encryption-undo-log">Undo日志加密</a>。</li>
<li>对于<code>SELECT ... FOR SHARE</code>和<code>SELECT ... FOR UPDATE</code>这样的加锁读取语句，InnoDB支持使用<code>NOWAIT</code>和<code>SKIP LOCKED</code>选项。语句中的<code>NOWAIT</code>选项的效果是当一列被请求的行被另一个事务锁定时立刻返回结果。<code>SKIP LOCKED</code>会在结果集中移除被锁定的行。详见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html#innodb-locking-reads-nowait-skip-locked">并发锁读中使用NOWAIT和SKIP LOCKED</a>。<br><code>SELECT ... FOR SHARE</code>语句取代<code>SELECT ... LOCK IN SHARE MODE</code>，但是<code>LOCK IN SHARE MODE</code>依然保持着向后的兼容性。两个语句是等效的。但是<code>FOR UPDATE</code>和<code>FOR SHARE</code>支持<code>NOWAIT&#39;，&#39;SKIP LOCKED</code>，以及<code>OF</code>之类的<code>tbl_name</code>选项。<br>详见13.2.10章节，<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">SELECT STATEMENT</a>。<code>OF</code>这个<code>tbl_name</code>值用于锁定对命名的表的查询(TODO)。</li>
<li>ADD PARTITION, DROP PARTITION, COALESCE PARTITION, REORGANIZE PARTITION, and REBUILD PARTITION ALTER TABLE options are supported by native partitioning<br>in-place APIs and may be used with ALGORITHM={COPY|INPLACE} and LOCK clauses.DROP PARTITION with ALGORITHM=INPLACE deletes data stored in the partition and drops the partition. However,<br>DROP PARTITION with ALGORITHM=COPY or old_alter_table=ON rebuilds the partitioned table and attempts to move data from the dropped partition<br>to another partition with a compatible PARTITION … VALUES definition. Data that cannot be moved to another partition is deleted. </li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>一周文章收集-20220117</title>
    <url>/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/</url>
    <content><![CDATA[<p>我发现逐篇翻译看到的技术博文并不是那么高效，还是像阮老师那样把一周看到的有价值的文章收集起来，作为一个归档会更加有用。</p>
<hr>
<h2 id="微软发布了自己的linux版本：CBL-Mariner"><a href="#微软发布了自己的linux版本：CBL-Mariner" class="headerlink" title="微软发布了自己的linux版本：CBL-Mariner"></a><a href="https://github.com/microsoft/CBL-Mariner">微软发布了自己的linux版本：CBL-Mariner</a></h2><p>根据github上的介绍，CBL-Mariner 是微软为了云架构，edge的产品和服务开发的内部linux发行版。CBL-Mariner的设计是为了云设备和服务提供持久化的平台，并使得微软可以跟上linux的更新脚本。这是微软对于linux技术投入的一部分，还包括<a href="https://azure.microsoft.com/en-us/blog/sonic-the-networking-switch-software-that-powers-the-microsoft-global-cloud/">SONiC</a>， <a href="https://docs.microsoft.com/en-us/azure-sphere/product-overview/what-is-azure-sphere">Azure Sphere OS</a> 和 <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a>。</p>
<h2 id="程序员才懂的幽默"><a href="#程序员才懂的幽默" class="headerlink" title="程序员才懂的幽默"></a><a href="https://programmerhumor.io/">程序员才懂的幽默</a></h2><p>一个摸鱼网站，着实不错，里面包含了大量得具有一定开发知识才能懂的段子，是纯英文的，摸鱼的同时也能顺便提升下英文水平（并不）。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/programmerhumor.png"></p>
<h2 id="权力的游戏和指环王等奇幻故事里的地图"><a href="#权力的游戏和指环王等奇幻故事里的地图" class="headerlink" title="权力的游戏和指环王等奇幻故事里的地图"></a><a href="https://www.smithsonianmag.com/smart-news/explore-literary-maps-of-famous-authors-180979409/"><code>权力的游戏</code>和<code>指环王</code>等奇幻故事里的地图</a></h2><p>这篇文章介绍了奇幻小说中的地图，这些地图的创作倾注了作者的心血和巧思，可以给读者带来沉浸的阅读感受。原文中有更多的地图介绍。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/map1.png" alt="`奥德赛`的扉页地图"></p>
<h2 id="13个程序员必看的博客网站"><a href="#13个程序员必看的博客网站" class="headerlink" title="13个程序员必看的博客网站"></a><a href="https://blog.bit.ai/programming-blogs-and-websites/">13个程序员必看的博客网站</a></h2><p>技术博客是程序员保持技术新鲜度非常重要的一个渠道，不仅仅是看其他的技术博客，自己维护一个博客也是很有必要。文章介绍了13个可以提升技术水平的博客网站，可以作为参考。<br>P.S.后面发现里面大部分网站的质量不高，要么得收费，要么更新频率低，要么没啥有价值的文章。。。<br><img src="/2022/01/19/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20210117/blog.jpg"></p>
<h2 id="深入详解Node-js线程池"><a href="#深入详解Node-js线程池" class="headerlink" title="深入详解Node.js线程池"></a><a href="https://betterprogramming.pub/a-deep-dive-into-the-node-js-thread-pool-a1f32a4f8628">深入详解Node.js线程池</a></h2><p>这篇文章介绍了使用BigQuery这个Node插件后出现的错误，应该有点深度，以我有限的Node.js知识和英文水平，并没有怎么看懂。<br>P.S.这个网站居然是收费的，一个月一篇免费博客。。。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>一周文章收集-20220124</title>
    <url>/2022/01/25/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20220124/</url>
    <content><![CDATA[<h2 id="为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释"><a href="#为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释" class="headerlink" title="为什么网络游戏Wordle病毒式的传播，来听听心理学家的解释"></a><a href="https://www.smithsonianmag.com/smart-news/heres-why-the-word-game-wordle-went-viral-180979439/">为什么网络游戏<code>Wordle</code>病毒式的传播，来听听心理学家的解释</a></h2><p>近期有个网络游戏<code>Wordle</code>在推特上及其流行，这是字谜类的游戏。规则比较简单，玩家需要猜一个5个字母组成的单词。其特别之处在于拥有社交属性，即一盘游戏是需要好几个人参与的，通过不同色块提示字母和位置的正确与否，这样每个人都能看到别人猜的进度，形成一种竞争体验。<br><img src="/2022/01/25/blog/%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86-20220124/wordle.png"></p>
<h2 id="开源工具Arthas在线诊断java程序"><a href="#开源工具Arthas在线诊断java程序" class="headerlink" title="开源工具Arthas在线诊断java程序"></a><a href="https://arthas.aliyun.com/doc/">开源工具Arthas在线诊断java程序</a></h2><p><code>Arthas</code>是Alibaba开源的Java诊断工具，可以实现在线监控执行方法，观测返回值等，在很多特殊的场景下，比如在家里无法部署开发环境却需要检查线上程序具体问题，或者需要查问题的程序只有线上包没有源代码，可以使用Arthas进行在线诊断并处理，以后将会专门写一篇关于如何使用Arthas的文章。</p>
<h2 id="如何在Debian-11安装CSF"><a href="#如何在Debian-11安装CSF" class="headerlink" title="如何在Debian 11安装CSF"></a><a href="https://vitux.com/how-to-install-config-server-firewall-csf-on-debian/">如何在Debian 11安装CSF</a></h2><p>CSF全称是Config Server Firewall，是一套可以轻松对防火墙策略和规则进行配置的防火墙软件，适合不熟悉linux防火墙的新手使用，本文介绍了如何安装和使用CSF，以增强linux的安全性。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一周文章收集</category>
      </categories>
  </entry>
  <entry>
    <title>12例bash脚本最佳实践</title>
    <url>/2022/01/18/blog/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%BF%BB%E8%AF%91-12%E4%BE%8Bbash%E8%84%9A%E6%9C%AC%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><strong>声明</strong></p>
<p>翻译自<a href="https://www.faqforge.com/linux/12-best-practices-for-writing-bash-scripts/">12 Best Practices for Writing Bash Scripts</a><br>翻译完发现这篇文章技术价值相当低。。。</p>
<hr>
<p>Bash shell全称Bourne Again Shell，现在作为大部分的linux发行版本的默认shell。一个Bash脚本是一个包含多行shell命令的文件，用于执行特别的命令。如果你熟知bash脚本，那这篇文章就很适合你，在这篇文章中我写了12种bash脚本的最佳实践，可以增加bash脚本的效率并使其更易读。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解是一段清晰代码最基础的部分，用于定义或解释复杂代码的不同部分。写脚本的时候，你可以毫不费力的看懂很早之前你写过的代码。同样也能帮助你在一个大的项目组提高工作效率，帮助你理解一个函数或方法的真实用途。</p>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>一个函数是一堆命令联合之后实现一个特定的任务，可以帮助工作流模块化并使得脚本可复用，消除重复的代码。这可以让你维护的代码更加清晰和可读。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_root</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;function has been called&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对引用变量使用双引号"><a href="#对引用变量使用双引号" class="headerlink" title="对引用变量使用双引号"></a>对引用变量使用双引号</h2><p>使用双引号可以消除不必要的通配符，同时当引用变量包含分割字符和空格时可以将包含空格的单词进行分割。如下例子中，我们可以看出变量用不用双引号的区别。（译者：没有例子，作者估计漏了）</p>
<h2 id="出现错误时终止脚本"><a href="#出现错误时终止脚本" class="headerlink" title="出现错误时终止脚本"></a>出现错误时终止脚本</h2><p>有时候执行脚本的时候可能会出现一些错误。然而即使一个命令失败了，剩余的脚本也有可能继续运行，从而影响脚本中的其他命令。所以为了避免任何进一步的逻辑错误，我们需要加入<code>set -o errexit</code>或<code>set -e</code>终止错误的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="使用未声明变量时终止脚本"><a href="#使用未声明变量时终止脚本" class="headerlink" title="使用未声明变量时终止脚本"></a>使用未声明变量时终止脚本</h2><p>脚本执行时，如果存在未声明的变量，可能导致bash使用变量时出现逻辑错误。当bash中存在一个未声明变量时，我们可以用如下命令中止脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br></pre></td></tr></table></figure>

<h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>我们必须对一个变量的数据类型和用法进行声明。当变量未声明，bash可能会因此执行失败。变量可以被声明为全局或在脚本内的本地变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable declaration</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -r -i x=30</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my_variable</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> -r name = <span class="variable">$&#123;HOME&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用花括号"><a href="#使用花括号" class="headerlink" title="使用花括号"></a>使用花括号</h2><p>当使用变量关联字符串时，可以使用花括号将变量圈起来，以避免不必要的变量使用。同样也可用于对字符串的简单定义。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom variable</span></span><br><span class="line"></span><br><span class="line">data= <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>_data is being used&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>当分配命令的输出到变量时，bash使用命令替换的特性。我们需要使用推荐的$()而不是反引号去分配输出到变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"><span class="comment">#Displaying Date</span></span><br><span class="line"></span><br><span class="line">date_now = <span class="variable">$&#123;date&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>在我们的系统中，所有的环境变量都用大写字母。所以当我们声明一个本地变量时，需要使用小写字母以避免环境变量和本地变量名之间的冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Terminate the script on command fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line">user_var = <span class="string">&quot;<span class="variable">$HOME</span> is your system&#x27;s current login user.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="声明静态变量"><a href="#声明静态变量" class="headerlink" title="声明静态变量"></a>声明静态变量</h2><p>如果你拥有一个在整个脚本中都不变的静态数据，你可以将值分配到一个不能被修改的静态变量上。你可以使用<code>readonly</code>命令来分配静态变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is nginx test host config</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> test_conf_path = <span class="string">&quot;/etc/nginx/conf.d/test.conf&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>在多数场景下字符串用<code>==</code>进行比较，但是在bash脚本中，字符串用<code>=</code>就可以完成比较。在如下例子中，我用<code>=</code>比较两个字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># comparing two strings</span></span><br><span class="line"></span><br><span class="line">If [ <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span> = <span class="string">&quot;User1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;This is test purpose&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>调试是鉴定问题最重要的部分。我们需要在运行脚本的时候加上<code>-n</code>命令来检查脚本语法错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -n script_name</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以使用如下命令打开脚本的debug模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -x script_name</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样，就是12个可以提升你脚本能力的bash脚本实践。当使用命令去完成特殊任务时，bash脚本将是更出色的那个。</p>
<hr>
<p>refers to 指的是；全称<br>demonstration （强烈表达）集会示威;游行示威;示范;示范表演;演示;证明;证实;论证;说明;表达<br>effortless 不费力的<br>modularizing 模块化<br>globbing 通配符<br>splitting 分割<br>curly braces 大括号;花括号;大括弧;花括號<br>concatenation 串联<br>substitution 置换;取代;代换;代入<br>assigning 分配<br>syntax 语法</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-置身事内</title>
    <url>/2022/03/14/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</url>
    <content><![CDATA[<p><img src="/2022/03/14/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/1.jpg"></p>
<h2 id="第一章-地方政府的权力和事务"><a href="#第一章-地方政府的权力和事务" class="headerlink" title="第一章 地方政府的权力和事务"></a>第一章 地方政府的权力和事务</h2><ul>
<li>第一节 政府治理的特点<ul>
<li>五级政府管理体系：中央-省-市-县区-乡镇</li>
<li><strong>四套领导班子：党委、政府、人大、政协等，在五级政府下都完全复制</strong><ul>
<li>条条块块：既有垂直的上下关系，又有横向的行政区划</li>
<li>如县教育局受上级的市教育局管辖，又受县市政府管辖</li>
</ul>
</li>
<li>官僚体系<ul>
<li>官员学习和贯彻统一的意识形态</li>
<li>由上级任命</li>
<li>地方官在多地轮流任职</li>
</ul>
</li>
</ul>
</li>
<li>第二节 外部性和经济规模<ul>
<li>公共服务<ul>
<li>覆盖区域使用人数越多越好</li>
<li>行政区划的范围</li>
<li>边远地区是否有必要建设公共服务</li>
</ul>
</li>
<li>人口密度<ul>
<li>云南-腾冲线：43%东边面积占了94%人口</li>
<li>密度高的地方区划要小，密度低的地方区划要大</li>
<li>政策上会对城市群进行规划，以打破交界</li>
<li>人为划分意图消除边界不一定有好效果，主要还是受地理因素影响</li>
</ul>
</li>
<li>行政交界处<ul>
<li>交界处三不管，经济一般更差</li>
<li>边界处交通网路会更疏</li>
<li>环境问题，污染排向边界处</li>
<li>长期看，需要进行深化的市场化改革</li>
<li>中短期通过行政区划调整和都市圈</li>
</ul>
</li>
</ul>
</li>
<li>第三节 复杂信息<ul>
<li><strong>实际权威来自信息优势</strong></li>
<li>下级具有信息优势</li>
<li>上级只有形式权威，办事最终还是要看下级意愿</li>
</ul>
</li>
<li>第四节 激励相容<ul>
<li>专业性较强的部门一般受垂直上下级的约束较大，如海关，工商部门等</li>
<li>完全受垂直上下级管理，会减弱地方监管力度，因此需要平衡</li>
<li>中央做好约束，同时也让地方发挥更大的自治权</li>
</ul>
</li>
<li><strong>第二至第四节就是事权划分的三大原则</strong></li>
<li>第五节 招商引资<ul>
<li>地方政府给予企业土地开发支持</li>
<li>地方政府给予企业金融支持</li>
<li>地方政府给予补贴和税收优惠</li>
<li>地方政府提供招工服务<span id="more"></span>    </li>
</ul>
</li>
</ul>
<h2 id="第二章-财税与政府行为"><a href="#第二章-财税与政府行为" class="headerlink" title="第二章 财税与政府行为"></a>第二章 财税与政府行为</h2><ul>
<li>第一节 分税制改革<ul>
<li>财政包干 1985-1993<ul>
<li>农村土地承包，城市企业承包，政府财政承包</li>
<li>地方根据实际进行不同形式的承包和分账<ul>
<li>北京确定一个增长比例，超过部分归北京所有，没超过部分和中央55分账</li>
<li>广州按照1987年上缴的基数，每年递增9%归中央，剩余归自己</li>
<li>上海定额上缴，每年缴105亿</li>
</ul>
</li>
<li>地方比较有动力增加财政收入，促进了企业的发展</li>
<li>地方财政收入增长较快，但是由于承包上缴，导致中央的财政收入增长很慢，造成中央政府很穷</li>
<li>地方也通过各种手段帮助企业减税，进一步导致中央收入变少</li>
<li>影响中央对于整体经济的调控</li>
</ul>
</li>
<li>分税制改革<ul>
<li>分为中央税、地方税、共享税</li>
<li>同时分设国税、地税两套机构，与地方财政部门脱钩</li>
<li>中央设立税收返还机制，防止地方税收急剧下降</li>
<li>改革后中央收入剧增，增强了宏观调控能力</li>
</ul>
</li>
</ul>
</li>
<li>第二节 土地财政<ul>
<li>招商引资<ul>
<li>地方财政更喜欢重资产的制造业<ul>
<li>投资规模大</li>
<li>增值税在生产环节增收，跟生产规模挂钩</li>
<li>制造业可以吸收低技能劳动力，并带动第三产业发展</li>
</ul>
</li>
<li>重生产而轻环保，轻民生</li>
</ul>
</li>
<li>土地公有制<ul>
<li>城市土地归国家所有，农村土地归集体所有</li>
<li>农村土地要建设，必须先转为国有</li>
<li>土地转让金额随着城市化进展开始大幅增加</li>
</ul>
</li>
<li>任期内政府过度借债导致下任政府难以为继</li>
</ul>
</li>
<li>第三节 纵向不平衡和横向不平衡<ul>
<li>基层财政<ul>
<li>落后地区的税收收入较低，导致政府很难展开工作</li>
<li><strong>三农问题：农民苦，农村穷，农业危险</strong><ul>
<li>统筹城乡发展</li>
<li>废除农业税</li>
<li>农村公共服务开支纳入国家财政</li>
<li>转移支付制度中加入激励机制，以精简政府机构</li>
<li>地方财政归上一级政府统筹，乡财县管</li>
<li>放权给县级政府，缩小城乡差距</li>
</ul>
</li>
<li>“乡财县管”和“省直管县”改革，只适用于浙江等发达地区，不发达地区效果不佳</li>
</ul>
</li>
<li>地区间不平等<ul>
<li>中央转移支付，使得落后地区的平均财政支出和发达地区差不多</li>
<li>一般转移支付：条件少，可以自行决定用途。导致越穷的地方拿到越多，影响创收动力。</li>
<li>专项转移支付：项目专项资金。由于发达地区更可能做好项目，导致发达地区拿到越多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章-政府投融资与债务"><a href="#第三章-政府投融资与债务" class="headerlink" title="第三章 政府投融资与债务"></a>第三章 政府投融资与债务</h2><ul>
<li>第一节 城投公司与土地金融<ul>
<li>地方政府不能从银行贷款，因此通过成立国资企业进行融资<ul>
<li>持有政府的土地使用权，因此可以撬动银行贷款，快速扩展</li>
<li>盈利状况依赖政府补贴</li>
<li>可以获得政府担保，融资更容易</li>
</ul>
</li>
<li>工业园区开发<ul>
<li>一种由国企承当，投资大，盈利低，靠后期运营来实现盈利</li>
<li>一种由私企承当，通过开发房地产来反哺工业区实现盈利</li>
</ul>
</li>
</ul>
</li>
<li>第二节 地方政府债务<ul>
<li>城投公司，始于国开行</li>
<li>城商行由地方政府控制，和国开行相比<ul>
<li>资金多来于中短期存款，风险较大</li>
<li>存款来源不稳定</li>
</ul>
</li>
<li>地方债务水平<ul>
<li>估计占gdp六成左右，虽然不低，但和美日相比依然不算多</li>
<li>低一级的政府以及落后地区债务风险大</li>
</ul>
</li>
<li>债务治理<ul>
<li>债务置换，用地方政府的公债替换融资公司的银行贷和城投债</li>
<li>推动融资平台转型，剥离为政府融资的功能</li>
<li>约束银行和金融机构的资金流入融资平台</li>
<li>对过度负债终身追责</li>
</ul>
</li>
</ul>
</li>
<li>第三节 招商引资中的地方官员<ul>
<li>官员政绩<ul>
<li>经济发展是官员的主要政绩，因此新官上任都会大兴土木，导致城市规模虽然变大，但是整体效率较低</li>
<li>中央强调不已gdp作为政绩考核的主要指标</li>
<li>除了晋升和激励，内在的道德驱动也是官员的重要动力</li>
</ul>
</li>
<li>腐败问题<ul>
<li>近年来的腐败多与土地开发有关</li>
<li>腐败与经济高速发展长期并存</li>
<li>官商勾连腐败，政府将项目给关系户<ul>
<li>长期偏重投资导致资本收入增长高于老百姓收入增长</li>
<li>扭曲投资和信贷资源配置，把大量资金浪费在效益不高的关系户项目上，推升债务负担和风险</li>
<li>扩大贫富差距</li>
<li>形成利益集团，不利于市场发展</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四章-工业化中的政府角色"><a href="#第四章-工业化中的政府角色" class="headerlink" title="第四章 工业化中的政府角色"></a>第四章 工业化中的政府角色</h2><ul>
<li>第一节 京东方与政府投资<ul>
<li>20世纪90年代，液晶屏巨头们联手抬高价格，垄断市场</li>
<li>京东方在此背景下获得了政府大量投资<ul>
<li>初代时购买了价格峰值的液晶面板，在低谷时生产出了成品，导致大量亏损</li>
<li>改用股权融资：先向地方政府筹本金，不足部分再贷款</li>
<li>新的融资方式获得了更多资金，同时也赶来智能手机的爆发，获得了盈利</li>
</ul>
</li>
<li>政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应</li>
<li>新兴制造业在地理上的集聚效应很强</li>
<li>政府扶持也吸引了一些并无技术实力和竞争力的小企业进入该行业，引发了对产能过剩的担忧</li>
</ul>
</li>
<li>第二节 光伏发展和政府补贴<ul>
<li>2000 - 2010年，大量光伏企业获得政府补贴，急剧扩张</li>
<li>随着金融危机，以及成本高于煤电，光伏企业累积了大量的债务，导致倒闭</li>
<li>补贴电价下调，但是企业的技术积累和成本降幅依然快于补贴降幅，使得光伏迅猛发展</li>
<li>政府补贴造就了光伏的需求</li>
<li>政府补贴有助于新技术起步时的发展</li>
<li>产业政策要有推出机制<ul>
<li>政策本身要有推出机制，如光电补贴逐步降低</li>
<li>低效企业破产退出的渠道要畅通</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-城市化与不平衡"><a href="#第五章-城市化与不平衡" class="headerlink" title="第五章 城市化与不平衡"></a>第五章 城市化与不平衡</h2><ul>
<li>第一节 房价与居民债务<ul>
<li>土地供需<ul>
<li>现代经济集聚效应很强，经济活动及就业越来越向大城市集中</li>
<li>地区房价差异的主要原因是供需失衡</li>
<li>中国对建设用地指标实行严格管理，每年的新增指标由中央分配到省，再由省分配到地方</li>
<li>建设用地指标不能在全国交易，土地使用效率很难提高</li>
</ul>
</li>
<li>欧美房价与居民债务<ul>
<li>二战之前，欧美自有住房比例很低，大部分为租房</li>
<li>欧美自有住房比例上升后<ul>
<li>房产在居民资产中的比例上升</li>
<li>政府开始降低卖房门槛和按揭比例</li>
</ul>
</li>
<li>美国出于政治选票因素，大量房贷给低收入者买房，导致坏账变多，引发次贷危机<ul>
<li>导致房价降低</li>
<li>进而抑制消费</li>
</ul>
</li>
<li>房地产常被称作“经济周期之母”<ul>
<li>银行可以通过按揭创造无限的购买力</li>
<li>不可再生的城市土地供给有限</li>
</ul>
</li>
</ul>
</li>
<li>我国房价与居民债务<ul>
<li>2008年后，房价急速上升<ul>
<li>居民债务负担上涨3倍多，占GDP的54%</li>
<li>平均债务约等于居民1.6倍年收入</li>
</ul>
</li>
<li>影响消费</li>
</ul>
</li>
<li>房价与居民债务风险<ul>
<li>拉大各地的资产差距</li>
<li>消费下滲：刺激低收入者举债消费</li>
<li>借贷比例上升，影响未来收入增长，导致债务负担变重</li>
<li>负债率高更容易受到房价下跌的影响</li>
<li>我国的金融危机概率低<ul>
<li>首付比例30%，不会如美国可以低到0</li>
<li>信贷资产没有层层嵌套，导致风险放大</li>
<li>资本账户管制，限制外国资产参与我国房市</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二节 不平衡与要素市场改革<ul>
<li>低收入者到发达城市是提高收入最简单的途径</li>
<li>地方政府偏重投资，收入分配偏向资本，降低劳动收入占比</li>
<li>需要平衡人均规模，而不是总体规模</li>
<li>关键要让劳动力自由流动<ul>
<li>提高城市市场规模，分工细，使得低技能者也能有高收入</li>
<li>低技能者服务业支撑城市生活质量</li>
<li>城市规模的上升也能促进地区间的分工和流动</li>
</ul>
</li>
<li>土地流转<ul>
<li>2008年提出城乡统一的建设用地市场与国有土地享有平等权益</li>
<li>2015年试点三块地改革，即农村土地征收、集体经营性建设用地入市以及宅基地制度改革</li>
<li>2017年在租赁住房供需矛盾突出的超大和特大城市，开展集体建设用地上建设租赁住房试点</li>
<li>三条底线<ul>
<li>土地公有制性质不变</li>
<li>耕地红线不突破</li>
<li>农民利益不受损</li>
</ul>
</li>
</ul>
</li>
<li>户籍改革<ul>
<li>逐步取消农业户口和非农业户口差别</li>
<li>2019年发改委提出放宽各类城市落户限制</li>
<li>未来方向<ul>
<li>建立健全城乡统一的建设用地市场</li>
<li>深化户籍制度改革</li>
<li>以经常居住地登记户口制度</li>
<li>基本公共服务与常住人口挂钩机制，推动公共资源按常住人口规模配置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三节 经济发展与贫富差距<ul>
<li>全球贫困人口急剧下降，主要贡献来自于中国</li>
<li>70后，经济快速增长使得财富继承的重要性下降，个人更看重自己的劳动收入</li>
<li>80，90后，房价的上涨使得财富继承重要性上升，拉大贫富差距</li>
<li>隧道效应：经济增长放缓，对穷人的影响更大</li>
</ul>
</li>
</ul>
<h2 id="第六章-债务与风险"><a href="#第六章-债务与风险" class="headerlink" title="第六章 债务与风险"></a>第六章 债务与风险</h2><ul>
<li>第一节 债务与经济衰退<ul>
<li>债务危机的爆发和蔓延非常迅速<ul>
<li>负债率高的经济中，资产价格下降速度也更快</li>
<li>资产价格下跌引起信贷收缩，导致资金链断裂</li>
<li>债务常常将风险集中到承受能力最弱的穷人身上</li>
</ul>
</li>
</ul>
</li>
<li>第二节 欧美债务的教训<ul>
<li>布雷顿森林体系<ul>
<li>各国货币以固定比例与美元挂钩</li>
<li>美元以固定比例与黄金挂钩</li>
<li>各国需要充足的外汇干预市场，防止汇率波动</li>
<li>因此国际资本流动规模不能太大，否则会冲破某些国家的外汇储备</li>
<li>因此要限制国内银行放贷，这样就能限制居民的进出口消费</li>
</ul>
</li>
<li>自由化浪潮<ul>
<li>各国实现浮动汇率</li>
<li>放松了贷款限制</li>
<li>银行危机风险加剧，在布雷顿森林体系下，1945-1970，只发生2次银行危机，自由化浪潮下，1980-2010发生了153次银行危机</li>
</ul>
</li>
<li>金融危机源头<ul>
<li>银行规模大，杠杆高</li>
<li>银行借进来的钱很多是短期的（比如活期存款），但贷出去的钱却大都是长期的（比如企业贷款），这种负债和资产的期限不匹配会带来流动性风险。</li>
<li>银行信贷大都和房地产有关，常常与土地和房产价值一同起落，放大经济波动</li>
<li>银行很少雪中送炭，却常常晴天送伞，繁荣时慷慨解囊、助推经济过热，衰退时却捂紧口袋、加剧经济下行</li>
<li>银行风险会传导到其他金融部门</li>
</ul>
</li>
<li>不平衡问题<ul>
<li>东亚贸易不平衡使得中国1997年金融危机中美元储备不足导致经济受损，因此之后大量买入美国国债</li>
<li>欧洲和美国贸易平衡，但是总量大，交易规模变大后，风险也变大</li>
<li>富人借债给穷人，拉大贫富差距</li>
</ul>
</li>
<li>实体企业投资不足<ul>
<li>投资流向了发展中国家</li>
<li>通信技术发展，使得资产涌入非失业和服务业</li>
<li>大企业规模越来越大，竞争性不足</li>
</ul>
</li>
</ul>
</li>
<li>第三节 中国债务与风险<ul>
<li>相比其他发展中国家，我国债务水平较低</li>
<li>债务累计过程<ul>
<li>08年为应对金融危机，出台4万亿计划</li>
<li>降准降息，放宽信贷</li>
<li>10-11年，经济过热，通胀加剧</li>
<li>欧债危机爆发后，国内制造业吃紧，央行继续降准降息</li>
<li>15年股灾后，美国量化宽松，导致资本外流，人民币汇率降低</li>
<li>导致央行的进一步降准降息，带动房价上涨</li>
</ul>
</li>
<li>企业债务<ul>
<li>地方政府投资基建，投资回报率低</li>
<li>国进民退问题，国企快速扩张，效率却较低，提升整体债务负担</li>
<li>推进改革<ul>
<li>推进国企混改，限制地方政府干预</li>
<li>加强金融监管，从源头上拧紧资金的水龙头</li>
<li>在要素市场上推行更加全面的改革，让市场力量在资金、土地、技术、劳动力等生产要素配置中发挥更大作用</li>
<li>改革和完善《企业破产法》，在债务重整过程中“去行政化”，避免地方官员主导企业破产重组，损害债权人利益</li>
</ul>
</li>
<li>房地产债务占总体债务比重较大</li>
<li>优质抵押物或者政府担保，可以使得银行的借贷风险降低                                                </li>
<li>影子银行<ul>
<li>银行通过卖理财产品筹得钱款</li>
<li>筹来的钱委托给信托公司  </li>
<li>信托公司将钱借给公司</li>
<li>理财产品不算银行储蓄，委托给信托公司的钱不算银行贷款，因此摆脱对银行的监管，成了影子银行</li>
</ul>
</li>
<li>2018年资管新规出台，打压了影子银行，同时也打压了小企业的融资渠道</li>
</ul>
</li>
</ul>
</li>
<li>第四节 化解债务危机<ul>
<li>压缩支出的方式<ul>
<li>收入减少是连锁反应，导致经济整体下行</li>
<li>债务负担可能反而上升</li>
<li>让债权人和债务人都痛苦</li>
</ul>
</li>
<li>增发货币<ul>
<li>08年金融危机前的主流做法</li>
<li>刺激投资和消费</li>
<li>温和的通货膨胀</li>
<li>没有明显的受损方</li>
</ul>
</li>
<li><strong>量化宽松</strong><ul>
<li>金融危机后主流做法</li>
<li>增发货币买入资产，维持资产价值</li>
<li>相当于将其他地方的负债转移到央行</li>
<li>理论上央行可以无限印钱，所以可以无限消化负债</li>
<li>不会过度通货膨胀，因为其他地方挣了钱会优先还债，支出并没有显著增加</li>
<li>难以刺激消费，依然帮助了富人消化债务，拉大贫富差距</li>
</ul>
</li>
<li>赤字货币化<ul>
<li>政府加大财政支出去刺激经济，由财政部发债融资，央行直接印钱买过来，无需其他金融机构参与也无需支付利息</li>
<li>用无利率的货币替代有利率的债务，以政府预算收支的数量代替金融市场的价格（即利率）来调节经济资源配置</li>
<li>会引发物价飞涨的恶性通货膨胀（国民党的教训）</li>
</ul>
</li>
<li>遏制新债务<ul>
<li>围绕供给侧结构性改革所推行的一系列重大经济金融改革</li>
<li>资本市场改革，改变以银行贷款为主的间接融资体系，拓展直接融资渠道，既降低债务负担，也提高资金使用效率</li>
<li><strong>我国债务风险的本质不是金融投机的风险，而是财政和资源分配机制的风险</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-国内国际失衡"><a href="#第七章-国内国际失衡" class="headerlink" title="第七章 国内国际失衡"></a>第七章 国内国际失衡</h2><ul>
<li>第一节 低消费与产能过剩<ul>
<li>消费不足<ul>
<li>2018年消费占gdp比重只有44%，而美国这一比例达到70%</li>
<li>从1980到2010年，消费比重从65%降到50%</li>
<li>居民可支配收入下降</li>
<li>居民储蓄率上升</li>
</ul>
</li>
<li>高储蓄率<ul>
<li>20世纪90年代储蓄率达到了25-30%，欧美这一比例一般在10%左右</li>
<li>计划生育导致下一代数量减少，养儿防老不可靠，导致需要存钱应对老年</li>
<li>政府民生支出不足</li>
<li>房价上升拉低消费，提高了储蓄</li>
</ul>
</li>
<li>地方政府推动工业化的方式加速了资本份额的上升和劳动份额的下降</li>
<li>国民经济分配中居民占比下降，政府和企业的占比就必然上升</li>
<li>经济到一定阶段后，不再是任何投资都有回报<ul>
<li>基础设施和工业体系已经比较完善， 投资难度加大</li>
<li>由于老百姓收入和消费不足，无法消化投资形成的产能，很多投资不能变成有效的收入，都浪费掉了，所以债务负担越积越重，带来了一系列风险</li>
<li>劳动收入份额下降和资本收入份额上升，会扩大贫富差距</li>
<li>由于消费不足和投资过剩，过剩产能必须向国外输出，输出产能会加重全球贸易失衡，引发贸易冲突</li>
</ul>
</li>
<li><strong>居民收入增长快于经济增长，居民收入份额才能提高</strong></li>
<li>过多的无用投资没带来收入，虽然gdp增长了，但是债务会积累，在未来爆发</li>
<li>对外贸易失衡也是内部结构失衡的延续</li>
</ul>
</li>
<li>第二节 中美贸易冲突<ul>
<li>只要全世界还信任美元的价值，美国就可以源源不断地用美元去换取他国实际的产品和资源</li>
<li>美国所谓的中国制造抢走美国工作并不确切<ul>
<li>美国制造业就业本身就一直在下降</li>
<li>制造业gdp占比一直很稳定，事实上是机器效率提高取代了人工</li>
</ul>
</li>
<li>民粹主义和全球化情绪爆发，引发美国人对于贸易保护的倾向</li>
<li>制造业和科学领域，各项指标已经开始毕竟甚至赶超美国</li>
<li>工业制造是科学进步的基础</li>
</ul>
</li>
<li>第三节 <strong>再平衡与国内大循环</strong><ul>
<li>要提高居民收入，就要继续推进城市化，让人口向城市尤其是大城市集聚</li>
<li>从目前的技术发展和发达国家的经验看，制造业的进一步发展吸纳不了更多就业</li>
<li>改革的关键是转变地方政府在经济中扮演的角色，遏制其投资冲动，降低其生产性支出，加大民生支出</li>
<li>要提高居民收入，还要扩宽居民的财产性收入，发展各种直接融资渠道，让更多人有机会分享经济增长的果实，这就涉及金融体系和资本市场的改革</li>
<li>“双循环”战略在强调“再平衡”和扩大国内大市场的同时，也强调了要扩大对外开放</li>
</ul>
</li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li>英国史学家艾伦的《全球经济史》（2015）</li>
<li>乔治梅森大学戈德斯通的《为什么是欧洲？世界史视角下的西方崛起》（2010）</li>
<li>哈佛大学弗里登的《20世纪全球资本主义的兴衰》（2017）</li>
<li>西北大学戈登的《美国增长的起落》（2018）</li>
<li>哈佛大学教授傅高义《邓小平时代》</li>
<li>《经济落后的历史透视》（格申克龙，2012）</li>
<li>《大转型：我们时代的政治与经济起源》（波兰尼，2020）</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-数据结构和算法图解</title>
    <url>/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/1.jpg"></p>
<h2 id="第一章-数据结构为何重要"><a href="#第一章-数据结构为何重要" class="headerlink" title="第一章 数据结构为何重要"></a>第一章 数据结构为何重要</h2><ul>
<li><strong>操作的速度，并不按时间计算，而是按步数计算。理解这个观点</strong>，因为不同机器其实运行速度都会有差异，真正决定效率的是一个操作的步数。</li>
<li>读取是一步到位，意味着是读取数组的索引<ul>
<li>计算机的内存可以看成一堆格子，内存的格子是地址连续的</li>
<li>声明数组时，是在内存中划分出一些连续的格子</li>
<li>查找任意索引，最多都是只需要1步</li>
</ul>
</li>
<li>查找意味着从数组中寻找是否存在某个值<ul>
<li>计算机需要从索引0开始寻找，即线性查找</li>
<li>查找任意内容，最多步骤为数组的索引长度N</li>
</ul>
</li>
<li>计算机知道数组的索引开始位置和结束位置<ul>
<li>插入末尾只需要一步，直接在末尾插入即可</li>
<li>开头或中间的位置，需要先移动其他元素的位置，再进行插入</li>
<li>最复杂的插入，是在数组开头插入，意味着需要将N个元素都右移，再将元素插入，即N+1步</li>
</ul>
</li>
<li>删除任意元素都需要将右边的元素左移，以保持数组的连续性和完整性</li>
<li>最复杂的删除是删除开头元素，删除为1步，之后将N-1个元素左移，最终为N步</li>
<li>集合是一种不允许元素重复的数据结构<ul>
<li>读取，查找，删除和数组的效率是一致的</li>
<li>插入的效率和数组不同<ul>
<li>需要先确定这个元素在不在集合内，因此需要先查找一遍，如前文所诉，最多需要N步</li>
<li>确定要插入的元素不在集合内后，进行插入，和数组一样，最多需要N+1步</li>
<li>因此集合的插入最终的复杂度为2N+1步<span id="more"></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-算法为何重要"><a href="#第二章-算法为何重要" class="headerlink" title="第二章 算法为何重要"></a>第二章 算法为何重要</h2><ul>
<li>和数组的区别就在于里面的元素是按照规则排序的。读取和删除跟数组效率一样。</li>
<li>插入元素<ul>
<li>首先需要根据排序规则，从索引0的位置开始遍历，找到这个元素在有序数组中的位置，最多N步</li>
<li>将该位置的元素右移，然后插入，这是2步，因此最多N+2步。</li>
</ul>
</li>
<li>查找元素<ul>
<li>有序数组的查找比数组的查找效率更高，因为排列有序，所以如果某个元素比查找元素要大，那就可以停止查找。</li>
</ul>
</li>
<li>二分查找的前提是有序数组</li>
<li>数组长度每次翻倍，二分查找的操作步数只会+1。而线性查找却会跟着一起翻倍。</li>
</ul>
<h2 id="第三章-大O记法"><a href="#第三章-大O记法" class="headerlink" title="第三章 大O记法"></a>第三章 大O记法</h2><ul>
<li>无论数组多大，操作都只要一步，记为O(1)</li>
<li>数组长度为N，操作需要用N步，记为O(N)</li>
<li>当数据增长时，步数如何变化？<ul>
<li>O(N) 被称为线性时间，随着数组长度增长，步数每次+1</li>
<li>O(1) 被称为常数时间，表示随着数组长度增长，步数不变</li>
</ul>
</li>
<li>线性查找的最好情况是O(1)，最坏情况是O(N)。</li>
<li>二分查找的复杂度记为O(log N)</li>
</ul>
<h2 id="第四章-利用大O给代码提速"><a href="#第四章-利用大O给代码提速" class="headerlink" title="第四章 利用大O给代码提速"></a>第四章 利用大O给代码提速</h2><ul>
<li><p>冒泡排序</p>
<ul>
<li>基本步骤<ul>
<li>指针首先指向头两个元素，比较大小，如果左边大于右边，则交换位置</li>
<li>将指针右移一位，重复第一步</li>
<li>到列表末尾，重新到列表头部重复第一二步</li>
<li>直到顺序正确，退出循环</li>
</ul>
</li>
<li>按照最复杂的情况看，也就是完全倒序的列表进行冒泡排序的话，复杂度为O(N^2)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二次问题</p>
<ul>
<li>解决一个数组中是否存在重复元素的问题</li>
<li>时间复杂度为O(N^2)的解决办法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasDuplicateValue</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vari=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(varj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!==j&amp;&amp;array[i]==array[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度为O(N)的解决办法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasDuplicateValue</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> existingNumbers=[];</span><br><span class="line">    <span class="keyword">for</span>(vari=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 将元素成员作为下标</span></span><br><span class="line">        <span class="keyword">if</span>(existingNumbers[array[i]]===<span class="literal">undefined</span>)&#123;</span><br><span class="line">            existingNumbers[array[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第五章-用或不用大O来优化代码"><a href="#第五章-用或不用大O来优化代码" class="headerlink" title="第五章 用或不用大O来优化代码"></a>第五章 用或不用大O来优化代码</h2><ul>
<li>选择排序<ul>
<li>基本步骤<ul>
<li>从索引0开始，遍历数组，找到最小的数，将其和索引0的数字调换位置</li>
<li>第二次循环从索引1开始，找到最小数，和索引1的数字调换位置</li>
<li>如此循环，到最后一个数时就完成了排序</li>
</ul>
</li>
<li>和冒泡排序一样，时间复杂度都表示为O(N^2)，但是实际效率比冒泡排序快一倍，也就是虽然更高效，但是没有指数上的差别</li>
<li><strong>从这个角度说，性能调优不应该盲目只看大O记法所表示的复杂度，如果不能有数量级的差别，也应该具体分析后进行同一数量级的调优</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                minIndex = j; <span class="comment">// 获取最小的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[minIndex];</span><br><span class="line">        nums[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第六章-乐观地调优"><a href="#第六章-乐观地调优" class="headerlink" title="第六章 乐观地调优"></a>第六章 乐观地调优</h2><ul>
<li>假设排序数组并不是按照最差的情况进行排序，则总是会有更好更高效的方式进行排序</li>
<li>插入排序<ul>
<li>基本步骤<ul>
<li>从索引1开始，将索引1的数字取出作为一个对比数字，然后从索引0开始，直到索引1结束，比较数字和对比数字的大小</li>
<li>遇到比它大的往右移动一位，遇到比它小的数字，或者索引左边的所有数字都右移了就停止这次循环</li>
<li>从索引2开始，重复1，2步骤    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(array)):</span><br><span class="line">        position = index</span><br><span class="line">        temp_value = array[index]</span><br><span class="line">        <span class="keyword">while</span> position &gt; <span class="number">0</span> <span class="keyword">and</span> array[position-<span class="number">1</span>] &gt; temp_value:</span><br><span class="line">            array[position] = array[position-<span class="number">1</span>]</span><br><span class="line">            position = position - <span class="number">1</span> </span><br><span class="line">        array[position] = temp_value</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>实际时间复杂度为O(N^2 + 2N - 2)，忽略常数和只看最高次的N，则还是O(N^2)</li>
<li><strong>看似时间复杂度一样，但是在平均情况下，插入排序的效率是更高的</strong></li>
</ul>
<h2 id="第七章-查找迅速的散列表"><a href="#第七章-查找迅速的散列表" class="headerlink" title="第七章 查找迅速的散列表"></a>第七章 查找迅速的散列表</h2><ul>
<li>散列表即map，或称字典，映射，关联数组</li>
<li>查找效率为O(1)</li>
<li>简单原理：暂且把散列中的键值对应关系视为乘法关系，如BAD值，转为字母表中的214，对应键为8</li>
<li>散列值计算过程（简化）<ul>
<li>散列表可以看成是一行能够存储数据的格子，就像数组那样。每个格子都有对应的编号</li>
<li>函数对键进行计算，如BAD=2<em>1</em>4=8</li>
<li>将BAD存到第8个格子上</li>
<li>当需要查找BAD对应的值时，计算机计算键BAD的散列值=8，因此直接找到第8个位置的值，复杂度为O(1)</li>
</ul>
</li>
<li>冲突解决<ul>
<li>如上所诉的过程，如果又要存储DAB的值，算出来的散列值也是8，也要存到同一个位置上</li>
<li>将8的位置换成一个数组，即8这个位置可以存储多个键值对</li>
<li>DAB的查找过程就变成，先计算散列值为8，然后找到8这个位置的数组，再用线性查找遍历数组，找到DAB</li>
<li>为了减少冲突，散列表的设计需要减少这种冲突，因此实际设计中散列值的计算要复杂很多</li>
</ul>
</li>
<li>散列表的效率决定因素<ul>
<li>要存多少数据</li>
<li>有多少可用的格子</li>
<li>用什么样的散列函数</li>
<li>要避免冲突，就要增加存储空间，需要找到平衡</li>
</ul>
</li>
</ul>
<h2 id="第八章-用栈和队列来构造灵巧的代码"><a href="#第八章-用栈和队列来构造灵巧的代码" class="headerlink" title="第八章 用栈和队列来构造灵巧的代码"></a>第八章 用栈和队列来构造灵巧的代码</h2><ul>
<li>栈 LIFO（lastin，firstout）后进先出。<ul>
<li>只在末尾插入数据</li>
<li>只能读取末尾数据</li>
<li>只能一处末尾数据</li>
<li><strong>栈的末尾叫栈顶，栈的开头成为栈尾</strong></li>
<li>往栈里插入数据，称为<strong>压栈</strong></li>
<li>从栈顶移出数据，称为<strong>出栈</strong></li>
<li>一般来说，栈都是用来实现某些特殊算法（当数据的处理顺序要与接收顺序相反时），而不会用于存储数据</li>
</ul>
</li>
<li>队列 先进先出<ul>
<li>只能在末尾插入数据（这跟栈一样）</li>
<li>只能读取开头的数据（这跟栈相反）</li>
<li>只能移除开头的数据（这也跟栈相反）</li>
<li>可用于处理网络数据接收处理等任务</li>
</ul>
</li>
</ul>
<h2 id="第九章-递归"><a href="#第九章-递归" class="headerlink" title="第九章 递归"></a>第九章 递归</h2><ul>
<li>递归必需设置基准情形，即结束递归的条件</li>
<li>计算机是用栈来记录每个调用中的函数。这个栈就叫作调用栈，也就是在递归场景中，按照321顺序调用，123顺序完成</li>
<li>递归十分适用于那些无法预估计算深度的问题</li>
</ul>
<h2 id="第十章-飞快的递归算法"><a href="#第十章-飞快的递归算法" class="headerlink" title="第十章 飞快的递归算法"></a>第十章 飞快的递归算法</h2><ul>
<li>快速排序<ul>
<li>基本步骤<ul>
<li>首先找一个基准数，比如找最右边的数</li>
<li>两个指针分别指向数组开头和结尾（排除基准数之外）</li>
<li>两个指针每次都向中间各移动一步，左指针遇到大于等于基准数的数值时就停止移动，右指针遇到小于等于基准数的数值时停止移动</li>
<li>两指针所在数值的位置互换</li>
<li>重复2-4步骤，直到两个指针重合</li>
<li>将基准数与左指针指向的数值互换</li>
</ul>
</li>
<li>以上步骤是以基准数为中心，将数组分为比基准数大的分区和比基准数小的分区，并没有完成最终排序</li>
<li><strong>结合递归，在每个分区内再分别进行快速排序，最终就可以完成排序</strong></li>
<li><strong>可以近似看作长度为N的数组，要进行N个分区的二分查找，二分查找的效率为logN，所以快速排序的效率近似为O(NlogN)</strong></li>
<li>大部分情况下都是表现最好的排序方式，因此多数语言内置排序都以快速排序实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    temp = a[left]; <span class="comment">// temp中存的就是基准数</span></span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="comment">// 顺序很重要，要先从右边开始找</span></span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="comment">// 再找左边的</span></span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="comment">// 交换两个数在数组中的位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终将基准数归位</span></span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line"></span><br><span class="line">    quickSort(a, left, i - <span class="number">1</span>);<span class="comment">// 继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">    quickSort(a, i + <span class="number">1</span>, right);<span class="comment">// 继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>快速选择<ul>
<li>用于查找无序数组中指定大小的数字，比如长度为10的数组中查找第二小的数字</li>
<li>结合快速排序和二分法，先用快速排序对数组进行分区，每次分完区之后，基准数落下的位置就是这个数组中第几大的数字</li>
<li>根据这个方法，快速选择可以用O(N)的复杂度获取到需要的数字</li>
</ul>
</li>
</ul>
<h2 id="第十一章-基于结点的数据结构"><a href="#第十一章-基于结点的数据结构" class="headerlink" title="第十一章 基于结点的数据结构"></a>第十一章 基于结点的数据结构</h2><ul>
<li>链表<ul>
<li>和数组不同的是，链表中的各个元素不是连续的，这种不相邻的格子叫做<strong>结点</strong></li>
<li>每个结点存储数据以及下一个结点的地址来实现链表，这些存储下个结点地址的额外数据就是<strong>链</strong></li>
<li>链表的好处是不需要内存分配连续的空间</li>
<li>读取<ul>
<li>不像连续数组，计算机不知道某个结点的地址，只知道开头结点的地址，因此需要遍历</li>
<li>读取的复杂度为O(N)</li>
</ul>
</li>
<li>查找：读取一样，需要从链表开头进行逐一遍历，复杂度为O(N)</li>
<li>插入<ul>
<li>链表的插入需要先找到插入的位置，如前所述，这个过程的时间复杂度为O(N)</li>
<li>随后将插入位置的上一个结点指向的地址改为当前结点的地址，复杂度为O(1)</li>
<li>和有序列表相反的是，在表头插入数据步骤是最少的，在最后一位插入步骤是最多的</li>
</ul>
</li>
<li>删除：大致上和插入的原理差不多，时间复杂度同样为O(N)</li>
</ul>
</li>
<li><strong>为什么用链表</strong><ul>
<li>从上述分析看，链表增删改查的效率并没有比数组快</li>
<li>但在某些业务场景下，比如从一堆数组中删除指定条件的无效数据<ul>
<li>数组的操作过程是，每次找到一条无效数据后，先进行删除，然后将右边的数据进行左移，如果在最坏的情况下，无效数据都在数组开头，那每次删除都相当于要移动一遍整个数组</li>
<li>链表的操作过程，省略了每次删除后左移的过程，只需遍历一次数组即可</li>
<li>增加数据也是同理</li>
</ul>
</li>
<li>因此，相比数组，链表的增删效率更高</li>
</ul>
</li>
<li>双向链表<ul>
<li>即每个结点除了存储下个结点的地址，还会存储上一个结点的地址</li>
<li>增删改查可以从头部或者尾部开始</li>
<li>这种特性可以使双向链表作为队列的底层实现，这样增删复杂度都是O(1)</li>
</ul>
</li>
</ul>
<h2 id="第十二章-二叉树"><a href="#第十二章-二叉树" class="headerlink" title="第十二章 二叉树"></a>第十二章 二叉树</h2><ul>
<li>前文提到，有序列表的查找(二分法 O(logN))和读取 (O(1))非常快，但是插入和删除效率较低(O(N))；而散列表的查找，插入和删除效率较高(O(1))，但却是无序的<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree.png"></li>
<li>二叉树<ul>
<li>每个结点链接着另外两个结点</li>
<li>最上面的那一结点（此例中的“j”）被称为<strong>根</strong></li>
<li>此例中，“j”是“m”和“b”的<strong>父结点</strong>，反过来，“m”和“b”是“j”的<strong>子结点</strong>。“m”又是“q”和“z”的父结点，“q”和“z”是“m”的子结点</li>
<li>树可以分<strong>层</strong>。此例中的树有3层</li>
<li>每个结点的子结点数量可为0、1、2</li>
<li>如果有两个子结点，<strong>则其中一个子结点的值必须小于父结点，另一个子结点的值必须大于父结点</strong></li>
</ul>
</li>
<li>二叉树查找的原理类似于二分法，因此复杂度为O(logN)</li>
<li>插入同样也是O(logN)，因为找到需要插入的结点即可，无需像有序数组那样移动</li>
<li><strong>需要乱序生成的二叉树才能高效，原理看图可知</strong><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree2.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree3.png"></li>
<li>二叉树的删除<ul>
<li>规则较多，如果是删除最底下的子结点复杂度为O(logN)，但是如果删除某个父结点，需要考虑</li>
<li>如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上</li>
<li>如果要删除的结点有两个子结点，则从其子结点中选取后继结点。后继结点的选取规则是，所有比被删除结点大的子结点中，最小的那个。下图例子中就是将61作为替换<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree4.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree5.png"></li>
<li>查找后继结点的方法：跳到被删除结点的右子结点，然后一路只往左子结点上跳，直到没有左子结点为止，则所停留的结点就是被删除节点的后继结<ul>
<li>如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree6.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree7.png"><br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/tree8.png"></li>
</ul>
</li>
<li>尽管看起来规则复杂，然而这些额外步骤都是寥寥几步就可以完成，删除的主要过程依然是查找结点的过程，所以复杂度还是O(logN)</li>
</ul>
</li>
</ul>
<h2 id="第十三章-连接万物的图"><a href="#第十三章-连接万物的图" class="headerlink" title="第十三章 连接万物的图"></a>第十三章 连接万物的图</h2><p><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/graph.png"></p>
<ul>
<li>每个结点都是一个<strong>顶点</strong>，每条线段都是一条<strong>边</strong>。当两个顶点通过一条边联系在一起时，我们会说这两个顶点是相邻的。</li>
<li>以Facebook和twitter为例，facebook是双向的关系，而twitter是单向的<br><img src="/2022/03/21/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/graph2.png"></li>
<li>可用散列表来实现图</li>
<li>广度优先搜索<ul>
<li>需要用队列记录后续要处理哪些顶点</li>
<li>找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。）</li>
<li>如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。</li>
<li>如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，那么算法完成。</li>
<li>简单点说就是每次只处理下一层的数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-人类简史</title>
    <url>/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/humanhistory.jpg"></p>
<h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><h3 id="人类：一种没什么特别的动物"><a href="#人类：一种没什么特别的动物" class="headerlink" title="人类：一种没什么特别的动物"></a>人类：一种没什么特别的动物</h3><ul>
<li>在历史的路上，有三大重要革命：<ul>
<li>大约7万年前，“认知革命”（CognitiveRevolution）让历史正式启动</li>
<li>大约12000年前，“农业革命”（AgriculturalRevolution）让历史加速发展</li>
<li>而到了大约不过是500年前，“科学革命”（ScientificRevolution）可以说是让历史画下句点而另创新局</li>
</ul>
</li>
<li>从同一个祖先演化而来的不同物种，会属于同一个“属”（genus）<ul>
<li>生物学家用拉丁文为生物命名，每个名字由两个词组成，第一个词是属名，第二个词则是种名</li>
<li>例如狮子就称为“Pantheraleo”，指的是豹属（Panthera）的狮种（leo）</li>
</ul>
</li>
<li>许多属还能再归类为同一科（family）</li>
<li>最早的人类是从大约250万年前的东非开始演化，祖先是一种更早的猿属“Australopithecus”（南方古猿）<ul>
<li>在欧洲和西亚的人类成了“Homoneanderthalensis”，意为“来自尼安德谷（NeanderValley）的人”，一般简称为“尼安德特人”（Neanderthals）</li>
<li>在东方的亚洲，住的则是“Homoerectus”（直立人），一共存续了将近200万年，是目前所知存续最久的人类物种</li>
<li>在印度尼西亚的爪哇岛，则住着“Homosoloensis”（梭罗人，拉丁文意为“来自梭罗谷的人”）</li>
<li>人类的摇篮继续养育着许多新品种，例如“Homorudolfensis”（鲁道夫人，“来自鲁道夫湖的人”）、“Homoergaster”（匠人，“工作的人”）</li>
<li>而我们也颇为厚颜地把自己命名为“Homosapiens”（智人，“明智的人”）</li>
</ul>
</li>
<li>人类不是线性发展的，在某一个时期同时存在多种人中，智人也是其中之一<ul>
<li>大脑容量大<ul>
<li>大脑结构脆弱，不利于活动</li>
<li>能耗很大，只占重量2%，却要消耗25%的能量</li>
<li>令人困惑的是，在接近200万年的时间里，大脑并没有带来显著的优势，却一直偏执的在这条路上进化</li>
</ul>
</li>
<li>直立行走<ul>
<li>手解放出来做更精细的事</li>
<li>促进了神经系统的进化</li>
<li>导致背痛，颈脖部位的酸痛</li>
</ul>
</li>
<li>人类都是早产儿<ul>
<li>促使人类成为强社交生物，因为需要群体帮助照顾幼儿</li>
</ul>
</li>
<li>用火<ul>
<li>一些本无法消化的食物变为主食（如小麦，水稻，马铃薯等）</li>
<li>食物中的病菌和寄生虫被杀死</li>
<li>咀嚼和消化时间大幅缩减</li>
<li>缩小牙齿、减少肠的长度<ul>
<li>一种说法认为，这减少了消化时所需的能量，从而使得大脑得到发育的空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>长久以来，智人一直只是稳定位于食物链的中间位置，直到最近才有改变<ul>
<li>在先前长达数百万年的时间里，人类会猎杀小动物、采集种种能得到的食物，但同时也会遭到较大型肉食动物猎杀</li>
<li>一直要到40万年前，有几种人种才开始固定追捕大型猎物，而要到10万年前智人崛起，人类才一跃而居于食物链顶端</li>
<li>人类转眼就登上顶端，不仅让生态系统猝不及防，就连人类自己也不知所措</li>
</ul>
</li>
<li>智人如何成为唯一存活的人种<ul>
<li>混种繁衍理论，即智人是和其他人种互通繁衍，从而融合为同一人种</li>
<li>替代理论，即除了智人之外的其他人种灭绝了<ul>
<li>这种理论更加政治正确，毕竟世界上的人都有同样的祖先比较不会引起种族方面的讨论</li>
<li>然而目前，已经找到证据证明各个地区的人身上携带者不同远古人种的DNA</li>
</ul>
</li>
<li><strong>智人胜出的根本原因很可能是因为有独特的语言</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="知善恶树"><a href="#知善恶树" class="headerlink" title="知善恶树"></a>知善恶树</h3><ul>
<li>大约就是在距今7万到3万年前，出现了新的思维和沟通方式，这也正是所谓的<strong>认知革命</strong><ul>
<li>智人的语言并不是世界上的第一种语言。每种动物都有着某种语言。</li>
<li>最常见的理论，认为人类语言最为灵活</li>
<li>第二种理论，也同意人类语言是沟通关于世界的信息的方式。然而，最重要的信息不是关于狮子和野牛，而是关于人类自己。<strong>我们的语言发展成了一种八卦的工具</strong></li>
<li>只有智人能够表达关于从来没有看过、碰过、耳闻过的事物，而且讲得煞有其事。<strong>讨论虚构的事物”正是智人语言最独特的功能</strong></li>
</ul>
</li>
<li>社会学研究指出，借由八卦来维持的最大“自然”团体大约是150人<ul>
<li>在这个规模下，只需要靠人际关系就可以维持正常运作，而不需要什么特定的纪律约束</li>
<li>超过这个规模，就需要依靠虚构的故事。例如宗教，国家历史，法律故事等</li>
</ul>
</li>
<li><strong>所谓“想象的现实”指的是某件事人人都相信，而且只要这项共同的信念仍然存在，力量就足以影响世界</strong></li>
<li>自从认知革命之后，智人就能依据不断变化的需求迅速调整行为。这等于开启了一条采用“<strong>文化演化</strong>”的快速道路，而不再停留在“基因演化”这条总是堵车的道路上<ul>
<li>在认知革命之后，虽然智人的基因和环境都没什么改变，但智人还是能够迅速改变行为，并将新的行为方式传给下一代</li>
<li>最典型的例子，就是人类社会总会出现不生育的精英阶层</li>
<li>过去远古人类的行为模式可能维持几万年不变，但对现代智人来说，只要十几二十年，就可能改变整个社会结构、人际交往关系和经济活动<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/human1.png">   </li>
</ul>
</li>
</ul>
<h3 id="亚当和夏娃的一天"><a href="#亚当和夏娃的一天" class="headerlink" title="亚当和夏娃的一天"></a>亚当和夏娃的一天</h3><ul>
<li>演化心理学<ul>
<li>这个领域的学者认为，即使到了现在，我们的大脑和心灵都还是以狩猎和采集的生活方式在思维</li>
<li>比如爱吃甜食和高热量食物来自于祖先一辈缺乏这种摄入，因此看到这些食物就得大量摄入以免失去机会</li>
<li>一夫一妻制和”远古公社”都存在于人类社会</li>
</ul>
</li>
<li>远古的采集生活与后来的农业和工业生活相比，最明显的区别在于极少使用人造物品<ul>
<li>无法光靠现存的文物来了解远古狩猎采集生活</li>
<li>即使是在类似的生态、同样的基因组成下出现的人类，也能够创造出非常不同的想象现实，表现出来就成了不同的规范和价值观</li>
<li>从认知革命之后，智人的“自然生活方式”从来就不止一种。真正存在的只有“<strong>文化选择</strong>”</li>
</ul>
</li>
<li>在个人层面上，远古的采集者则是有史以来最具备多样知识和技能的人类<ul>
<li>等到农业和工业时代开展，人类开始能靠着别人的技能生存下来，就算是低能的人也开始有了生存空间</li>
<li>采集经济，能让大多数人都过着比在农业或工业社会中更有趣的生活</li>
<li>采集者之所以能够免受饥饿或营养不良的困扰，秘诀就在于多样化的饮食。相较之下，之后农民的饮食往往种类极少，而且不均衡。</li>
<li>远古采集者也比较少碰到传染病的问题</li>
</ul>
</li>
<li>多数学者都同意，远古的采集者普遍信奉泛神论的信仰（animism，源自拉丁文的“anima”，意义“灵魂”或“精神”）<ul>
<li>泛神论相信，几乎任何一个地点、任何一只动物、任何一株植物、任何一种自然现象，都有其意识和情感，并且能与人类直接沟通</li>
<li>泛神论者认为，人类和其他的灵之间并没有障碍，可以直接通过言语、歌曲、舞蹈和仪式来沟通</li>
</ul>
</li>
<li>我们已经看到，采集社会可能有许多不同的宗教和社会结构，可以预测他们也同样有不同的暴力倾向。可能在某些时期，某些地区一片平静祥和，但在其他地区却是动乱不断。</li>
<li>整个动物界从古至今，最重要也最具破坏性的力量，就是这群四处游荡、讲着故事的智人</li>
</ul>
<h3 id="毁天灭地的人类洪水"><a href="#毁天灭地的人类洪水" class="headerlink" title="毁天灭地的人类洪水"></a>毁天灭地的人类洪水</h3><ul>
<li>在历史上，人类首次抵达澳大利亚绝对算是大事一件，重要性不亚于哥伦布抵达美洲或是阿波罗11号登上月球</li>
<li>智人灭绝澳大利亚大型动物的证据<ul>
<li>大多数动物在智人来之前都活过了多次冰河期，但却基本都在智人登陆后灭绝</li>
<li>同样是在澳大利亚，在那里的海洋生物却没有什么灭绝的变化</li>
<li>这种灭绝现象，出现的时间点基本都是智人登陆的时间点</li>
</ul>
</li>
<li>智人如何造成澳大利亚的生物灭绝<ul>
<li>大型动物的繁衍周期较长，即使智人只是几个月捕杀一只，也会超过大型动物的生殖速度，使得在几千年时间内缓慢灭绝</li>
<li>火耕技术改变了地貌，彻底改变生态</li>
<li>气候变迁加上人类狩猎</li>
</ul>
</li>
<li>智人的第一波殖民正是整个动物界最大也最快速的一场生态浩劫<ul>
<li>在认知革命发生的时候，地球上大约有200属体重超过50公斤的大型陆生哺乳动物</li>
<li>等到农业革命的时候，只剩下大约100属</li>
<li>远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝</li>
</ul>
</li>
</ul>
<h2 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h2>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记-算法</title>
    <url>/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm.jpg"></p>
<p><strong>配套网站：<a href="https://algs4.cs.princeton.edu/home/">https://algs4.cs.princeton.edu/home/</a></strong></p>
<h2 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h2><ul>
<li>无论在任何应用领域，精心设计的算法都是解决大型问题最有效的方法</li>
<li>我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为<strong>基础编程模型</strong></li>
<li>java程序的基本语法，同时也是多数程序语言的通用语法<ul>
<li>原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。<ul>
<li>int    32位整数(2^31=2147483648)<ul>
<li>在java中int可表示的范围为（-2147483648——2147483647），2147483648会溢出变为-2147483648，因此Math.abs(-2147483648)=-214783648</li>
</ul>
</li>
<li>double 64位双精度实数</li>
<li>布尔型  true or false</li>
<li>string 字符串</li>
<li>long   64位整数</li>
<li>short  16位整数(2^15=32768)</li>
<li>char   16位字符</li>
<li>byte   8位整数(2^7=128)</li>
<li>float  32位单精度实数</li>
</ul>
</li>
<li>语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：<strong>声明、赋值、条件、循环、调用和返回</strong><ul>
<li>java是一种强类型语言，编译器会检查类型一致性</li>
</ul>
</li>
<li>数组：数组是多个同种数据类型的值的集合</li>
<li>静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序</li>
<li>字符串：字符串是一连串的字符，Java内置了对它们的一些操作</li>
<li>标准输入/输出：标准输入输出是程序与外界联系的桥梁</li>
<li>数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程</li>
</ul>
</li>
<li>不同程序语言的运算符计算优先级会有不同，因此通常情况下用括号来进行优先级的改变</li>
<li>方法的性质<ul>
<li>方法的参数按值传递<ul>
<li>调用方法时传递对象名也是值传递，意味着传递的是对象的别名，也就是对象的引用地址，所以在方法内修改其内容也会影响原始值</li>
</ul>
</li>
<li>方法名可以重载</li>
<li>方法只能返回一个值，但是可以包含多个返回语句</li>
<li>方法可以产生副作用：在本书中，返回值是void的方法就是副作用</li>
</ul>
</li>
<li><strong>递归原则</strong><ul>
<li>递归总是在第一行就要包含一个包含return的条件语句</li>
<li>递归总是尝试先解决一个更小的问题</li>
<li>递归的父问题和子问题之间不应该有交集</li>
</ul>
</li>
<li><strong>API的目的是将调用和实现分离</strong></li>
<li>重定向和管道输入<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/redirect.png"></li>
<li>Java表达式1/0和1.0/0.0的值是什么<ul>
<li>第一个表达式会产生一个运行时除以零异常（它会终止程序，因为这个值是未定义的）；第二个表达式的值是Infinity（无穷大）。</li>
</ul>
</li>
<li>为什么数组的起始索引是0而不是1<ul>
<li>这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将起始索引设为1要么会浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减1</li>
</ul>
</li>
<li>每次使用new来创建一个对象时，系统都会<ul>
<li>为新的对象分配内存空间</li>
<li>调用构造函数初始化对象中的值</li>
<li>返回该对象的一个引用 </li>
</ul>
</li>
<li>为什么要区别原始数据类型和引用类型？为什么不只用引用类型<ul>
<li>因为性能。Java提供了Integer、Double等和原始数据类型对应的引用类型，以供希望忽略这些类型的区别的程序员使用。原始数据类型更接近计算机硬件所支持的数据类型，因此使用它们的程序比使用引用类型的程序运行得更快</li>
</ul>
</li>
<li>指针是什么？<ul>
<li>和Java的引用一样，可以把指针看做机器地址。在许多编程语言中，指针是一种原始数据类型，程序员可以用各种方法操作它。</li>
<li>但众所周知，指针的编程非常容易出错，因此需要精心设计指针类的操作以帮助程序员避免错误。Java将这种观点发挥到了极致（许多主流编程语言的设计者也赞同这种做法）。</li>
<li>在Java中，创建引用的方法只有一种（new），且改变引用的方法也只有一种（赋值语句）。也就是说，程序员能对引用进行的操作只有创建和复制。</li>
<li>在编程语言的行话里，Java的引用被称为安全指针，因为Java能够保证每个引用都会指向某种类型的对象（而且它能找出无用的对象并将其回收）。</li>
</ul>
</li>
<li>栈用于带括号的运算符计算<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/dijkstra.png" alt="dijkstra双栈算术表达式求值"></li>
<li><strong>Java标准库中有栈和队列吗</strong><ul>
<li>Java有一个内置的库，叫做java.util.Stack，但你需要栈的时候请不要使用它。</li>
<li>它新增了几个一般不属于栈的方法，例如获取第i个元素。它还允许从栈底添加元素（而非栈顶），所以它可以被当做队列使用</li>
<li>java.util.Stack的API是<strong>宽接口</strong>的一个典型例子</li>
</ul>
</li>
<li><strong>算法分析</strong><ul>
<li>一个程序运行的总时间主要和两点有关<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>
</li>
<li>常见的增长数量级函数<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm1.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm2.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm3.png"></li>
<li>从增长率来看，效率排行是<strong>常数&gt;logN&gt;N&gt;N^2&gt;2^N&gt;N^3</strong></li>
</ul>
</li>
<li>解决3-sum问题<ul>
<li>即在给定的数组中找到和为0的三个数</li>
<li>解决2-sum问题<ul>
<li>使用归并排序对数组进行排序，复杂度为NlogN</li>
<li>遍历数组，第一个数找到后使用二分查找在排序后的数组中获取相反数，时间复杂度为NlogN</li>
<li>因此整个2-sum问题的时间复杂度为logN</li>
</ul>
</li>
<li>将解决2-sum问题的方法推广<ul>
<li>使用归并排序对数组进行排序，复杂度为NlogN</li>
<li>遍历数组，但是这时，需要遍历两遍，相当于先把两个数相加后再用二分法去找数组中的相反数，因此时间复杂度为(N^2)*logN</li>
<li>这样3-sum的问题的时间复杂度为(N^2)*logN</li>
</ul>
</li>
<li>可以看到，针对这样的问题，先排序一遍所需的成本在总成本中几乎可以忽略不计，而排序后可以使用二分法则可以将整个时间复杂度降一个量级<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/algrithm4.png"></li>
</ul>
</li>
<li>考虑数量级的注意事项<ul>
<li>大常数，考虑数量级一般情况下不需要去考虑常数，如2N^2 + cN，通常情况下是看成N^2，然而如果某些情况下，c的值非常大，大到在具体业务场景中无法忽略的话，还是需要将常数考虑进去</li>
<li>非决定性的内循环<ul>
<li>内循环是决定性因素的假设并不总是正确的</li>
<li>有些程序在内循环之外也有大量指令需要考虑</li>
</ul>
</li>
<li>指令时间<ul>
<li>每条指令执行所需的时间总是相同的假设并不总是正确的</li>
<li>例如，大多数现代计算机系统都会使用缓存技术来组织内存</li>
</ul>
</li>
<li>系统因素<ul>
<li>Java只是争夺资源的众多应用程序之一，而且Java本身也有许多能够大大影响程序性能的选项和设置</li>
<li>某种垃圾收集器或是JIT编译器或是正在从因特网中进行的下载都可能极大地影响实验的结果</li>
</ul>
</li>
<li><strong>对输入的依赖</strong><ul>
<li>某些特殊值导致的运行时间的陡然差异不应该考虑进我们对于程序整体运行时间的评估</li>
<li>考虑最坏情况下对于性能的保证</li>
<li>引入随机化算法<ul>
<li>需要模拟随机数的输入</li>
</ul>
</li>
<li>考虑操作序列<ul>
<li>即某些情况下，进行ABC操作和进行CBA操作的顺序可能也会对性能造成影响</li>
</ul>
</li>
<li>均摊分析<ul>
<li>提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>速度太慢的程序和错误的程序一样无用</strong></li>
<li><strong>union-find算法</strong><ul>
<li>问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数pq可以被理解为“p和q是相连的”</li>
<li>规则<ul>
<li>自反性：p和p是相连的</li>
<li>对称性：如果p和q是相连的，那么q和p也是相连的</li>
<li>传递性：如果p和q是相连的且q和r是相连的，那么p和r也是相连的</li>
</ul>
</li>
<li>动态连通性问题<ul>
<li>当程序从输入中读取了整数对pq时，如果已知的所有整数对都不能说明p和q是相连的，那么则将这一对整数写入到输出中</li>
<li>如果已知的数据可以说明p和q是相连的，那么程序应该忽略pq这对整数并继续处理输入中的下一对整数</li>
<li>比如没有连通数据时，输入1，3，将其连通，输出1-3；接下来再输入3，5，将其连通，输出3-5；这样在输出记录中，存在1-3-5的连通记录；此时，输入1，5，根据连通规则，1和5是连通的，所以忽略这对数据<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/unionfind.png"></li>
</ul>
</li>
<li>用处<ul>
<li>这个程序能够判定我们是否需要在p和q之间架设一条新的连接才能进行通信，或是我们可以通过已有的连接在两者之间建立通信线路</li>
<li>这些整数表示的可能是社交网络中的人，而整数对表示的是朋友关系</li>
</ul>
</li>
<li>术语<ul>
<li>将对象称为<strong>触点</strong>，将整数对称为<strong>连接</strong>，将等价类称为<strong>连通分量</strong>或是简称<strong>分量</strong></li>
</ul>
</li>
<li>实现方法<ul>
<li>用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量</li>
<li>定义四个基本API<br>  <img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/unionfind2.png">   </li>
<li>quick-find算法<ul>
<li>connected(p,q)只需要判断id[p]==id[q]</li>
<li>我们需要遍历整个数组，将所有和id[p]相等的元素的值变为id[q]的值。我们也可以将所有和id[q]相等的元素的值变为id[p]的值——两者皆可<ul>
<li>举例来说，1-3本来相连，则数组id[]中id[1]和id[3]的值相等，比如都等于1</li>
<li>这时需要连接另一对触点，比如5-6，数组id[]中id[5]和id[6]的值相等，比如都等于5</li>
<li>现在需要将3和5连接，此时遍历数组，找到与id[3]和id[5]的值相同的索引，即1和6，此时将索引1,3,5,6的值都改为1或者都改为5<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind2.png"><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickyfind3.png"></li>
</ul>
</li>
<li>union方法包含三步，一步是find，找到各自对应的值，复杂度为O(1)，第二步是遍历数组，复杂度为O(N)，第三步是修改数组中的值，根据连通量的不同，可能需要1——N-1步</li>
<li>最差的情况下，只得到一个连通分量，如1-5的数组，最终连通分路只有一条1-2-3-4-5，其复杂度接近O(N^2)<ul>
<li>两个数组连通每次都需要N+3步，即两次find为2步，遍历数组N步，改变值1步，2+N+1=N+3步</li>
<li>只有一个通路的情况下，数组中依次比较需要N-1步，如1-5的数组，步骤为1-2,2-3,3-4,4-5。</li>
<li>所以最终步骤为(N+3)*(N-1)，时间复杂度记为O(N^2)</li>
<li>这个时间复杂度在数据量达到上亿的情况下显然效率过低，不予考虑</li>
</ul>
</li>
</ul>
</li>
<li>quick-union算法<ul>
<li>每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称，称为<strong>链接</strong><br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion.png">  </li>
<li>在数组被初始化之后，每个节点的链接都指向它自己</li>
<li>每次union之后节点都会指向某个父节点，id[i]的值除非是根节点，否则不会等于自身，因此代码中的find会一直追溯到父结点<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion2.png"></li>
<li>与quick-find相比，最明显的改变就是每次union的操作无需遍历数组，只需将子节点指向父节点即可，这个过程只需一步<ul>
<li>相比之下，就要付出额外的成本去追溯父节点，这个过程最快1步，最慢需要N-1步</li>
</ul>
</li>
<li>在最坏的情况下，所有的节点的链接都指向前一个节点，那么每次find都需要遍历之前的每个节点，总的find的步骤就是3+5+6+……+(2N-1)～N^2<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/quickunion3.png">       </li>
<li>在一般情况下都会比quick-find更快，但是无法保证出现最坏情况下仍然是O(N^2)的时间复杂度</li>
</ul>
</li>
<li>加权quick-union算法<ul>
<li>记录每一棵树的大小并总是将较小的树连接到较大的树上</li>
<li>需要添加一个数组和一些代码来记录树中的节点数<br><img src="/2022/03/24/read/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/weightquickunion.png">        </li>
<li>对于N个触点，加权quickunion算法构造的森林中的任意节点的深度最多为lgN</li>
<li>多出来记录节点数量的数组并不会增加多少复杂度，只会在每次union中多出两步操作</li>
<li>使得find成本大大降低，随着数量级的提升，时间复杂度只会以lgN的数量级增长</li>
</ul>
</li>
<li>路径压缩的加权quick-union算法<ul>
<li>我们希望每个节点都直接链接到它的根节点上，但我们又不想像quickfind算法那样通过修改大量链接做到这一点</li>
<li>要实现路径压缩，只需要为find()添加一个循环，将在路径上遇到的所有节点都直接链接到根节点</li>
<li>我们所得到的结果是几乎完全扁平化的树，它和quickfind算法理想情况下所得到的树非常接近</li>
<li>是目前的最优解  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
