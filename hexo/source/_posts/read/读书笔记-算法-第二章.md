---
title: 读书笔记-算法-第二章
date: 2022-03-29 09:28:29
comments: true
categories: 
- 读书笔记
---

## 第二章 排序

![](basesort.png)
- 初级排序算法
    - 排序就是将数组的**主键**按照某种方式排序
    - 排序成本模型：我们需要计算**比较**和**交换**的数量。对于不交换元素的算法，我们会计算访问数组的次数
    - java的compareTo方法必须实现一个全序关系：
        - 自反性：对于所有的v，v=v
        - 反对称性：对于所有的v<w都有w>v，且v=w时w=v
        - 传递性：对于所有的v，w和x，如果v<=w且w<=x，则v<=x
- 选择排序
    - 基本步骤
        - 找到数组中最小的那个元素
        - 将它和数组的第一个元素交换位置
        - 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，如此反复
    - 分析效率
        - 对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换
        - 为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息
        - 可以看到，对于长度为N的数组，交换次数固定为N次，是所有数组中，交换步数最少的
        - 简单，但效率颇低  
        ![](selectsort.png) 
- 插入排序
    - 基本步骤
        - 从索引1开始，将索引1的数字取出作为一个对比数字，然后从索引0开始，直到索引1结束，比较数字和对比数字的大小
        - 遇到比它大的往右移动一位，遇到比它小的数字，或者索引左边的所有数字都右移了就停止这次循环
        - 从索引2开始，重复1，2步骤
    - 分析效率
        - 对于随机排列的长度为且主键不重复的数组，平均情况下插入排序需要N^2/4次比较以及N^2/4次交换。最坏情况下需要N^2/2次比较和N^2/2次交换，最好情况下需要N-1次比较和0次交换。
        - 插入排序对于实际应用中常见的某些类型的非随机数组很有效
            - 数组中每个元素距离它的最终位置都不远
            - 一个有序的大数组接一个小数组
            - 数组中只有几个元素的位置不正确
            - 当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快
            ![](insertsort.png)
      
          
