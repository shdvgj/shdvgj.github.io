---
title: RabbitMQ VS Kafka
date: 2023-09-20 20:55:28
tags:
---

翻译自[RabbitMQ vs. Kafka – An Architect’s Dilemma (Part 1)](https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-1)

## 介绍

作为一位处理许多基于微服务的系统的软件架构师，我经常遇到一个不断重复的问题——“我应该使用RabbitMQ还是Kafka？”。出于某种原因，许多开发人员认为这些技术可以互相替代。虽然在某些情况下这是正确的，但这些平台之间存在着各种根本性的差异。因此，在不同的场景下需要不同的解决方案，选择错误的方案可能会严重影响您设计、开发和维护软件解决方案的能力。

本博文的目标首先是介绍基本的异步消息传递模式。然后，它继续介绍RabbitMQ和Kafka以及它们的内部结构。[第二部分](https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-2)重点介绍了这些平台之间的关键差异，它们的各种优势和劣势，以及如何在两者之间进行选择。

<!-- more -->

## 异步消息传递模式

异步消息传递是一种消息传递方案，其中生产者产生的消息与消费者处理消息的过程解耦。在处理消息系统时，我们通常识别出两种主要的消息传递模式——消息队列和发布/订阅。

### 消息队列

在消息队列通信模式中，队列将生产者与消费者进行了时间上的解耦。多个生产者可以向同一个队列发送消息；然而，当消费者处理一条消息时，它会被锁定或从队列中移除，不再可用。只有一个消费者会消费特定的消息。

![](mq1.svg)

值得一提的是，如果消费者无法处理某条消息，消息平台通常会将该消息返回到队列中，以便其他消费者使用。除了时间上的解耦外，队列还允许我们独立扩展生产者和消费者，并提供一定程度的容错能力，以应对处理错误。

### 发布/订阅

在发布/订阅（Pub/Sub）通信模式中，一条消息可以同时被多个订阅者接收和处理。

![](mq2.svg)

这种模式允许发布者通知所有订阅者系统中发生的事件。许多队列平台通常将发布/订阅与"主题"这个术语相关联。在RabbitMQ中，主题是一种特定类型的发布/订阅实现（确切地说，是一种交换机类型），但在本文中，我将主题作为整个发布/订阅模式的一种表示方式。

从一般意义上讲，订阅有两种类型：

- 短暂订阅，只有在消费者运行时才处于活动状态。一旦消费者关闭，它的订阅和尚未处理的消息就会丢失。

- 持久订阅，只要没有明确删除，订阅就会保持有效。当消费者关闭时，消息平台会保持订阅，并且可以稍后恢复消息处理。

### RabbitMQ

[RabbitMQ](https://www.rabbitmq.com/)是消息代理的一种实现，通常也被称为服务总线。它本身原生地支持上述两种消息传递模式。其他流行的消息代理实现包括[ActiveMQ](https://activemq.apache.org/)、[ZeroMQ](https://zeromq.org/)、[Azure Service Bus](https://azure.microsoft.com/en-us/services/service-bus/)和[Amazon Simple Queue Service (SQS)](https://aws.amazon.com/sqs/)。所有这些实现都有很多共同之处；本文中描述的许多概念适用于它们中的大多数。

#### 队列

RabbitMQ原生支持经典的消息队列。开发者可以定义具名队列，然后发布者可以将消息发送到该具名队列。消费者则使用同一队列来获取消息并进行处理。

#### 消息交换机

RabbitMQ通过使用消息交换机来实现发布/订阅（Pub/Sub）模式。发布者将消息发布到消息交换机中，而不知道哪些订阅者会接收这些消息。每个希望订阅交换机的消费者都会创建自己的队列；然后，消息交换机会将产生的消息排队，供消费者消费。它还可以根据各种路由规则为某些订阅者筛选消息。

![](mq3.svg)

需要注意的是，RabbitMQ支持短暂订阅和持久订阅两种类型。消费者可以通过RabbitMQ的API来决定使用哪种订阅类型。

由于RabbitMQ的架构，我们还可以创建一种混合方法，其中一些订阅者形成消费者组，共同处理以竞争消费者方式在特定队列上的消息。通过这种方式，我们既实现了发布/订阅模式，又允许一些订阅者进行扩展以处理接收到的消息。

![](mq4.svg)

### Apache Kafka

[Apache Kafka](https://kafka.apache.org/)并不是消息代理的一种实现，而是一种分布式流处理平台。与基于队列和交换机的RabbitMQ不同，Kafka的存储层是使用分区事务日志来实现的。此外，Kafka还提供了Streams API用于实时处理流数据，以及Connectors API用于与各种数据源进行轻松集成，但这些内容超出了本文的范围。

云供应商提供了Kafka存储层的替代解决方案。这些解决方案包括[Azure Event Hubs](https://azure.microsoft.com/en-us/services/event-hubs/)，以及在某种程度上[AWS Kinesis Data Streams](https://aws.amazon.com/kinesis/data-streams/)。此外，还有云特定和开源的替代方案可以实现Kafka的流处理能力，但同样超出了本文的范围。

#### 主题(Topics)

Kafka并不实现队列的概念，而是将记录集合存储在称为主题的分类中。对于每个主题，Kafka维护了一个分区化的消息日志。每个分区都是一个有序、不可变的记录序列，消息会不断地追加到其中。Kafka在消息到达时将其追加到这些分区中。默认情况下，它使用循环分区器将消息均匀地分布在分区之间。生产者可以修改这种行为以创建逻辑消息流。例如，在多租户应用程序中，我们可能希望根据每条消息的租户ID创建逻辑消息流。在物联网场景中，我们可能希望每个生产者的身份始终映射到特定的分区。确保同一逻辑消息流中的所有消息映射到同一个分区，可以保证它们按顺序传递给消费者。

![](mq5.svg)

消费者通过维护对这些分区的偏移量（或索引）并按顺序读取它们来消费消息。单个消费者可以消费多个主题，并且消费者可以根据可用的分区数量进行扩展。因此，在创建主题时，应仔细考虑对该主题的消息吞吐量预期。一组共同工作以消费主题的消费者称为消费者组。Kafka的API通常处理消费者组中的分区处理的平衡，并存储消费者当前的分区偏移量。

![](mq6.svg)

#### 使用Kafka实现消息模式

Kafka的实现非常适合发布/订阅模式。生产者可以将消息发送到特定的主题，而多个消费者组可以消费相同的消息。每个消费者组可以独立扩展以处理负载。由于消费者维护其分区的偏移量，它们可以选择使用持久订阅，在重新启动时保持其偏移量，或者使用临时订阅，每次启动时都从每个分区的最新记录重新开始。然而，对于消息队列模式来说，它并不完全适合。当然，我们可以使用只有一个消费者组的主题来模拟经典的消息队列。然而，这种方法有多个缺点，这篇文章的第二部分详细讨论了这些缺点。

值得注意的是，Kafka会保留分区中的消息一段预配置的时间，无论消费者是否消费了这些消息。这种保留意味着消费者可以自由地重新读取过去的消息。此外，开发人员还可以利用Kafka的存储层来实现诸如事件溯源（Event Sourcing）和审计日志（Audit Logs）等机制。

## 结语

虽然RabbitMQ和Kafka有时可以互换使用，但它们的实现方法却非常不同。因此，我们不能将它们视为同一类工具的成员；一个是消息代理（message broker），另一个是分布式流处理平台（distributed streaming platform）。作为解决方案架构师，我们应该认识到这些差异，并积极考虑在特定场景下应该使用哪种类型的解决方案。[第二部分](https://eranstiller.com/rabbitmq-vs-kafka-an-architects-dilemma-part-2)将详细介绍这些差异，并提供了在何时使用每种工具的指导。

## 其他文章

如果您想深入了解RabbitMQ和Kafka的内部实现，我推荐以下资源：

[AMQP 0.9.1 Model Explained – RabbitMQ](https://www.rabbitmq.com/tutorials/amqp-concepts.html)
[Introduction to Apache Kafka](https://kafka.apache.org/intro)



