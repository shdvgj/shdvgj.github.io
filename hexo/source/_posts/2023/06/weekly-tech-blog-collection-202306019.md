---
title: 一周文章收集-20230619
date: 2023-06-19 16:28:13
comments: true
categories: 
- 一周文章收集
---

## [OpenLLM：开源的大语言模型](https://github.com/bentoml/OpenLLM)
通过OpenLLM，可以使用任何开源的大型语言模型进行推断，将其部署到云端或本地，以及构建强大的人工智能应用程序。
需要服务器安装python3.8或以上以及pip。

#### 安装命令
```sh
pip install openllm
```
#### 验证是否安装正确
```sh
$ openllm -h
```

#### 启动LLM服务器
```sh
openllm start dolly-v2
```

以上命令会在 http://localhost:3000 发布一个前端页面。

#### 命令行中使用
```sh
export OPENLLM_ENDPOINT=http://localhost:3000
openllm query 'Explain to me the difference between "further" and "farther"'
```
<!-- more -->
其中，语言模型是可以换的，包含[flan-t5](https://huggingface.co/docs/transformers/model_doc/flan-t5)，[dolly-v2](https://github.com/databrickslabs/dolly)等等。

## [Nix初体验](https://mtlynch.io/notes/nix-first-impressions/)
[Nix](https://nix.dev/)是一种采用独特方法进行软件包管理和系统配置的工具。作者介绍了之前使用过的[Salt](https://github.com/saltstack/salt)和[Ansible](https://github.com/ansible/ansible)。关于这两者的对比，可以看这篇文章[Ansible vs Salt](https://www.redhat.com/en/topics/automation/ansible-vs-salt)。

对于Salt和Ansible完全不了解的小伙伴可以看下chatGPT的介绍，足够简洁了。
![](ansible_vs_salt.png)

作者介绍了Nix的多个好处，包括快速搭建，可本地部署，原子级修改等等。同时也说到Nix目前文档不足，想要用好Nix需要具备非常丰富的经验。最后也写了几个成功和失败的部署经验。

## [PostgreSQL重新考虑其基于进程的模型](https://lwn.net/SubscriberLink/934940/3abb2d4086680b78/)
这条新闻需要了解的前提是，PostgreSQL是一个多进程的数据库，在一个运行的PostgreSQL实例中，会有多个进程同时运行来协同完成不同的任务和处理多个客户端连接。

而今年六月初，PostgreSQL的重要贡献者之一Heikki Linnakangas提议将PostgreSQL改为基于线程的模型。他的理由如下：
- 进程模型已经不适应时代的发展，尤其不适用于大型机器。
- 进程的上下文切换开销过大，他认为这种开销以后还会继续增大，导致将花费大量时间在TLB缺失上。
- 进程模型对开发造成了成本，迫使项目维护大量重复的代码，包括几个在单一地址空间中不需要的内存管理机制。
- 他认为线程模型没有如上问题。

这个提议在论坛上引发大量讨论，首先就是认为这种涉及底层的更改会带来灾难性的后果，导致大量bug，使得现存的很多项目都无法运行。另外，这种转变为线程的好处是否足够明显，在转变初期，必然是线程和进程模式并存的方式，在这种情况下，是否有足够的动力让开发人员转变为线程方式。

这个问题的提出值得深思，一些古老的代码语言和框架，随着时代的发展，其底层架构很可能已经不适合现代了，但是整体大修的成本过高，带来的好处又不一定明显，对现有项目的运行却可能是灾难性的。这种事情曾在PHP6上发生过，PHP6尝试重构了字符串的底层实现，结果非常糟糕，使得PHP的发展几乎停滞了十年，最后重新发布了PHP7，字符串回归了PHP5的实现。

## [MVC不是MVC](https://collindonnell.com/mvc-isnt-mvc)
如今众所周知的MVC设计模式来源于1979年Xerox PARC的一名雇员Trygve Reenskaug在一篇论文中提出的，其原文仅500字，描述了每个部分的功能和作用，简单概括下就是：
- Models（模型）：应用程序中表示用于组织应用程序数据的抽象部分。模型的每个部分应该表示问题的一部分。当模型的数据发生变化时，模型会通知视图。
- Views（视图）：模型的可视化表示。视图通过直接查询模型进行更新，并且会收到模型的更新通知。视图可以直接更新其模型。视图不应直接了解键盘和鼠标事件等事物。
- Controllers（控制器）：用户和系统之间的连接。在屏幕上安排视图，接收用户输入，将消息传递给视图，并更新模型。

另外他还定义了一个特殊的控制器叫Editor：
- Editors（编辑器）：一种控制器，它临时插入在控制器和视图之间用于编辑。如果你想象一个联系人应用程序，当用户点击编辑时，可能会创建一个编辑器，然后在保存或取消时被丢弃，并根据需要更新模型。编辑器允许用户对数据进行修改，提供临时的编辑环境，并在编辑完成后将更改传递给模型。

在Reenskaug的设想里，MVC的每个部分都发挥着重要作用，其运作方式如下图：
![](mvc1.png)

#### MVC概念转变
如今概念里的MVC和他的最初定义已经大相径庭，苹果风格的MVC如下：
![](mvc2.png)
可以看出，View和Model的作用被大幅削弱，只是被动的给controller提供用户行为和数据，一切更新操作都由Controller来控制。

在1990年代，java的开发者提出一种新的MVC模型，叫Model-2，在这个模型里多了http的请求，请求经过controller，然后通过controller来返回view。
![](mvc3.jpeg)

可以看出，如今耳熟能详的MVC跟一开始的MVC已经完全不同，只是保留了模型中的三个概念，每个概念发挥的作用却已经完全不同。

## [AI带来了60年以来的第一种新的用户交互方式](https://www.nngroup.com/articles/ai-paradigm/)
ChatGPT和其他AI系统带来了在计算机历史上的第三种用户交互方式。
![](UI-paradigm.jpeg)
#### 第一种交互方式：批处理进程
在1945年计算机诞生之初，用户需要通过在打孔卡片上输入一系列需要计算机完成的完整工作流程，来让计算机一次性完成。用户体验当然是非常糟糕的，在计算机执行完任务之前，用户和计算机之间无法有任何其他交互。而每次结果出来往往需要隔天才能拿到，用户根据结果对打孔卡片进行调整，继续执行用户，最终要数天才能执行完成一个任务。

#### 第二种交互方式：基于命令的交互设计
大约在1964年，时分共享的出现（通过连接的终端使多个用户共享一台大型机）引导了第二种用户界面范式：基于命令的交互。这个时候，用户的输入可以得到计算机的反馈，从而调整自己的命令输入，而且可以精细到每次只用输入一行命令。包括dos的命令行界面，全屏文本终端（IBM），图形化界面都是属于这种交互方式。

#### 第三种交互方式：意图导向的交互方式
在AI模型下，你不用像过去那样告诉计算机**做什么**，而是直接告诉计算机**你想要什么**。作者举了个例子，比如你想要如下一幅画，
> 为一本低俗科幻杂志的封面绘制一幅合适的插图，画面中展示了一个穿着太空服的牛仔在一个无氧行星上，天空中有两颗红色的月亮。

在AI出现之前，你需要在photoshop上进行大量的操作来达到你的意图，而如今你直接告诉AI就可以。
![](redmoon.jpeg)

作者认为，未来的人工智能系统很可能会采用混合用户界面，结合意图导向和基于命令的界面元素，同时保留许多图形用户界面的元素。
