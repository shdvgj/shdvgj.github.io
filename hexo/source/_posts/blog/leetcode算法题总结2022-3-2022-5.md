---
title: leetcode算法题总结2022.3-2022.5
date: 2022-05-09 16:01:53
comments: true
categories: 
- 学习
---
## 最小路径和

基本思路：动态规划，每个格子依次计算，计算当前格子的最小路径和，因为每次移动必定是往下或者往右，因此每个格子的路径和必定来自于上边格子或者左边格子的数字加上当前格子的数字
时间复杂度分析：O(m*n)，会遍历所有格子，因此复杂度是n*m

```java
/**
 * 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
 *
 * 说明：每次只能向下或者向右移动一步。
 *
 * 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
 * 输出：7
 * 解释：因为路径 1→3→1→1→1 的总和最小。
 *
 * 提示：
 *
 *     m == grid.length
 *     n == grid[i].length
 *     1 <= m, n <= 200
 *     0 <= grid[i][j] <= 100
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/minimum-path-sum
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */

public class MinPathSum {
    static int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;
        int n = grid.length ;
        int m = grid[0].length;
        // 动态规划
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0 && j== 0) continue;
                if (i == 0) {
                    grid[0][j] += grid[0][j-1];
                    continue;
                }
                if (j == 0) {
                    grid[i][0] += grid[i-1][0];
                    continue;
                }
                if (grid[i-1][j] > grid[i][j-1]) {
                    grid[i][j] += grid[i][j-1];
                } else {
                    grid[i][j] += grid[i-1][j];
                }
            }
        }
        return grid[n-1][m-1];
    }

    public static void main(String[] args) {
        System.out.println(minPathSum(new int[][]{}));
    }
}
```

## 排序矩阵查找

基本思路：从右上角开始遍历，左边是比它小的，下边是比它大的，相当于是一个二叉树遍历
时间复杂度分析：O(m*n)，会遍历所有格子，因此复杂度是n*m

```java
/**
 * 给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
 *
 * 示例:
 *
 * 现有矩阵 matrix 如下：
 *
 * [
 *   [1,   4,  7, 11, 15],
 *   [2,   5,  8, 12, 19],
 *   [3,   6,  9, 16, 22],
 *   [10, 13, 14, 17, 24],
 *   [18, 21, 23, 26, 30]
 * ]
 *
 * 给定 target = 5，返回 true。
 *
 * 给定 target = 20，返回 false。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/sorted-matrix-search-lcci
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */

public class SearchMatrix {
    // 基本思路，从右上角开始遍历，左边是比它小的，下边是比它大的，相当于是一个二叉树遍历
    static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int n = 0;
        int m = matrix[0].length - 1;
        while (true) {
            if (matrix[n][m] == target) return true;
            if (matrix[n][m] > target) m--;
            else n++;
            if (m < 0 || n >= matrix.length) return false;
        }
    }

    public static void main(String[] args) {
        System.out.println(searchMatrix(new int[][]{{}}, 18));
    }
}
```

## 合并若干三元组以形成目标三元组

基本思路：根据题设可知，每次合并都会取各个位置更大的那个数，因此如果一个数组中的任一位置存在比目标数更大的数，则这个数组一定不能进行合并；反之，如果一个数组的任一位置存在目标数，且其他各位置的数都比目标数小，则一定能进行合并

```java
/**
 * 三元组 是一个由三个整数组成的数组。给你一个二维整数数组 triplets ，其中 triplets[i] = [ai, bi, ci] 表示第 i 个 三元组 。同时，给你一个整数数组 target = [x, y, z] ，表示你想要得到的 三元组 。
 *
 * 为了得到 target ，你需要对 triplets 执行下面的操作 任意次（可能 零 次）：
 *
 *     选出两个下标（下标 从 0 开始 计数）i 和 j（i != j），并 更新 triplets[j] 为 [max(ai, aj), max(bi, bj), max(ci, cj)] 。
 *         例如，triplets[i] = [2, 5, 3] 且 triplets[j] = [1, 7, 5]，triplets[j] 将会更新为 [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5] 。
 *
 * 如果通过以上操作我们可以使得目标 三元组 target 成为 triplets 的一个 元素 ，则返回 true ；否则，返回 false 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
 * 输出：true
 * 解释：执行下述操作：
 * - 选择第一个和最后一个三元组 [[2,5,3],[1,8,4],[1,7,5]] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],[2,7,5]]
 * 目标三元组 [2,7,5] 现在是 triplets 的一个元素。
 *
 * 示例 2：
 *
 * 输入：triplets = [[1,3,4],[2,5,8]], target = [2,5,8]
 * 输出：true
 * 解释：目标三元组 [2,5,8] 已经是 triplets 的一个元素。
 *
 * 示例 3：
 *
 * 输入：triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
 * 输出：true
 * 解释：执行下述操作：
 * - 选择第一个和第三个三元组 [[2,5,3],[2,3,4],[1,2,5],[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。
 * - 选择第三个和第四个三元组 [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]] 。
 * 目标三元组 [5,5,5] 现在是 triplets 的一个元素。
 *
 * 示例 4：
 *
 * 输入：triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
 * 输出：false
 * 解释：无法得到 [3,2,5] ，因为 triplets 不含 2 。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class MergeTriplets {
    static boolean mergeTriplets(int[][] triplets, int[] target) {
        if (triplets == null || target == null || triplets.length == 0 || triplets[0].length == 0 || target.length == 0) return false;
        int one = target[0];
        int two = target[1];
        int three = target[2];
        boolean oneJudge = false;
        boolean twoJudge = false;
        boolean threeJudge = false;
        for (int i = 0; i < triplets.length; i++) {
            if (!oneJudge && triplets[i][0] == one && triplets[i][1] <= two && triplets[i][2] <= three) oneJudge = true;
            if (!twoJudge && triplets[i][1] == two && triplets[i][0] <= one && triplets[i][2] <= three) twoJudge = true;
            if (!threeJudge && triplets[i][2] == three && triplets[i][0] <= one && triplets[i][1] <= two) threeJudge = true;
            if (oneJudge && twoJudge && threeJudge) return true;
        }
        return false;
    }

    public static void main(String[] args) {
        System.out.println(mergeTriplets(new int[][]{{2,5,3},{1,8,4},{1,7,5}}, new int[]{2,5,3}));
    }
}
```

## 二叉搜索树与双向链表

基本思路：本质上是一个将二叉树按大小输出的问题，使用中序遍历可以实现。同时需要将头尾连接，因此存储头部结点，直到中序遍历结束，将最后的结点指向头部结点。

```java
/**
 * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
 *
 * 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */

class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
}

public class TreeToDoublyList {
    static Node head, pre;
    static Node treeToDoublyList(Node root) {
        if (root == null) return root;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    static void dfs(Node node) {
        // 中序遍历，按大小输出结点
        if (node == null) return;
        dfs(node.left);
        if (head == null) head = node;
        else {
            pre.right = node;
            node.left = pre;
        }
        pre = node;
        dfs(node.right);
    }

}
```

## 两个相同字符之间的最长子字符串

基本思路：
        1.题设只有小写字母，因此可以用一个容量26的数组来进行存储。
        2.按顺序遍历数组，将每个字母出现的位置索引存储在数组中，当找到重复的字母时，将其位置和数组中的索引进行相减，得到的结果和已存储的最大值比较，如果当前结果更大，将最大值替换
        3.返回最大值

```java
/**
 * 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。
 *
 * 子字符串 是字符串中的一个连续字符序列。

 * 示例 1：
 *
 * 输入：s = "aa"
 * 输出：0
 * 解释：最优的子字符串是两个 'a' 之间的空子字符串。
 *
 * 示例 2：
 *
 * 输入：s = "abca"
 * 输出：2
 * 解释：最优的子字符串是 "bc" 。
 *
 * 示例 3：
 *
 * 输入：s = "cbzxy"
 * 输出：-1
 * 解释：s 中不存在出现出现两次的字符，所以返回 -1 。
 *
 * 示例 4：
 *
 * 输入：s = "cabbac"
 * 输出：4
 * 解释：最优的子字符串是 "abba" ，其他的非最优解包括 "bb" 和 "" 。
 *

 * 提示：
 *
 *     1 <= s.length <= 300
 *     s 只含小写英文字母
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/largest-substring-between-two-equal-characters
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class MaxLengthBetweenEqualCharacters {
    // 基本思路：遍历一遍，时间复杂度O(N)，通过map存储已经存在的字符，在遍历时再次发现该字符的话就把两个位置的值相减并和已存储的最大值进行比较
    /*static int maxLengthBetweenEqualCharacters(String s) {
        if (s == null || s.length() == 0) return -1;
        Map<Character, Integer> map = new HashMap<>();
        char[] characters = s.toCharArray();
        int result = 0;
        int temp;
        char ch;
        for (int i = 0; i < characters.length; i++) {
            ch = characters[i];
            if (map.containsKey(ch)) {
                temp = i - map.get(ch);
                if (temp > result) result = temp;
            } else {
                map.put(ch, i);
            }
        }
        return result - 1;
    }*/

    static int maxLengthBetweenEqualCharacters(String s) {
        // 不使用map的方案
        if (s == null || s.length() == 0) return -1;
        int[] alpha = new int[26];//ASCII字符长度
        char[] characters = s.toCharArray();
        int result = -1;
        int temp;
        int ch;
        for (int i = 0; i < characters.length; i++) {
            ch = characters[i] - 97; // a的ascII位置是97
            if (alpha[ch] > 0) {
                temp = i - alpha[ch];
                if (temp > result) result = temp;
            } else {
                alpha[ch] = i + 1; // int数组默认初始化为0，所以需要通过+1和初始0值进行区分
            }
        }
        return result;
    }

}

```

## 替换隐藏数字得到的最晚时间

基本思路：由于固定是XX:XX的格式字符串，因此需要处理的无非是四个位置的字符。后两位的字符如果出现'?'，那一定是可以替换为5和9。前两位出现'?'，需要考虑：
        1.第一位是'?'，需要看第二位的值，如果大于3，那第一位只能是1，因为不存在24-29点这样的值；如果第二位是1，2，3，那第一位可以是2
        2.第二位是'?'，需要看第一位的值，如果是2，那第二位最大是3；如果是第一位是1，那第二位最大可以是9

```java
/**
 * 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。
 *
 * 有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。
 *
 * 替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。
 *
 *
 *
 * 示例 1：
 *
 * 输入：time = "2?:?0"
 * 输出："23:50"
 * 解释：以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50 。
 *
 * 示例 2：
 *
 * 输入：time = "0?:3?"
 * 输出："09:39"
 *
 * 示例 3：
 *
 * 输入：time = "1?:22"
 * 输出："19:22"
 *
 *
 *
 * 提示：
 *
 *     time 的格式为 hh:mm
 *     题目数据保证你可以由输入的字符串生成有效的时间
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class MaximumTime {
    static String maximumTime(String time) {
        char[] chars = time.toCharArray();
        if (chars[0] == '?') {
            // 直接比较字符大小时就是比较在ASCII码的大小
            if (chars[1] > '3' && chars[1] <= '9') chars[0] = '1';
            else chars[0] = '2';
        }
        if (chars[1] == '?') {
            if (chars[0] == '1' || chars[0] == '0') chars[1] = '9';
            else chars[1] = '3';
        }
        if (chars[3] == '?') chars[3] = '5';
        if (chars[4] == '?') chars[4] = '9';
        return String.valueOf(chars);
    }

    public static void main(String[] args) {
        System.out.println(maximumTime("?4:03"));
    }
}
```

## 拆分字符串使唯一子字符串的数目最大

基本思路：需要遍历所有的子字符串可能，用到递归+回溯

```java
/**
 * 给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。
 *
 * 字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。
 *
 * 注意：子字符串 是字符串中的一个连续字符序列。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "ababccc"
 * 输出：5
 * 解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。
 *
 * 示例 2：
 *
 * 输入：s = "aba"
 * 输出：2
 * 解释：一种最大拆分方法为 ['a', 'ba'] 。
 *
 * 示例 3：
 *
 * 输入：s = "aa"
 * 输出：1
 * 解释：无法进一步拆分字符串。
 *
 *
 *
 * 提示：
 *
 *     1 <= s.length <= 16
 *
 *     s 仅包含小写英文字母
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class MaxUniqueSplit {
    int ct = 1;
    int length = 1;

    // aac a
    int maxUniqueSplit(String s) {
        Set<String> set = new HashSet<>(16);
        length = s.length();
        maxUniqueSplit(0, 0, s, set);
        return ct;
    }

    void maxUniqueSplit(int index, int split, String s, Set<String> set) {
        if (ct < split) ct = split;
        for (int i = index; i < length; i++) {
            if (length - i + split < ct) break;// 关键步骤，判断当前切分数加上剩余数组长度是否大于最大切分数，如果不大于，则没有必要进一步切分
            String substring = s.substring(index, i+1);
            if (set.add(substring)) {
                maxUniqueSplit(i + 1, split + 1, s, set);
                set.remove(substring);
            }
        }
    }

    int count=0;
    char[] arr;
    Set<String> lookUp;
    public int maxUniqueSplit_2(String s) {
        arr=s.toCharArray();
        lookUp=new HashSet<>();
        dfs(0,0,arr,s.length());
        return count;
    }

    private void dfs(int begin,int cur_depth,char[] arr,int remain_length){
        if(remain_length==0){
            count=Math.max(cur_depth,count);
            return;
        }
        for(int start=begin,end=begin;end<arr.length;end++){
            int left_length=arr.length-end-1;
            if(cur_depth+1+left_length<=count)
                break;
            String temp=new String(arr,start,end-start+1);
            if(lookUp.contains(temp))
                continue;

            lookUp.add(temp);
            dfs(end+1,cur_depth+1,arr,left_length);
            lookUp.remove(temp);
        }

    }

}
```

## 两个链表的第一个公共节点

基本思路：两个链表的长度可能不一，长度分别为m和n。必然有m+n=n+m。
情况一：两个链表相交

链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m ，b+c=n。

    如果 a=b，则两个指针会同时到达两个链表的第一个公共节点，此时返回两个链表的第一个公共节点；

    如果 a≠b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表的第一个公共节点，该节点也是两个指针第一次同时指向的节点，此时返回两个链表的第一个公共节点。

情况二：两个链表不相交

链表 headA\textit{headA}headA 和 headB\textit{headB}headB 的长度分别是 mmm 和 nnn。考虑当 m=nm=nm=n 和 m≠nm \ne nm​=n 时，两个指针分别会如何移动：

    如果 m=n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 null，此时返回 null；

    如果 m≠n，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 pB 移动了 n+m 次之后，两个指针会同时变成空值 null，此时返回 null。

```java
/**
 * 输入两个链表，找出它们的第一个公共节点。
 *
 * 如下面的两个链表：
 *
 * 在节点 c1 开始相交。
 *
 *
 *
 * 示例 1：
 *
 * 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
 * 输出：Reference of the node with value = 8
 * 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 *
 *
 *
 * 示例 2：
 *
 * 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
 * 输出：Reference of the node with value = 2
 * 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
 *
 *
 *
 * 示例 3：
 *
 * 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
 * 输出：null
 * 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
 * 解释：这两个链表不相交，因此返回 null。
 *
 *
 *
 * 注意：
 *
 *     如果两个链表没有交点，返回 null.
 *     在返回结果后，两个链表仍须保持原有的结构。
 *     可假定整个链表结构中没有循环。
 *     程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
 *     本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class GetIntersectionNode {
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode head1 = headA;
        ListNode head2 = headB;
        while (head1 != head2) {
            head1 = head1 != null ? head1.next:headB;
            head2 = head2 != null ? head2.next:headA;
        }
        return head1;
    }
}
```